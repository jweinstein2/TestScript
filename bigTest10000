		swap(&q1, &q2);
				numElements++;
					return 1;
			if(!removeQ(&q1, &stringToAdd)){
}
						DIE("removeQ failed");
					bigLeftToMerge2--;
		}
		else{
					if(!removeQ(&q1, &stringToAdd)){

			//free(line);
		while(bigLeftToMerge1 > 0){
#include <string.h>
			while(leftToMerge1 > 0 && leftToMerge2 > 0){
    // check if the queue is empty
					}
		if(!headQ(&q1, &head1) || !headQ(&q2, &head2)){
			len = strtol(line + 1, &line, 10);
		// now check if LEN is specified, and if it isn't, set it to INT_MAX
	// head1 and head2
					}
								to stop merging
			}
		}
				// if we have a tie, remove from the queue that has priority
			bigLeftToMerge1 = bigLeftToMerge2;

			}
					if(!removeQ(&q1, &stringToAdd)){


		printf("size to merge bottom: %d\n", sizeToMerge);
					DIE("headQ failed");
			while(leftToMerge2 > 0){
				}
					if(isEmptyQ(&q1)){
			qSize1 = qSize2;
		(*fileIndex)++;
	// now loop through the rest of the args and read them as files
		DIE("createQ() failed!");
        free(nodeToRemove);
			bigLeftToMerge2--;
	}
			}
	// if there's stuff left over from the first queue
	Queue q1 = NULL, q2 = NULL;
				}
	bigLeftToMerge2 = qSize2;
	// otherwise there's stuff left over from the second queue
2/29	4:00pm		1 hour		Discussed problem statement with Jared Weinstein
				DIE("removeQ failed");
}// hold two copies of the list in the beginning and 
			if(!removeQ(&q2, &stringToAdd)){
		firstFileArg = 2;


			}
								for bigger files
					return 1;
*/
		// now we've finished the merging -- now some housekeeping
void swap(Queue *q1, Queue *q2){
			}
					if(!removeQ(&q1, &stringToAdd)){
				int tmp = qSize1;
		printf("%s", stringToAdd);
		qSize1 = qSize2;
				numElements++;
			// otherwise there's stuff left over from the second queue
		if(strcmp(head1, head2) < 0){
// function that takes in two ints (a and b) and returns the smaller of the two
	// we'll always add to q1, then swap each time
			bigLeftToMerge1--;

			//free(line);


		pos = strtol(argv[1] + 1, &line, 10);
				qSize1++;

			qSize1 = qSize2;
		qSize1 = qSize2;
		if(*fileToRead == NULL){
		else{
		(*fileIndex)++;
		// empty
// function to swap two queues (i.e. swap the pointers to the two nodes)
3/10	9:30pm		.5 hours	Debugged, but now it infinite loops instead of
				if(!addQ(&q1, stringToAdd)){
			fullCommand = strcat(fullCommand, " ");
}
#include <limits.h>
	int leftToMerge1 = 1, leftToMerge2 = 1;

		sizeToMerge *= 2;
	// the lines (either pos or the length of the string)
					DIE("addQ failed");
				qSize1++;
	char *line, *head1, *head2, *stringToAdd;
			// otherwise there's stuff left over from the second queue
								and Annie Chen						

	// now we can finally start mergesorting!
#include <string.h>
				}
		else{
		// various indices)

	char *line, *head1, *head2, *stringToAdd;
	// otherwise there's stuff left over from the second queue
				if(!addQ(&q1, line)){
3/15	8:00pm		1 hour		Now it sorts! Working on incorporating pos,len,
			while(qPos1 < stopMergeIndex1){
				leftToMerge2--;
		// if we have a tie, remove from the queue that has priority
		}
				// if we have a tie, remove from the queue that has priority
	*q2 = dummy;
	// now we can finally start mergesorting!
				bigLeftToMerge2--;
				DIE("removeQ failed");
    *q = newNode;
	Queue dummy = *q1;
		free(stringToAdd);
		free(stringToAdd);
		}
	if(argc == 1){
		leftToMerge1 = leftToMerge2 = sizeToMerge;
		printf("%s", stringToAdd);
				printf("bigLeftToMerges: %d %d\n", bigLeftToMerge1, bigLeftToMerge2);
					}
#include <stdlib.h>
					bigLeftToMerge1--;
			DIE("removeQ failed");
	*q1 = *q2;
		}

		printf("biglefts: %d %d\n", bigLeftToMerge1, bigLeftToMerge2);
	}
	// now loop through the rest of the args and read them as files
		// if we have a tie, remove from the queue that has priority
		printf("biglefts: %d %d\n", bigLeftToMerge1, bigLeftToMerge2);

		}
		sizeToMerge *= 2;
				// if we have a tie, remove from the queue that has priority
	}
3/3		1:30pm		1 hour		Started work on Queue.c, have first version of
		// compare the two values, remove from whichever one is smaller
					if(!removeQ(&q2, &stringToAdd)){
				bigLeftToMerge1--;
				qSize1 = qSize2;
	}
		bigLeftToMerge2 = qSize2;
		if(!removeQ(&q2, &stringToAdd)){
		// if we have excess on the first queue...the other queue should be
				DIE("removeQ failed");
		}
		else{
#include <stdbool.h>
			// otherwise there's stuff left over from the second queue
				qSize2--;
	// for(int i = 2; i < argc; i++){
		while(bigLeftToMerge2 > 0){
#include <string.h>
					qSize2--;

						DIE("removeQ failed");
		qSize1 = qSize2;
			bigLeftToMerge2--;
			}
					return 1;
				}
					qSize1--;
				}
// function to swap two queues (i.e. swap the pointers to the two nodes)
						DIE("removeQ failed");
		}
	call got NULL, and I had to worry about whether the next file existed, or
		// compare the two values, remove from whichever one is smaller
	if(!createQ(&q1) || !createQ(&q2)){

    }
			while(leftToMerge1 > 0 && leftToMerge2 > 0){
			if(!removeQ(&q2, &stringToAdd)){

				}
    *q = temp;
// offset the bottom one by one. Then keep comparing heads until
int createQ (Queue *q)

int main(int argc, char *argv[]){
		leftToMerge1 = leftToMerge2 = sizeToMerge;
		return 1;
				if(!addQ(&q1, stringToAdd)){

	// we don't have to merge the last time -- just print out
				}
	to call getLine() twice per loop and then running a lot of cases on which
	// now we can finally start mergesorting!
					}
				DIE("removeQ failed");
				DIE("removeQ failed");
				printf("size we're merging: %d\n", sizeToMerge);
    // if s doesn't point to anything
						DIE("removeQ failed");
				}
	// one
				// so we have to check whether the queues are reversed
					}
		printf("biglefts: %d %d\n", bigLeftToMerge1, bigLeftToMerge2);
			}
		// call headQ and store values into head1 and head2
	// if we've had an odd number of swaps, swap again to keep q1 as priority
		swap(&q1, &q2);
			// otherwise there's stuff left over from the second queue
				}
	// we'll always add to q1, then swap each time
						return 1;
				}
				bigLeftToMerge1--;
					return 1;
		while(bigLeftToMerge1 > 0){
				// switch up the queues so that you split up the strings
		}
		}
		else if(strcmp(head1, head2) > 0){
int isEmptyQ (Queue *q)
	while(!isEmptyQ(&q1) && !isEmptyQ(&q2)){
					if(!removeQ(&q1, &stringToAdd)){

	while(!isEmptyQ(&q2)){
			if(!addQ(&q1, stringToAdd)){

		if(line[0] == ','){
			//free(line);
				if(strcmp(head1, head2) < 0){
	// now we can finally start mergesorting!
			// merge or the end of a queue
					return 1;
		// now we've finished the merging -- now some housekeeping
					return 1;
		printf("%s", stringToAdd);

				}
				leftToMerge2--;
People I consulted with: Jared Weinstein, Annie Chen, Will Merrill
#include "/c/cs223/Hwk3/getLine.h"
    }
				}
					leftToMerge1--;
	int qSize1 = 0, qSize2 = 0, bigLeftToMerge2, bigLeftToMerge1;
				else{
				else if(strcmp(head1, head2) > 0){
				}
		if(line[0] == ','){

		// if fopen throws an error
				leftToMerge1--;
	}
					}
	int firstFileArg = 1, sizeToMerge = 1, numElements = 0;
			while((line = getLine(inFile)) != NULL){
			}
					return 1;

				if(!addQ(&q1, stringToAdd)){
		leftToMerge1 = leftToMerge2 = sizeToMerge;
			// open the file and loop through the lines
		qSize1 = qSize2;
	int qSize1 = 0, qSize2 = 0, bigLeftToMerge2, bigLeftToMerge1;
			}
	if(!createQ(&q1) || !createQ(&q2)){
			DIE("removeQ failed");
				if(!addQ(&q1, line)){
	}
				DIE("removeQ failed");
    return true;
	// otherwise there's stuff left over from the second queue
			qSize2--;
			if(!removeQ(&q1, &stringToAdd)){
				qSize1 = qSize2;
	int qSize1 = 0, qSize2 = 0, bigLeftToMerge2, bigLeftToMerge1;
		// this probably shouldn't ever happen but i'll do this just in case
			if(!removeQ(&q2, &stringToAdd)){
		}
		return 1;
			swap(&q1, &q2);
					DIE("addQ failed");
		// call headQ and store values into head1 and head2
				if(!addQ(&q1, line)){
			}
			while(leftToMerge1 > 0 && leftToMerge2 > 0){
		int tmp = qSize1;

		}
		}
		firstFileArg = 2;
				}
			}
		if(!removeQ(&q1, &stringToAdd)){
    if(s == NULL){
			qSize1 = qSize2;
		reversed = !reversed;
		}
		stdInput = strncpy(stdInput, line, strlen(line) - 1);
			DIE("removeQ failed");
			line1[lineSize1 - 1] = '\0';
			}
	destroyQ(&q1);
// From then on, just keep comparing heads until one of the queues is empty
// the node
						return 1;
			swap(&q1, &q2);
				DIE("removeQ failed");
	destroyQ(&q2);
3/10	8:30pm		1 hour		Change method of keeping track of indexes when
				}
				// now add the string to whichever queue we're currently adding to 
		}
	fclose(inFile);
// between consecutive merges
		}
		// this probably shouldn't ever happen but i'll do this just in case
		}
		swap(&q1, &q2);
		qSize2 = tmp;
3/15	8:00pm		1 hour		Now it sorts! Working on incorporating pos,len,

								most functions								
		sizeToMerge *= 2;
 				
		// POS or the end of the string)
		}
			if(!removeQ(&q2, &stringToAdd)){
	while(!isEmptyQ(&q1) && !isEmptyQ(&q2)){
        free(*q);
#define DIE(msg) exit(fprintf(stderr, "%s\n", msg))

				// compare the two values, remove from whichever one is smaller
				if(!addQ(&q1, stringToAdd)){
					}
// From then on, just keep comparing heads until one of the queues is empty
				// add each line in q1

					return 1;
				DIE("addQ failed");
// offset the bottom one by one. Then keep comparing heads until
			// otherwise there's stuff left over from the second queue
				// add each line in q1
	*q1 = *q2;
*/
    // check if the queue is empty
			if(!removeQ(&q1, &stringToAdd)){
		}
3/10	8:30pm		1 hour		Change method of keeping track of indexes when
				}



		fullCommand = strcpy(fullCommand, echo);
			DIE("removeQ failed");
				}
	}
3/3		1:30pm		1 hour		Started work on Queue.c, have first version of
				leftToMerge1--;
		reversed = !reversed;
		// compare the two values, remove from whichever one is smaller
// Returns true if operation succeeded, false if it failed
    }
#include "/c/cs223/Hwk4/Queue.h"
		// empty
	int firstFileArg = 1, sizeToMerge = 1, numElements = 0;

						DIE("removeQ failed");
				if(!addQ(&q1, stringToAdd)){
			}
        (*newNode).next = (**q).next;
					return 1;
			qSize1 = qSize2;
			qSize1++;
					DIE("removeQ failed");
	long pos, len;
	two at a time and essentially do the first merge as I filled in the queues
		// if we have excess on the first queue...the other queue should be
3/15	8:00pm		1 hour		Now it sorts! Working on incorporating pos,len,
    if(isEmptyQ(q)){

			// otherwise there's stuff left over from the second queue
	int leftToMerge1 = 1, leftToMerge2 = 1;
	int firstFileArg = 1, sizeToMerge = 1, numElements = 0;
					qSize1--;

		qSize1 = qSize2;
		leftToMerge1 = leftToMerge2 = sizeToMerge;

		}
	int firstFileArg = 1, sizeToMerge = 1, numElements = 0;
				}
	}

			}
		}
        }
		swap(&q1, &q2);

		}
        free(*q);
			while((line = getLine(inFile)) != NULL){
	destroyQ(&q1);
			while(leftToMerge1 > 0 && leftToMerge2 > 0){
		// empty
			// open the file and loop through the lines
		printf("%s", stringToAdd);
				return 1;
 -- Reading in the files was initially a challenge, as I was initally planning
			swap(&stopMergeIndex2, &stopMergeIndex1);
			// if there's stuff left over from the first queue
	int fileArg = 1, sizeToMerge = 2, numElements = 0;
			qSize1 = qSize2;
			DIE("removeQ failed");
					DIE("addQ failed");
#include <limits.h>
	// the same time
		// compare the two values, remove from whichever one is smaller
		int tmp = qSize1;
2/29	4:00pm		1 hour		Discussed problem statement with Jared Weinstein
Difficulties I ran into:
					if(!removeQ(&q2, &stringToAdd)){
					DIE("headQ failed");
						return 1;

	int fullLength, argLength, test;
			}
		// compare the two values, remove from whichever one is smaller
						return 1;
					break;
			if(!addQ(&q1, stringToAdd)){
		if(!removeQ(&q2, &stringToAdd)){
3/15	8:00pm		1 hour		Now it sorts! Working on incorporating pos,len,
		sizeToMerge *= 2;

				// we don't free since the queue still points to the same addr
					bigLeftToMerge2--;
		if(!headQ(&q1, &head1) || !headQ(&q2, &head2)){
				}
		qSize1 = qSize2;
		swap(&q1, &q2);
				// now add the string to whichever queue we're currently adding to 
		inFile = fopen(argv[i], "r");


		int tmp = qSize1;
		firstFileArg = 2;
			if(!addQ(&q1, stringToAdd)){
			// open the file and loop through the lines
					if(isEmptyQ(&q1)){
			}
		// now we've finished the merging -- now some housekeeping
				qSize1++;
				if(!addQ(&q1, stringToAdd)){
			bigLeftToMerge2 = tmp;

		// empty
				if(!addQ(&q1, stringToAdd)){
3/9		8:45pm		1 hour		Mostly fixed the mergesort algorithm, but it
				}

	int leftToMerge1 = 1, leftToMerge2 = 1;
#define DIE(msg) exit(fprintf(stderr, "%s\n", msg))
	if(qSize2 > qSize1){

	*q1 = *q2;
	various while loops, so it took me three or four tries of redoing my code
void swap(int *arg1, int *arg2);
	// q1 and q2 are the two queues we're using
	was empty, or had another line. Then I wrote a new getLine function which
						DIE("removeQ failed");
	// for(int i = 2; i < argc; i++){
// function to swap two queues (i.e. swap the pointers to the two nodes)
		DIE("createQ() failed!");
				bigLeftToMerge2--;
						DIE("removeQ failed");
			while(leftToMerge2 > 0){
			qSize2 = tmp;
		else if(strcmp(head1, head2) > 0){
// memory associated with it
} Node;
	int qSize1 = 0, qSize2 = 0, bigLeftToMerge2, bigLeftToMerge1;
	FILE *inFile;
				if(strcmp(head1, head2) < 0){
		qSize2 = tmp;
		}
					qSize2--;
			int tmp = qSize1;

				DIE("removeQ failed");
		firstFileArg = 2;
}
				}
void swap(Queue *arg1, Queue *arg2);
		// if we have excess on the first queue...the other queue should be
#include <stdio.h>
	while(!isEmptyQ(&q1) && !isEmptyQ(&q2)){
				}
		}
	int qSize1 = 0, qSize2 = 0, bigLeftToMerge2, bigLeftToMerge1;
				DIE("addQ failed");
	// where we want to stop once qPos1 or qPos2 hits them (i.e. the end of a
				}
}
					bigLeftToMerge1--;
								most functions								
						DIE("removeQ failed");

		printf("size to merge bottom: %d\n", sizeToMerge);
				// between the two queues
			}
		swap(&q1, &q2);
	int leftToMerge1 = 1, leftToMerge2 = 1;
			bigLeftToMerge2--;
				DIE("removeQ failed");
				qSize1++;
				}
		// if fopen throws an error
	// now we print out the things in the queues, doing the last merge at
// function to swap two queues (i.e. swap the pointers to the two nodes)
			if(!removeQ(&q1, &stringToAdd)){
			}
			while(qPos1 < stopMergeIndex1 && qPos2 < stopMergeIndex2) {	
	// the same time
			}
				}
		// to by checking whether the queues are switched
						printf("q1 is empty\n");
		// various indices)
			if(!removeQ(&q1, &stringToAdd)){
	// if we've had an odd number of swaps, swap again to keep q1 as priority

					DIE("addQ failed");
				else if(strcmp(head1, head2) > 0){
			if(!addQ(&q1, stringToAdd)){
	FILE *inFile;
		else{
					DIE("addQ failed");
				if(!addQ(&q1, stringToAdd)){
			while((line = getLine(inFile)) != NULL){
// offset the bottom one by one. Then keep comparing heads until
    // by pointing it to the first node and making the previous node point to it
				qSize1++;
char *newGetLine(char *argv[], int argc, FILE **fileToRead, int *fileIndex){
			qSize2--;

			}
    // if malloc fails, return false
						DIE("removeQ failed");
#include "/c/cs223/Hwk4/Queue.h"
    // frees each of the nodes)
	int qSize1 = 0, qSize2 = 0, bigLeftToMerge2, bigLeftToMerge1;
				if(!removeQ(&q2, &stringToAdd)){
				int tmp = qSize1;
					if(!removeQ(&q2, &stringToAdd)){
	}
	// if there's stuff left over from the first queue

	}
					return 1;
		while(bigLeftToMerge1 > 0 && bigLeftToMerge2 > 0){
		}
#include <stdlib.h>
				swap(&q1, &q2);
	}
			if(!removeQ(&q1, &stringToAdd)){
    return true;
				printf("bigLeftToMerges: %d %d\n", bigLeftToMerge1, bigLeftToMerge2);
	}
#include "/c/cs223/Hwk3/getLine.h"
				qSize2--;
        return false;

	addQ()s, as the one that I originally had workd in N ceil(Log(N)).
		offset2 = min(pos, strlen(head2));
			while(leftToMerge1 > 0){
    Node *newNode = malloc(sizeof(Node));
			return 1;
			// onto as well as the respective indices and positions
								very far
					leftToMerge2--;
		// compare the two values, remove from whichever one is smaller

								queue
			DIE("removeQ failed");
int main(int argc, char *argv[]){
					qSize2--;
			swap(&q1, &q2);
		if(!headQ(&q1, &head1) || !headQ(&q2, &head2)){
					}
			}
3/8		3:00pm		1 hour		Finished implementing all of mergesort but it
	// stringToAdd will point to the string that is smaller when comparing
					}
			qSize2--;
				qSize2--;
				DIE("addQ failed");
		if(line[0] == ','){
}// hold two copies of the list in the beginning and 
				// we don't free since the queue still points to the same addr
			}
		if(strcmp(head1, head2) < 0){
	// printf("%d\n", argLength);
	long pos = 0, len = INT_MAX;
		pos = strtol(argv[1] + 1, &line, 10);
					return 1;


		// if we have excess on the first queue...the other queue should be
		}
	if(argv[1][0] == '-'){
				if(!addQ(&q1, stringToAdd)){
			}
					qSize1--;

		offset1 = min(pos, strlen(head1));
    return true;
int isEmptyQ (Queue *q)
	long pos, len;
		if(inFile == NULL){
#include <limits.h>
			}
		// various indices)
			// otherwise there's stuff left over from the second queue
		return newGetLine(argv, argc, fileToRead, fileIndex);
			DIE("File could not be opened!");
		// this probably shouldn't ever happen but i'll do this just in case
				// now add the string to whichever queue we're currently adding to 
			}
								most functions								
		}
	for(int i = firstFileArg; i < argc; i++){
	while(!isEmptyQ(&q1)){
		printf("biglefts: %d %d\n", bigLeftToMerge1, bigLeftToMerge2);
	// inFile is a pointer to the file we're reading in
			if(!addQ(&q1, stringToAdd)){
						printf("q1 is empty\n");
		}
		swap(&q1, &q2);
					leftToMerge2--;
					bigLeftToMerge1--;
			}
	// the lines (either pos or the length of the string)
				DIE("addQ failed");
		firstFileArg = 2;
				DIE("addQ failed");
			// otherwise there's stuff left over from the second queue
			}
				// compare the two values, remove from whichever one is smaller
ESTIMATE of total time I will spend: 16 hours
	was empty, or had another line. Then I wrote a new getLine function which
	}
void swap(int *a, int *b){
				else{

#include <string.h>
					return 1;
					}
					leftToMerge1--;
			if(line2[lineSize2 - 1] == '\n'){
			swap(&qPos1, &qPos2);
    if(isEmptyQ(q)){
	}
			}
					qSize1--;
			leftToMerge1 = leftToMerge2 = sizeToMerge;
			bigLeftToMerge2 = tmp;
					qSize1--;
		else{
				DIE("addQ failed!");
					DIE("addQ failed");
	return 0;
	return 0;
    // if the queue is empty, it has no head, so it fails
	*q2 = dummy;
		if(!headQ(&q1, &head1) || !headQ(&q2, &head2)){
void swap(Queue *q1, Queue *q2){
			}
					return 1;
	if(!createQ(&q1) || !createQ(&q2)){
		printf("biglefts: %d %d\n", bigLeftToMerge1, bigLeftToMerge2);
				leftToMerge2--;
 -- Reading in the files was initially a challenge, as I was initally planning
		// queue evenly
	bigLeftToMerge2 = qSize2;
			}
#include <stdio.h>
	for(int i = firstFileArg; i < argc; i++){
		}
					DIE("addQ failed!");
				DIE("removeQ failed");
		swap(&q1, &q2);
		}
						return 1;

	// make sure there's at least one argument after Merge16
}
		qSize1 = qSize2;
			bigLeftToMerge2 = tmp;
					if(isEmptyQ(&q1)){
	// if there's stuff left over from the first queue
			bigLeftToMerge2 = tmp;

				bigLeftToMerge2--;
				}
		if(line[0] == ','){
				qSize1 = qSize2;
	// qSize1 and qSize2 are the lengths of the two queues, startSize1 and
		else{
		int tmp = qSize1;
			}

				printf("bigLeftToMerges: %d %d\n", bigLeftToMerge1, bigLeftToMerge2);
				}
	bigLeftToMerge2 = qSize2;
			while(leftToMerge1 > 0 && leftToMerge2 > 0){
			}
		if(strcmp(head1, head2) < 0){
		leftToMerge1 = leftToMerge2 = sizeToMerge;
	bigLeftToMerge1 = qSize1;
		}
		// if fopen throws an error
	long pos, len;
3/3		7:00pm		1 hour		Main function can read files and add lines to a 
	// if we have a hyphen on the first argument, we have POS
		}
#define DIE(msg) exit(fprintf(stderr, "%s\n", msg))
					return 1;
	// if there's stuff left over from the first queue
		DIE("createQ() failed!");
3/10	8:30pm		1 hour		Change method of keeping track of indexes when
		// if LEN is not specified, the character after POS should be null
// whether queue is empty
			}
	// we don't have to merge the last time -- just print out
 -- Reading in the files was initially a challenge, as I was initally planning
			bigLeftToMerge2 = tmp;
{

#include "/c/cs223/Hwk3/getLine.h"
				numElements++;
3/9		9:45pm 		1 hour		Identified a few bugs, trying to fix them
        free(*q);
// a file pointer (fileToRead) that we're currently reading from, and a pointer
			DIE("removeQ failed");
	return 0;
	// now we can finally start mergesorting!
				if(!removeQ(&q2, &stringToAdd)){
		inFile = fopen(argv[i], "r");

		stdInput = strncpy(stdInput, line, strlen(line) - 1);
					DIE("headQ failed");
			}
				if(!addQ(&q1, stringToAdd)){
3/9		8:45pm		1 hour		Mostly fixed the mergesort algorithm, but it
// and prints the sorted lines to the standard output
		free(fullCommand);
			// otherwise there's stuff left over from the second queue
        (**q).next = newNode;
    // if there's no node to remove, return false
    struct node *next;
			int tmp = qSize1;
3/3		10:15pm		1 hour		Worked out stable mergesort algorithm using two
			}
					return 1;
				// now add the string to whichever queue we're currently adding to 
			}
			if(!removeQ(&q1, &stringToAdd)){
		// call headQ and store values into head1 and head2
		stopMergeIndex1 = stopMergeIndex2 = 0;

				}

		if(!headQ(&q1, &head1) || !headQ(&q2, &head2)){
					if(!removeQ(&q2, &stringToAdd)){
			bigLeftToMerge2 = tmp;
				DIE("addQ failed");
		qSize2 = tmp;
					qPos2++;
				}
				}
				bigLeftToMerge2--;
		printf("%s", stringToAdd);
								most functions								
		// if we have a tie, remove from the queue that has priority
				// call headQ and store values into head1 and head2
			}
		}

				// switch up the queues so that you split up the strings
	// if we've had an odd number of swaps, swap again to keep q1 as priority
				// switch up the queues so that you split up the strings
			}
	}
int destroyQ (Queue *q)
	if(qSize2 > qSize1){
				qSize1++;
		// this probably shouldn't ever happen but i'll do this just in case
				numElements += 2;
						return 1;
		bigLeftToMerge2 = qSize2;
		pos = strtol(argv[1] + 1, &line, 10);
#include <string.h>

		}
		free(stringToAdd);
			len = INT_MAX;
				if(!removeQ(&q2, &stringToAdd)){
				// we don't free since the queue still points to the same addr
	}
#include <stdio.h>
TOTAL time spent: 14.5 hours
		if(!removeQ(&q1, &stringToAdd)){
// the node
			if(!addQ(&q1, stringToAdd)){
		// compare the two values, remove from whichever one is smaller
int destroyQ (Queue *q)
				DIE("removeQ failed");
}
		// now we've finished the merging -- now some housekeeping
					DIE("addQ failed");
					bigLeftToMerge2--;
3/21	4:30pm		.5 hours	Put more detailed comments in the code
	while(!isEmptyQ(&q1) && !isEmptyQ(&q2)){
		return 1;
			bigLeftToMerge1--;
			if(!addQ(&q1, stringToAdd)){
				}
		}
	// offset1 and offset2 are the indices where we want to start comparing

								to stop merging
		else{
			DIE("File could not be opened!");
			}
// From then on, just keep comparing heads until one of the queues is empty
	}
					bigLeftToMerge1--;
		// if we have a tie, remove from the queue that has priority
	int leftToMerge1 = 1, leftToMerge2 = 1;
					return 1;
				return 1;
			tmp = bigLeftToMerge1;
		}
		if(line1[0] == ','){
	}
		printf("%s", stringToAdd);
 -- Implementing the mergesort was also very difficult. The algorithm involved
				qSize1++;
#include <limits.h>
			return 1;
						printf("q1 is empty\n");
					DIE("removeQ failed");

		if(line[0] == ','){
		}
		}
    // if there is only one node
#include <string.h>
3/3		1:30pm		1 hour		Started work on Queue.c, have first version of
		}
3/9		7:30pm		1 hour		Sorts a little bit better but somehow breaks
					qSize1--;
				DIE("addQ failed");
    }
			bigLeftToMerge1 = bigLeftToMerge2;
	*q1 = *q2;
3/7		4:00pm		.5 hours	Started implementation of mergesort, didn't get
	// if we have a hyphen on the first argument, we have POS
#include "/c/cs223/Hwk4/Queue.h"
		// empty
		}
				}
    // check if the queue is empty
		printf("size to merge bottom: %d\n", sizeToMerge);
		bigLeftToMerge1 = qSize1;
		bigLeftToMerge2 = qSize2;


	}
								counter that keeps track of whether the queues

				// now add the string to whichever queue we're currently adding to 
	}
					return 1;

					return 1;
		}
				// add each line in q1
		// now check if LEN is specified, and if it isn't, set it to INT_MAX
				// now add the string to whichever queue we're currently adding to 
		swap(&q1, &q2);
					if(isEmptyQ(&q1)){
		fullCommand = memset(fullCommand, 0, fullLength);
			}
		fullCommand = malloc(fullLength);
					DIE("removeQ failed");
					bigLeftToMerge2--;
		if(line[0] == ','){
			len = INT_MAX;
					qSize2--;
		// print the string with the newline and free it
				// between the two queues
					DIE("headQ failed");
	// we'll always add to q1, then swap each time
	}
	// if we've had an odd number of swaps, swap again to keep q1 as priority
					return 1;
				numElements++;
		}
					return 1;

		while(bigLeftToMerge2 > 0){
				if(!addQ(&q1, stringToAdd)){
	// now loop through the rest of the args and read them as files
	Queue q1 = NULL, q2 = NULL;

			}
	Once I had the algorithm, it was then difficult to get it under N Log(N)
			if(line1[1] < '0' || line1[1] > '9'){
					leftToMerge2--;
								doesn't work for big files
				}
			DIE("File could not be opened!");

			int tmp = qSize1;
								very far
				qSize1++;
		sizeToMerge *= 2;
					qSize1--;
		}
	// if there's stuff left over from q1, print the rest of q1 and free each
		if(!removeQ(&q2, &stringToAdd)){
	return 0;
					leftToMerge1--;
			qSize2--;
		fclose(*fileToRead);
        return false;
				if(!removeQ(&q1, &stringToAdd)){
		while(bigLeftToMerge1 > 0){
	}
			if(!removeQ(&q1, &stringToAdd)){
void swap(int *arg1, int *arg2);
	long pos, len;
				if(!headQ(&q1, &head1) || !headQ(&q2, &head2)){
			if(!removeQ(&q1, &stringToAdd)){
	}
	// free the memory from each queue
	// if we have a hyphen on the first argument, we have POS
		bigLeftToMerge2 = qSize2;
	// if we have a hyphen on the first argument, we have POS
				qSize2 = tmp;
					leftToMerge1--;
				qSize1++;
    if((**q).next == *q){
}// hold two copies of the list in the beginning and 
3/3		1:30pm		1 hour		Started work on Queue.c, have first version of
	// now we can finally start mergesorting!
	char *line, *head1, *head2, *stringToAdd;
				DIE("removeQ failed");
						return 1;

	}
{
}// hold two copies of the list in the beginning and 
t
	*q1 = *q2;
				}
			while(leftToMerge1 > 0 && leftToMerge2 > 0){
				printf("left to merges: %d %d\n", leftToMerge1, leftToMerge2);
3/3		10:15pm		1 hour		Worked out stable mergesort algorithm using two
				}
			}
					bigLeftToMerge2--;
#include "/c/cs223/Hwk3/getLine.h"
				leftToMerge2--;
					}
	// we'll always add to q1, then swap each time
		// now check if LEN is specified, and if it isn't, set it to INT_MAX
		printf("%s", stringToAdd);
			bigLeftToMerge1 = bigLeftToMerge2;
	FILE *inFile;
				bigLeftToMerge1--;
3/20	9:30pm		1 hour		I think this works! Redid it to use another
					}
					DIE("addQ failed");
				qSize2 = tmp;
	// now we print out the things in the queues, doing the last merge at
				}
		// otherwise, DIE
				return 1;
	// if we've had an odd number of swaps, swap again to keep q1 as priority
	if(qSize2 > qSize1){
			if(!removeQ(&q1, &stringToAdd)){
		else{
			if(!removeQ(&q1, &stringToAdd)){
		bigLeftToMerge1 = qSize1;
	}
----	-----		----		-----
// Looks at the first node in the queue and makes s point to the contents of
					qSize2--;
	FILE *inFile;
				}
	// now we can finally start mergesorting!
					qSize1--;
				}
					}
int main(int argc, char *argv[]){
	}
			}
			bigLeftToMerge2--;
	}
			len = strtol(line + 1, &line, 10);
				qSize1 = qSize2;
			// open the file and loop through the lines
			//free(line);
	Queue dummy = *q1;


		}
	}
		if(!removeQ(&q2, &stringToAdd)){
#include <stdio.h>
		// this probably shouldn't ever happen but i'll do this just in case
					return 1;
			tmp = bigLeftToMerge1;
    return true;
				leftToMerge1--;
		free(stringToAdd);
			bigLeftToMerge1 = bigLeftToMerge2;
		}
					}
	while(!isEmptyQ(&q1)){
    if(s == NULL){
				// if we have a tie, remove from the queue that has priority
#include "/c/cs223/Hwk4/Queue.h"

			if(!addQ(&q1, stringToAdd)){
	*q1 = *q2;
				if(!removeQ(&q2, &stringToAdd)){
		// now we've finished the merging -- now some housekeeping
						printf("q1 is empty\n");
						return 1;
	if(qSize2 > qSize1){
    }
			// open the file and loop through the lines

		else{
    // otherwise make s point to the string that the next node contains
			DIE("removeQ failed");
					if(!removeQ(&q1, &stringToAdd)){
		// read in the next line for line2
int main(int argc, char *argv[]){
		// compare the two values, remove from whichever one is smaller
		bigLeftToMerge1 = qSize1;
	while(2 * sizeToMerge < numElements){
			if(!removeQ(&q2, &stringToAdd)){
			bigLeftToMerge1 = bigLeftToMerge2;
	}
					qSize1--;
								queues
	bigLeftToMerge2 = qSize2;
			// otherwise there's stuff left over from the second queue
	// if we've had an odd number of swaps, swap again to keep q1 as priority
		free(stringToAdd);
    *q = temp;


			DIE("removeQ failed");
int removeQ (Queue *q, char **s)
		// empty
    // if there's more than one node
	Queue dummy = *q1;
		// make sure POS is positive digits
								doesn't work for big files
		// of the first line
				// add each line in q1
		while(bigLeftToMerge1 > 0 && bigLeftToMerge2 > 0){
			bigLeftToMerge1--;
				if(!addQ(&q1, stringToAdd)){
				qSize1++;
						printf("q1 is empty\n");
		free(stringToAdd);

int min(int a, int b){
    }
3/20	9:30pm		1 hour		I think this works! Redid it to use another

			}
			qSize1++;
    return true;
	}
#include <stdbool.h>
	while(!isEmptyQ(&q1)){
			len = INT_MAX;
		if(line[0] == ','){
	// we'll always add to q1, then swap each time
e
}
	// free the memory from each queue
	// we'll always add to q1, then swap each time
				// keep updating size and position
					return 1;
			qSize2--;
		firstFileArg = 2;
			}
		DIE("createQ() failed!");
		}
// Returns true if operation succeeded, false if it failed
		if(strcmp(head1, head2) < 0){
	}
		if(strcmp(head1, head2) < 0){
	destroyQ(&q1);
		bigLeftToMerge1 = qSize1;
					leftToMerge1--;
		}
	while(!isEmptyQ(&q1) && !isEmptyQ(&q2)){
		inFile = fopen(argv[i], "r");
			while(leftToMerge1 > 0){
					DIE("addQ failed");
People I consulted with: Jared Weinstein, Annie Chen, Will Merrill
#define DIE(msg) exit(fprintf(stderr, "%s\n", msg))

			}
}
	destroyQ(&q1);
	bigLeftToMerge1 = qSize1;

					if(!removeQ(&q1, &stringToAdd)){
				qSize2 = tmp;
    if(s == NULL){


				if(strcmp(head1, head2) < 0){
				DIE("removeQ failed");
			bigLeftToMerge2--;
	long pos, len;
					if(isEmptyQ(&q1)){
	}

		// now we've finished the merging -- now some housekeeping
		offset1 = min(pos, lineSize1);
			}
	// make sure there's at least one argument after Merge16
	int leftToMerge1 = 1, leftToMerge2 = 1;
			}
*/
	}
		}
		printf("biglefts: %d %d\n", bigLeftToMerge1, bigLeftToMerge2);
					DIE("removeQ failed");
		pos = strtol(argv[1] + 1, &line, 10);
			// if there's stuff left over from the first queue

					return 1;
		// if fopen throws an error
	}
	// we don't have to merge the last time -- just print out
	bigLeftToMerge2 = qSize2;
}// hold two copies of the list in the beginning and 
	to call getLine() twice per loop and then running a lot of cases on which

				if(!removeQ(&q2, &stringToAdd)){
        return false;
			if(!removeQ(&q1, &stringToAdd)){

int destroyQ (Queue *q)
				}
			bigLeftToMerge2--;


	// where we want to stop once qPos1 or qPos2 hits them (i.e. the end of a
		// while at least one of the queues has some un-merged elements, we 
		// remove the newline (set the newline character to the null character)
			bigLeftToMerge1 = bigLeftToMerge2;
void swap(Queue *arg1, Queue *arg2);
		sizeToMerge *= 2;
	FILE *inFile;
					DIE("removeQ failed");
				qSize1++;
		printf("%s", stringToAdd);

		swap(&q1, &q2);
		else{
						return 1;
			bigLeftToMerge2--;
    Node *nodeToRemove = (**q).next;
// should take at most N*log2(N) adds.
		}
int main(int argc, char *argv[]){

					return 1;
					if(!removeQ(&q1, &stringToAdd)){
				swap(&q1, &q2);
	int fileArg = 1, sizeToMerge = 2, numElements = 0;
			fullCommand = strcat(fullCommand, argv[i]);
				DIE("addQ failed");
			tmp = bigLeftToMerge1;
		swap(&q1, &q2);
		stopMergeIndex1 = stopMergeIndex2 = 0;
				printf("two heads are %s %s\n", head1, head2);
								merging incorrectly
			len = strtol(line + 1, &line, 10);
// From then on, just keep comparing heads until one of the queues is empty
				qSize2--;
			}
		if(!removeQ(&q2, &stringToAdd)){
			DIE("removeQ failed");
			// open the file and loop through the lines
		while(bigLeftToMerge1 > 0){
 				
		}
			DIE("removeQ failed");
			return 1;
int main(int argc, char *argv[]){
	// otherwise there's stuff left over from the second queue
				leftToMerge2--;
						DIE("removeQ failed");
		// now we've finished the merging -- now some housekeeping
		if(line[0] == ','){
				printf("size we're merging: %d\n", sizeToMerge);

		leftToMerge1 = leftToMerge2 = sizeToMerge;
		if(!headQ(&q1, &head1) || !headQ(&q2, &head2)){
		qSize1 = qSize2;
				// if we have a tie, remove from the queue that has priority
				int tmp = qSize1;
		}
    }
		}
	int firstFileArg = 1, sizeToMerge = 1, numElements = 0;
int main(int argc, char *argv[]){
    char *dummyS;
	}
		while(bigLeftToMerge1 > 0 && bigLeftToMerge2 > 0){
			}
		int tmp = qSize1;
					DIE("addQ failed");
					qSize1--;
			}
			// otherwise there's stuff left over from the second queue
			if(!removeQ(&q2, &stringToAdd)){
			if(!removeQ(&q2, &stringToAdd)){
		else{
								merging incorrectly
					return 1;
			// open the file and loop through the lines
		qSize1 = qSize2;
		// files start at the next command line argument
				}
					leftToMerge1--;
		offset2 = min(pos, strlen(head2));
    return (*q == NULL);
			while(leftToMerge1 > 0){

			swap(&q1, &q2);
		}
// to fileIndex, which represents the index of argv of the file we're currently
		while(bigLeftToMerge1 > 0 && bigLeftToMerge2 > 0){
			swap(&stopMergeIndex2, &stopMergeIndex1);
			bigLeftToMerge2 = tmp;
				}
				return 1;
				// now add the string to whichever queue we're currently adding to 
	// make sure there's at least one argument after Merge16
		printf("%s", stringToAdd);
				printf("two heads are %s %s\n", head1, head2);
				printf("two heads are %s %s\n", head1, head2);
		else{
	// argumentString = strcat(argumentString, argv[1]);
    else{
					qSize1--;
// Returns true if operation succeeded, false if it failed
		}

People I consulted with: Jared Weinstein, Annie Chen, Will Merrill
	destroyQ(&q1);

			while(leftToMerge2 > 0){
				if(strncmp(head1 + offset1, head2 + offset2, len) < 0){
3/3		1:30pm		1 hour		Started work on Queue.c, have first version of
		if(inFile == NULL){
		printf("size to merge bottom: %d\n", sizeToMerge);
// offset the bottom one by one. Then keep comparing heads until
			qSize1++;
						return 1;
	// now we can finally start mergesorting!

#include <stdlib.h>
	}
					return 1;
					if(!removeQ(&q2, &stringToAdd)){
				qSize2 = tmp;
	}
    struct node *next;
				DIE("removeQ failed");
		DIE("createQ() failed!");
				}
			bigLeftToMerge1 = bigLeftToMerge2;
			len = INT_MAX;
	to call getLine() twice per loop and then running a lot of cases on which
				bigLeftToMerge1--;
				qSize2--;
					leftToMerge2--;
		sizeToMerge *= 2;
				DIE("addQ failed");
		}


			bigLeftToMerge1--;
	int firstFileArg = 1, sizeToMerge = 1, numElements = 0;
				if(!addQ(&q1, stringToAdd)){
#include <string.h>
			if(!removeQ(&q1, &stringToAdd)){
			if(!removeQ(&q2, &stringToAdd)){
				}
People I consulted with: Jared Weinstein, Annie Chen, Will Merrill
				}
			// open the file and loop through the lines

		return 1;
Difficulties I ran into:
	long pos, len;
				qSize1 = qSize2;
#include <stdlib.h>
				DIE("removeQ failed");
		leftToMerge1 = leftToMerge2 = sizeToMerge;
				if(!removeQ(&q2, &stringToAdd)){
	Queue dummy = *q1;

		}
	int leftToMerge1 = 1, leftToMerge2 = 1;
		}
            return false;
		while(bigLeftToMerge1 > 0){
	addQ()s, as the one that I originally had workd in N ceil(Log(N)).
				// compare the two values, remove from whichever one is smaller
			if(!addQ(&q1, stringToAdd)){
								counter that keeps track of whether the queues
// file is empty, opens the next file and returns the next line it can find.
		// empty
				}
	int leftToMerge1 = 1, leftToMerge2 = 1;
				DIE("removeQ failed");
	long pos, len;
		// this probably shouldn't ever happen but i'll do this just in case
		printf("%s", stringToAdd);
// function to swap two queues (i.e. swap the pointers to the two nodes)
// offset the bottom one by one. Then keep comparing heads until
				leftToMerge2--;

			return 1;
		if(!headQ(&q1, &head1) || !headQ(&q2, &head2)){
			bigLeftToMerge2 = tmp;
					return 1;
			swap(&startSize1, &startSize2);
3/9		9:45pm 		1 hour		Identified a few bugs, trying to fix them
				printf("left to merges: %d %d\n", leftToMerge1, leftToMerge2);
	}

		}
	bigLeftToMerge2 = qSize2;
	// we don't have to merge the last time -- just print out
TOTAL time spent: 14.5 hours
		// we also want to remember the starting size of each queue
				// now add the string to whichever queue we're currently adding to 
	while(!isEmptyQ(&q2)){
					qSize2--;
#include <stdlib.h>
void swap(Queue *q1, Queue *q2){
				bigLeftToMerge2--;
			len = INT_MAX;
		// if we have a tie, remove from the queue that has priority
					DIE("addQ failed");
		bigLeftToMerge2 = qSize2;
	}
			}
			}
// you finish the first merging, alternating which queue you push to
// offset the bottom one by one. Then keep comparing heads until
		}
		while(bigLeftToMerge1 > 0){
					leftToMerge2--;
				qSize1 = qSize2;
			if(!addQ(&q1, stringToAdd)){
	}
	// if we have a hyphen on the first argument, we have POS
				if(!headQ(&q1, &head1) || !headQ(&q2, &head2)){
				// call headQ and store values into head1 and head2
				// remove from whichever one is smaller
        return false;
*/
					bigLeftToMerge1--;
	char *line, *head1, *head2, *stringToAdd;
	// if we have a hyphen on the first argument, we have POS

int addQ (Queue *q, char *s)
		swap(&q1, &q2);
					return 1;
						return 1;
	int stopMergeIndex1 = 0, stopMergeIndex2 = 0;
3/7		4:00pm		.5 hours	Started implementation of mergesort, didn't get
	Queue dummy = *q1;
 				
			}
			DIE("Invalid POS");
	}
	char *line1;
				}
			DIE("removeQ failed");
					return 1;
int main(int argc, char *argv[]){
// function to swap two queues (i.e. swap the pointers to the two nodes)
			fullCommand = strcat(fullCommand, argv[i]);


					return 1;
			// if there's stuff left over from the first queue
	// 	argumentString = strcat(argumentString, argv[i]);
	bigLeftToMerge1 = qSize1;
			}
	// q1 will always have the same or one more element than q2
					DIE("headQ failed");
// function to swap two queues (i.e. swap the pointers to the two nodes)
		qSize2 = tmp;
		*fileToRead = fopen(argv[*fileIndex], "r");
					bigLeftToMerge1--;
					bigLeftToMerge1--;
		if(!removeQ(&q2, &stringToAdd)){
	long pos, len;
					}

    return true;
int main(int argc, char *argv[]){
// Implementation of Queue ADT using headless, singly-linked, circular list.
		}
			}
					leftToMerge2--;
			bigLeftToMerge1 = bigLeftToMerge2;
	if(!createQ(&q1) || !createQ(&q2)){
	while(2 * sizeToMerge < numElements){
		}
f
		leftToMerge1 = leftToMerge2 = sizeToMerge;
			}
								very far

						printf("q1 is empty\n");
#include <stdbool.h>
				if(!addQ(&q1, stringToAdd)){
		leftToMerge1 = leftToMerge2 = sizeToMerge;
					DIE("addQ() failed!");
        (**q).next = newNode;
		free(stringToAdd);
}

			qSize2 = tmp;
		}
		free(stringToAdd);
// Function takes in a pointer to a Queue, returns true if the Queue is empty
	FILE *inFile;
				DIE("removeQ failed");
				// between the two queues
		else{
					return 1;
		else{
			if(!removeQ(&q1, &stringToAdd)){
			//free(line);
				if(!addQ(&q1, stringToAdd)){
    struct node *next;
				// add each line in q1
						DIE("removeQ failed");

		if(inFile == NULL){
		inFile = fopen(argv[i], "r");
				bigLeftToMerge1--;
			}

				numElements++;
	long pos, len;
		qSize1 = qSize2;
		free(stringToAdd);
				else if(strcmp(head1, head2) > 0){
		if(strcmp(head1, head2) < 0){
				printf("size we're merging: %d\n", sizeToMerge);

	int dummy = *a;
	// startSize2 are their sizes at the start of each merge, qPos1 and qPos2
		}
			bigLeftToMerge1--;
				if(!addQ(&q1, stringToAdd)){

#include "/c/cs223/Hwk3/getLine.h"
{
int main(int argc, char *argv[]){
		bigLeftToMerge2 = qSize2;
		}
				}
					return 1;
		fullCommand = strcpy(fullCommand, echo);
				qSize1 = qSize2;
					}
		free(stringToAdd);
				// compare the two values, remove from whichever one is smaller
				numElements++;
	}
			}
	}
				if(!headQ(&q1, &head1) || !headQ(&q2, &head2)){
	call got NULL, and I had to worry about whether the next file existed, or
		if(line[0] == ','){
				DIE("addQ failed!");
					bigLeftToMerge2--;
				printf("left to merges: %d %d\n", leftToMerge1, leftToMerge2);
// to fileIndex, which represents the index of argv of the file we're currently
	// now loop through the rest of the args and read them as files
		// compare the two values, remove from whichever one is smaller
		}
		}
		// if fopen throws an error
// reading. this function returns the next line in the current file, or if the 
				}
// offset the bottom one by one. Then keep comparing heads until

		// POS or the end of the string)
}
	if(qSize2 > qSize1){

					qSize1--;
	long pos, len;
}// hold two copies of the list in the beginning and 
				}
						DIE("removeQ failed");
				// compare the two values, remove from whichever one is smaller
	}
				// switch up the queues so that you split up the strings
					leftToMerge1--;
		int tmp = qSize1;
				}
3/3		7:00pm		1 hour		Main function can read files and add lines to a 
	if(argc == 1){
	while(!isEmptyQ(&q2)){
		if(strcmp(head1, head2) < 0){
		}
    if(isEmptyQ(q)){
		bigLeftToMerge1 = qSize1;
	*q1 = *q2;
	// queue that q1 originally pointed to) and true otherwise
		else if(strcmp(head1, head2) > 0){
			bigLeftToMerge1--;
		}
				// start comparing either at POS or the end of the string,
				numElements++;
					DIE("removeQ failed");


		if(strncmp(head1 + offset1, head2 + offset2, len) < 0){
				bigLeftToMerge2--;
	*q1 = *q2;
			// otherwise there's stuff left over from the second queue
				qSize1++;
					DIE("headQ failed");

				if(!removeQ(&q2, &stringToAdd)){
			if(!addQ(&q1, stringToAdd)){
				// we don't free since the queue still points to the same addr
					return 1;
    }
	}
	}
3/7		4:00pm		.5 hours	Started implementation of mergesort, didn't get
			return 1;
        *s = (**q).next->value;
			bigLeftToMerge2--;
					DIE("addQ failed");
					bigLeftToMerge2--;
	int qSize1 = 0, qSize2 = 0, bigLeftToMerge2, bigLeftToMerge1;
		return 1;
					return 1;
#define DIE(msg) exit(fprintf(stderr, "%s\n", msg))
			DIE("removeQ failed");
		int tmp = qSize1;

		}
		free(stringToAdd);
				numElements += 2;
			len = INT_MAX;
			tmp = bigLeftToMerge1;
	// if we have a hyphen on the first argument, we have POS
		else{

ESTIMATE of total time I will spend: 16 hours
	}
    *q = temp;
				// between the two queues
		qSize2 = tmp;
	while((line = getLine(stdin)) != NULL){

	return 0;
			}
	}
		// while at least one of the queues has some un-merged elements, we 
		}
			qSize1++;
		}
		// now we've finished the merging -- now some housekeeping
	}
				qSize1++;
	// we'll always add to q1, then swap each time
		}
		if(argv[1][1] < '0' || argv[1][1] > '9'){
	while(!isEmptyQ(&q1) && !isEmptyQ(&q2)){
				// if we have a tie, remove from the queue that has priority
#include <stdbool.h>
// offset the bottom one by one. Then keep comparing heads until
			reversed = !reversed;
		}
        free(*q);
				printf("left to merges: %d %d\n", leftToMerge1, leftToMerge2);
				}
	Eventually I realized (with the help of Will) that I could read in the lines
		}
				return 1;

				// between the two queues
		if(!headQ(&q1, &head1) || !headQ(&q2, &head2)){
				return 1;
				if(!removeQ(&q1, &stringToAdd)){

	int firstFileArg = 1, sizeToMerge = 1, numElements = 0;
			if(!removeQ(&q1, &stringToAdd)){
		else{
		}
		printf("%s", stringToAdd);
	while(!isEmptyQ(&q1)){
void swap(Queue *q1, Queue *q2){


			reversed = !reversed;
	int qSize1 = 0, qSize2 = 0, bigLeftToMerge2, bigLeftToMerge1;
		}
				leftToMerge1--;
	int qSize1 = 0, qSize2 = 0, bigLeftToMerge2, bigLeftToMerge1;
			swap(&qPos1, &qPos2);
		printf("%s", stringToAdd);
					}
			}
#define DIE(msg) exit(fprintf(stderr, "%s\n", msg))
	char *line, *head1, *head2, *stringToAdd;
			}
			int tmp = qSize1;
		swap(&qSize1, &qSize2);
				if(!addQ(&q1, stringToAdd)){
	Queue dummy = *q1;
*/
	}
#include <stdlib.h>
				}

						DIE("removeQ failed");
		stopMergeIndex1 = stopMergeIndex2 = 0;
	// we'll always add to q1, then swap each time
		// if we have excess on the first queue...the other queue should be
		if(strcmp(head1, head2) < 0){
		free(stdInput);
		firstFileArg = 2;
			if(!addQ(&q1, stringToAdd)){
// Returns true if operation succeeded, false if it failed

		while(bigLeftToMerge1 > 0 && bigLeftToMerge2 > 0){
} Node;
	// we'll always add to q1, then swap each time
				else{
		printf("%s", stringToAdd);
int destroyQ (Queue *q)
			bigLeftToMerge1--;
				else if(strcmp(head1, head2) > 0){
						printf("q1 is empty\n");
				if(!headQ(&q1, &head1) || !headQ(&q2, &head2)){
				printf("left to merges: %d %d\n", leftToMerge1, leftToMerge2);
	// the same time
    if((**q).next == *q){
			qSize1++;
		}
			bigLeftToMerge1--;
			line1[lineSize1 - 1] = '\0';
				if(!addQ(&q1, stringToAdd)){

		}
			return 1;
		bigLeftToMerge2 = qSize2;
// function to swap two queues. Takes pointers to two queues (q1 and q2) and 
	// now we print out the things in the queues, doing the last merge at
				qSize2 = tmp;
		else{
					DIE("addQ failed");
}

						DIE("removeQ failed");
			}
3/10	8:30pm		1 hour		Change method of keeping track of indexes when
			qSize2 = tmp;
				DIE("addQ failed");
		}
				DIE("removeQ failed");
		leftToMerge1 = leftToMerge2 = sizeToMerge;
	Queue q1 = NULL, q2 = NULL;
	two at a time and essentially do the first merge as I filled in the queues
			}
				// call headQ and store values into head1 and head2
		if(!removeQ(&q2, &stringToAdd)){
				qPos2++;
				DIE("addQ failed");
				if(!removeQ(&q2, &stringToAdd)){
						DIE("removeQ failed");
			if(!removeQ(&q2, &stringToAdd)){
					}
				// between the two queues
// Returns true if operation succeeded, false if it failed
		leftToMerge1 = leftToMerge2 = sizeToMerge;

	call got NULL, and I had to worry about whether the next file existed, or

		else{
			swap(&qSize1, &qSize2);

					DIE("addQ failed");
		*fileToRead = fopen(argv[*fileIndex], "r");
		// call headQ and store values into head1 and head2
						printf("q1 is empty\n");
		free(stringToAdd);
				if(!addQ(&q1, stringToAdd)){
			tmp = bigLeftToMerge1;
		// if fopen throws an error
		// call headQ and store values into head1 and head2
	long pos, len;
					}
		// now check if LEN is specified, and if it isn't, set it to INT_MAX
				if(qPos1 == startSize1 || qPos2 == startSize2){
		printf("biglefts: %d %d\n", bigLeftToMerge1, bigLeftToMerge2);
		if(!removeQ(&q2, &stringToAdd)){
				}
					}
						DIE("removeQ failed");
	if(argc == 1){
						return 1;
		// print the string with the newline and free it
			qSize1 = qSize2;
		printf("%s", stringToAdd);
	*q1 = *q2;
				else{
	for(int i = firstFileArg; i < argc; i++){
	// now we can finally start mergesorting!
					if(!removeQ(&q1, &stringToAdd)){

		if(!headQ(&q1, &head1) || !headQ(&q2, &head2)){
	call got NULL, and I had to worry about whether the next file existed, or
			}
				DIE("addQ failed");
					leftToMerge1--;
		}
				// compare the two values (starting from the offset we defined)
		argLength += (test + 1);
			}
	while(2 * sizeToMerge < numElements){
// between consecutive merges
		printf("size to merge bottom: %d\n", sizeToMerge);
			}
				// compare the two values, remove from whichever one is smaller
				swap(&q1, &q2);
e
		// empty
// function to swap two queues (i.e. swap the pointers to the two nodes)
				if(!addQ(&q1, stringToAdd)){
					if(isEmptyQ(&q1)){
				bigLeftToMerge2--;
			while(leftToMerge2 > 0){
			}

	}
		if(strcmp(head1, head2) < 0){
	if(!createQ(&q1) || !createQ(&q2)){
				qSize1++;
				// if we have a tie, remove from the queue that has priority


					DIE("addQ failed!");

			if(!removeQ(&q2, &stringToAdd)){
				// now add the string to whichever queue we're currently adding to 
			// otherwise there's stuff left over from the second queue
			while(leftToMerge1 > 0){
	}
					}
		while(bigLeftToMerge2 > 0){
		DIE("createQ() failed!");
		if(strcmp(head1, head2) < 0){
		if(!removeQ(&q2, &stringToAdd)){
			bigLeftToMerge1--;


		while(bigLeftToMerge2 > 0){
// Function that takes in a pointer to a Queue (q) and a string (s), then adds a
					bigLeftToMerge1--;
	FILE *inFile;
		}
		swap(&q1, &q2);
						return 1;
		swap(&q1, &q2);
    return true;
		printf("biglefts: %d %d\n", bigLeftToMerge1, bigLeftToMerge2);
			}
	long pos, len;
	call got NULL, and I had to worry about whether the next file existed, or
		if(!headQ(&q1, &head1) || !headQ(&q2, &head2)){
				bigLeftToMerge2--;
			int tmp = qSize1;
			}
	// q1 will always have the same or one more element than q2
		while(bigLeftToMerge1 > 0 && bigLeftToMerge2 > 0){

					if(!removeQ(&q2, &stringToAdd)){
	// if we've had an odd number of swaps, swap again to keep q1 as priority
		}
						return 1;
		else{
						DIE("removeQ failed");
				swap(&q1, &q2);
				printf("size we're merging: %d\n", sizeToMerge);
		else{
/*Progress report: sorts, but doesn't handle it when there's leftover between merges (i.e. when one bigleft is nonzero but the other is zero)
			}

	// offset1 and offset2 are the indices where we want to start comparing

3/15	8:00pm		1 hour		Now it sorts! Working on incorporating pos,len,
	// head1 and head2
						DIE("removeQ failed");
					leftToMerge1--;
			// if there's stuff left over from the first queue
	if(argc == 1){
		qSize1 = qSize2;
					DIE("removeQ failed");
	*q1 = *q2;
		}
		leftToMerge1 = leftToMerge2 = sizeToMerge;
				int tmp = qSize1;
	// q1 will always have the same or one more element than q2
					DIE("addQ failed");
		leftToMerge1 = leftToMerge2 = sizeToMerge;
					leftToMerge1--;
				if(!addQ(&q1, line)){
				}
	}
					DIE("removeQ failed");
					return 1;
#include <stdbool.h>
				qSize2 = tmp;
					leftToMerge2--;
	// argumentString = strcpy(argumentString, " ");
				DIE("addQ failed");
#include <stdio.h>
	FILE *inFile;
3/20	9:30pm		1 hour		I think this works! Redid it to use another
				}
{
			// with an empty list)
				}
		swapQueues(&q1, &q2);
		free(stringToAdd);
	destroyQ(&q1);
	// if we have a hyphen on the first argument, we have POS
		}
			while(leftToMerge1 > 0 && leftToMerge2 > 0){
			DIE("File could not be opened!");
				return 1;
	// the lines (either pos or the length of the string)
				else{

/*Progress report: sorts, but doesn't handle it when there's leftover between merges (i.e. when one bigleft is nonzero but the other is zero)
					return 1;
		int tmp = qSize1;
	bigLeftToMerge1 = qSize1;
				leftToMerge2--;
			}
					}
	// make sure there's at least one argument after Merge16
	// if we have a hyphen on the first argument, we have POS
		free(stringToAdd);
	// q1 will always have the same or one more element than q2
 -- Getting the algorithm for two-queue mergesort was difficult to begin with.
	// now we can finally start mergesorting!
				// add each line in q1
			qSize1++;
#include <stdlib.h>
		}
			}
	*q2 = dummy;
			len = strtol(line + 1, &line, 10);
	// q1 will always have the same or one more element than q2
					return 1;
				}

				printf("two heads are %s %s\n", head1, head2);
	// if there's stuff left over from the first queue
		}
		printf("%s", stringToAdd);
					DIE("addQ failed");
				return 1;
			}
		// reset the queues if they're reversed (along with their sizes and 
TOTAL time spent: 14.5 hours
					qSize1--;
		while(bigLeftToMerge1 > 0){
		leftToMerge1 = leftToMerge2 = sizeToMerge;
		return 1;
			}
			len = INT_MAX;

				}
		else{
	// size of each subQueue we're merging, numElements is total number of 
		free(stringToAdd);
			}

3/20	9:30pm		1 hour		I think this works! Redid it to use another
				if(!addQ(&q1, stringToAdd)){
			return 1;
				// between the two queues
								to stop merging
	if(!createQ(&q1) || !createQ(&q2)){


				qSize2 = tmp;
	if(!createQ(&q1) || !createQ(&q2)){

	if(argv[1][0] == '-'){
		}
#include <string.h>
		printf("size to merge bottom: %d\n", sizeToMerge);

				}
		}
	// if we've had an odd number of swaps, swap again to keep q1 as priority
        return false;
				numElements++;
				DIE("Invalid LEN");
		// record the offset where we want to start comparing (again, either 
					if(!removeQ(&q1, &stringToAdd)){
			while((line = getLine(inFile)) != NULL){
	}
	destroyQ(&q1);
					if(!removeQ(&q1, &stringToAdd)){
#include "/c/cs223/Hwk4/Queue.h"
		else{
		}
#include "/c/cs223/Hwk3/getLine.h"
					if(!removeQ(&q1, &stringToAdd)){
		swap(&q1, &q2);
		pos = strtol(argv[1] + 1, &line, 10);
			bigLeftToMerge2 = tmp;
			}
		leftToMerge1 = leftToMerge2 = sizeToMerge;
		}
				if(!addQ(&q1, line)){

}
	keeping track of a lot of indices, pointers, and so on, all within
		// compare the two values, remove from whichever one is smaller
		leftToMerge1 = leftToMerge2 = sizeToMerge;
				DIE("addQ failed");
----	-----		----		-----
			return 1;
			}
			//free(line);
				qSize2--;
	if(argv[1][0] == '-'){
			if(!removeQ(&q1, &stringToAdd)){
#include <limits.h>
	}
/*Progress report: sorts, but doesn't handle it when there's leftover between merges (i.e. when one bigleft is nonzero but the other is zero)
		// queue evenly
int main(int argc, char *argv[]){
		return newGetLine(argv, argc, fileToRead, fileIndex);
		free(stringToAdd);
			while((line = getLine(inFile)) != NULL){
    // if s doesn't point to anything
				}
				int tmp = qSize1;
				DIE("removeQ failed");
					}
			}
 				
				// alternate which queue we add to) 
// From then on, just keep comparing heads until one of the queues is empty
				}
			}
		free(stringToAdd);
				}
	while(sizeToMerge * 2 < numElements){ 
				qSize1++;

			if(line1[1] < '0' || line1[1] > '9'){
	char *line, *head1, *head2, *stringToAdd;
		fullCommand = malloc(fullLength);
				}
			while(leftToMerge1 > 0){
				printf("two heads are %s %s\n", head1, head2);
		}
// sorts the files using Mergesort (implemented using exactly two queues),
		// of the first line
		if(strcmp(head1, head2) < 0){
			}
	}
					return 1;
	// q1 will always have the same or one more element than q2
			swap(&q1, &q2);
	// now loop through the rest of the args and read them as files
					leftToMerge2--;
		}
	// argumentString = strcat(argumentString, argv[1]);
			}
		return 1;
#include "/c/cs223/Hwk3/getLine.h"
					bigLeftToMerge2--;
			bigLeftToMerge2 = tmp;
		return 1;
    return (*q == NULL);
				qSize1++;
		free(stringToAdd);
			qSize1++;
		// otherwise, open the new file, update the file pointer and return the
		}
			if(!removeQ(&q2, &stringToAdd)){
	// printf("%d\n", argLength);
		if(line[0] == ','){
				qSize1++;
void swap(Queue *q1, Queue *q2){
			qSize2 = tmp;
		}
			}
					DIE("headQ failed");
#include <string.h>
	// if we have a hyphen on the first argument, we have POS
				}
	// now we can finally start mergesorting!

		// call headQ and store values into head1 and head2
		}
			}
----	-----		----		-----

	Queue q1 = NULL, q2 = NULL;
	int leftToMerge1 = 1, leftToMerge2 = 1;
#include <stdbool.h>
	}
		else{
					DIE("removeQ failed");
{
	}
				// update the size each time, incremeting by two since we 
				}
			}
				}
			while(leftToMerge1 > 0){
// From then on, just keep comparing heads until one of the queues is empty
		else{
			qSize2--;
	*q1 = *q2;
			if(!addQ(&q1, stringToAdd)){
	// we'll always add to q1, then swap each time
					if(!removeQ(&q1, &stringToAdd)){
		}
		if(!removeQ(&q2, &stringToAdd)){
		}
	}
*/

{
		// if we have excess on the first queue...the other queue should be
			if(!addQ(&q1, stringToAdd)){
					DIE("addQ failed");
					return 1;
			len = INT_MAX;
				qPos2++;

				if(!addQ(&q1, stringToAdd)){
// should take at most N*log2(N) adds.
				DIE("removeQ failed");
	*q2 = dummy;
		}
				if(!headQ(&q1, &head1) || !headQ(&q2, &head2)){
// The struct contains a string (value) for the contents of a node and a pointer
	// start reading in the first file (if there is one)
		test = strlen(argv[i]);
	Queue dummy = *q1;
	}
			return 1;
    // if the queue is empty, it has no head, so it fails
				}
#include <stdlib.h>
		}

*/

			}
// between consecutive merges
// between consecutive merges
		sizeToMerge *= 2;
	int qSize1 = 0, qSize2 = 0, bigLeftToMerge2, bigLeftToMerge1;
			while((line = getLine(inFile)) != NULL){
					qSize2--;
			while((line = getLine(inFile)) != NULL){
			if(!addQ(&q1, stringToAdd)){
	if(argc == 1){
			swap(&qSize1, &qSize2);
			DIE("Invalid POS");
#include <limits.h>

			bigLeftToMerge2--;
	while(!isEmptyQ(&q1) && !isEmptyQ(&q2)){
			return 1;


			DIE("removeQ failed");
// function to swap two queues (i.e. swap the pointers to the two nodes)
		free(stringToAdd);
		free(stringToAdd);
	}

				printf("left to merges: %d %d\n", leftToMerge1, leftToMerge2);
		while(bigLeftToMerge1 > 0 && bigLeftToMerge2 > 0){
		}
				else if(strncmp(head1 + offset1, head2 + offset2, len) > 0){
			}
				if(!addQ(&q1, stringToAdd)){
	// 	argumentString = strcat(argumentString, " ");
3/9		8:45pm		1 hour		Mostly fixed the mergesort algorithm, but it
	if(qSize2 > qSize1){
	bigLeftToMerge1 = qSize1;
void swap(Queue *arg1, Queue *arg2);
			qSize1++;
			}
				// now add the string to whichever queue we're currently adding to 
	// if there's stuff left over from q1, print the rest of q1 and free each
				leftToMerge2--;
				qSize1 = qSize2;
			int tmp = qSize1;

								merging
				}

				}
			}
				// call headQ and store values into head1 and head2
					return 1;
					DIE("addQ failed!");
int min(int a, int b){
    return (*q == NULL);
				}
								for bigger files

			len = strtol(line + 1, &line, 10);

		leftToMerge1 = leftToMerge2 = sizeToMerge;
	while(!isEmptyQ(&q2)){
					DIE("addQ failed");
				qSize2 = tmp;
#include <string.h>
				DIE("addQ failed");
								very far
*/
				}
			}
					bigLeftToMerge1--;
	}
		// now we've finished the merging -- now some housekeeping

	*q1 = *q2;
}
				return 1;
// between consecutive merges
		firstFileArg = 2;
				DIE("addQ failed");
				}
    // if it's not empty, insert the new node at the end of the linked list
#include <limits.h>
			return NULL;
#define DIE(msg) exit(fprintf(stderr, "%s\n", msg))
					if(!removeQ(&q1, &stringToAdd)){
}
		else if(strcmp(head1, head2) > 0){
				return 1;
				DIE("removeQ failed");
	to get a working version
 -- Getting the algorithm for two-queue mergesort was difficult to begin with.
				bigLeftToMerge1--;
// should take at most N*log2(N) adds.
#include <stdlib.h>
				printf("two heads are %s %s\n", head1, head2);

		// if fopen throws an error
			leftToMerge1 = leftToMerge2 = sizeToMerge;
				if(!addQ(&q1, line)){

	}

				}
					}
		// this probably shouldn't ever happen but i'll do this just in case
		DIE("createQ() failed!");

			len = strtol(line + 1, &line, 10);
		}
		// now we've finished the merging -- now some housekeeping

		else{
3/3		7:00pm		1 hour		Main function can read files and add lines to a 
	if(argc == 1){
			if(!removeQ(&q1, &stringToAdd)){
	bigLeftToMerge1 = qSize1;
			if(!removeQ(&q1, &stringToAdd)){
					DIE("removeQ failed");

        return false;

		if(line[0] == ','){
{
	// now loop through the rest of the args and read them as files
						return 1;
		int tmp = qSize1;
		// if we have a tie, remove from the queue that has priority
				}
	}
					DIE("headQ failed");

						DIE("removeQ failed");
	}
				offset1 = min(pos, strlen(head1));
#define DIE(msg) exit(fprintf(stderr, "%s\n", msg))
#include <stdio.h>
				DIE("removeQ failed");

	*q1 = *q2;
			DIE("File could not be opened!");

			return 1;
		// now check if LEN is specified, and if it isn't, set it to INT_MAX
				// now add the string to whichever queue we're currently adding to 
			return 1;
		free(stringToAdd);
			bigLeftToMerge2--;
	// the same time
				// add each line in q1
		if(!removeQ(&q1, &stringToAdd)){
		qSize1 = qSize2;
						return 1;
			stopMergeIndex1 = min(stopMergeIndex1 + sizeToMerge, startSize1);
void swap(Queue *arg1, Queue *arg2);
					return 1;
		int tmp = qSize1;
			if(!removeQ(&q2, &stringToAdd)){
			qSize2--;

		// call headQ and store values into head1 and head2
				}
				if(!addQ(&q1, stringToAdd)){
					}
	}
3/9		4:30pm		1 hour		It now sorts but only handles powers of 2 and is
 				

/*Progress report: sorts, but doesn't handle it when there's leftover between merges (i.e. when one bigleft is nonzero but the other is zero)
		// if we have excess on the first queue...the other queue should be
				}
				}
		else{
	}
			while((line = getLine(inFile)) != NULL){
}
						return 1;
					return 1;
					DIE("addQ failed");
#include <stdlib.h>
			swap(&qSize1, &qSize2);
					DIE("headQ failed");
			}
				DIE("addQ failed");
		printf("%s", stringToAdd);
					bigLeftToMerge1--;
						printf("q1 is empty\n");
		// if we have a tie, remove from the queue that has priority
			}
#include "/c/cs223/Hwk4/Queue.h"
				// first, which is the one that q1 originally pointed to
		qSize2 = tmp;
				int tmp = qSize1;
						return 1;
    if(s == NULL){
					}
	for(int i = firstFileArg; i < argc; i++){
				if(strcmp(head1, head2) < 0){
			// otherwise there's stuff left over from the second queue
#include "/c/cs223/Hwk3/getLine.h"
			if(line1[0] != '\0'){
				}
								queue
		printf("size to merge bottom: %d\n", sizeToMerge);
	// the same time
// the list (or NULL if the queue is empty).
		inFile = fopen(argv[i], "r");
		printf("%s", stringToAdd);
			}
		}
				leftToMerge2--;

			if(!addQ(&q1, stringToAdd)){
		printf("size to merge bottom: %d\n", sizeToMerge);
		}
				printf("two heads are %s %s\n", head1, head2);
				DIE("addQ failed");
	}
			while(leftToMerge1 > 0 && leftToMerge2 > 0){
			}
						DIE("removeQ failed");
			len = strtol(line + 1, &line, 10);
		bigLeftToMerge2 = qSize2;
				// switch up the queues so that you split up the strings
						return 1;
				DIE("addQ failed");
					if(!removeQ(&q1, &stringToAdd)){
					}
        if(!removeQ(q, &dummyS)){
#define DIE(msg) exit(fprintf(stderr, "%s\n", msg))
								counter that keeps track of whether the queues
	}
		// now check if LEN is specified, and if it isn't, set it to INT_MAX
		// if we have excess on the first queue...the other queue should be
		if(!removeQ(&q2, &stringToAdd)){
				DIE("removeQ failed");
	// loop through all of the files and read in their lines
		if(!removeQ(&q1, &stringToAdd)){
				qSize1 = qSize2;
		line2 = newGetLine(argv, argc, &inFile, &fileArg);
	if(argc == 1){
			}

				printf("two heads are %s %s\n", head1, head2);
			}
 -- Reading in the files was initially a challenge, as I was initally planning

		// we also want to remember the starting size of each queue

	return 0;

    // check if the queue is empty
				swap(&q1, &q2);
					DIE("addQ() failed!");
    *s = (*nodeToRemove).value;
					if(isEmptyQ(&q1)){
			if(!addQ(&q1, stringToAdd)){
			}

	was empty, or had another line. Then I wrote a new getLine function which
		}
				}
				DIE("removeQ failed");
	// if we've had an odd number of swaps, swap again to keep q1 as priority
		// empty
								most functions								
				qSize1 = qSize2;
	return 0;
// Function that takes in a pointer to a Queue (q) and a string (s), then adds a
		qSize2 = tmp;

	}
int headQ (Queue *q, char **s)
		qSize1 = qSize2;
	while(2 * sizeToMerge < numElements){

				qSize2--;



		// if fopen throws an error
		// this probably shouldn't ever happen but i'll do this just in case
		argLength += (test + 1);
		qSize2 = tmp;
// memory associated with it
	if(argc == 1){
		while(bigLeftToMerge1 > 0 && bigLeftToMerge2 > 0){
	char *line, *head1, *head2, *stringToAdd;
	char *line, *head1, *head2, *stringToAdd;
			int tmp = qSize1;
	Queue q1 = NULL, q2 = NULL;
	FILE *inFile;
#include "/c/cs223/Hwk4/Queue.h"
	char *line, *head1, *head2, *stringToAdd;
			// do line+1 to make sure we don't include the comma
				printf("size we're merging: %d\n", sizeToMerge);
		}
			qSize1 = qSize2;
								and Annie Chen						
void swap(int *arg1, int *arg2);
    Node *nodeToRemove = (**q).next;
	*q1 = *q2;
	while(!isEmptyQ(&q2)){

			tmp = bigLeftToMerge1;
	if(qSize2 > qSize1){
					}
		if(!headQ(&q1, &head1) || !headQ(&q2, &head2)){
		// files start at the next command line argument
// Implementation of Queue ADT using headless, singly-linked, circular list.
}
				}
				if(strcmp(head1, head2) < 0){
	// fileArg is the index of argv where files start, sizeToMerge is the
					bigLeftToMerge1--;
    char *value;
		// now check if LEN is specified, and if it isn't, set it to INT_MAX
3/3		10:15pm		1 hour		Worked out stable mergesort algorithm using two
		while(bigLeftToMerge1 > 0 && bigLeftToMerge2 > 0){
			DIE("removeQ failed");
				qSize2 = tmp;
	char *line, *head1, *head2, *stringToAdd;
				if(!addQ(&q1, stringToAdd)){


	int firstFileArg = 1, sizeToMerge = 1, numElements = 0;
// you finish the first merging, alternating which queue you push to
		// now check if LEN is specified, and if it isn't, set it to INT_MAX
		// if fopen throws an error
}#include <stdio.h>
	// make sure there's at least one argument after Merge16
	if(qSize2 > qSize1){
				printf("size we're merging: %d\n", sizeToMerge);
	}
			}
	bigLeftToMerge2 = qSize2;
						DIE("removeQ failed");
// From then on, just keep comparing heads until one of the queues is empty
				DIE("addQ failed");
		qSize1 = qSize2;
		}
		}
		if(line[0] == ','){
					bigLeftToMerge1--;
			if(!addQ(&q1, stringToAdd)){
		qSize2 = tmp;
		// now check if LEN is specified, and if it isn't, set it to INT_MAX

	destroyQ(&q1);

				// compare the two values, remove from whichever one is smaller
				else if(strcmp(head1, head2) > 0){
		fullCommand = malloc(fullLength);
			}

			}

	}
	}
				DIE("addQ failed");
	while(2 * sizeToMerge < numElements){
        (*newNode).next = (**q).next;
				if(!addQ(&q1, stringToAdd)){
    // by pointing it to the first node and making the previous node point to it
			return 1;
					}
		int tmp = qSize1;
				return 1;
				// if we have a tie, remove from the queue that has priority
					leftToMerge2--;
			DIE("removeQ failed");
	// now we can finally start mergesorting!
void swap(Queue *arg1, Queue *arg2);
		printf("%s\n", stringToAdd);
	char *stdInput, *fullCommand, *line;
		}

				else{
void swap(Queue *arg1, Queue *arg2);
void swapQueues(Queue *arg1, Queue *arg2);

// between consecutive merges
		// now we've finished the merging -- now some housekeeping
		while(bigLeftToMerge2 > 0){
}// hold two copies of the list in the beginning and 

				if(!addQ(&q1, stringToAdd)){
					leftToMerge2--;
				}
				}
					DIE("addQ failed");
#include <stdlib.h>
					bigLeftToMerge1--;
			bigLeftToMerge1--;
		}

		inFile = fopen(argv[i], "r");
						printf("q1 is empty\n");
#include "/c/cs223/Hwk4/Queue.h"
		while(bigLeftToMerge1 > 0 && bigLeftToMerge2 > 0){
	// if there's stuff left over from the first queue
				return 1;
		bigLeftToMerge2 = qSize2;
*/
				DIE("removeQ failed");
			swap(&qPos1, &qPos2);

				DIE("addQ failed");
	// head1 and head2 will point to the results of headQ() on the two queues
	// if we've had an odd number of swaps, swap again to keep q1 as priority
		else if(strcmp(head1, head2) > 0){
			}
				qSize1 = qSize2;
		qSize2 = tmp;
}
	addQ()s, as the one that I originally had workd in N ceil(Log(N)).
		if(!headQ(&q1, &head1) || !headQ(&q2, &head2)){
	}

				// call headQ and store values into head1 and head2
		int tmp = qSize1;
				// call headQ and store values into head1 and head2
			return 1;
			}

			}
						DIE("removeQ failed");
	}
		return 1;
		// this probably shouldn't ever happen but i'll do this just in case
#include <limits.h>
    // if there is only one node
	*q1 = *q2;

			DIE("File could not be opened!");

		// record the offset where we want to start comparing (again, either 
	}
		}

	}
					leftToMerge2--;
				// we don't free since the queue still points to the same addr


		offset1 = min(pos, lineSize1);
	Queue dummy = *q1;
						DIE("removeQ failed");
*/
	Queue q1 = NULL, q2 = NULL;

	bigLeftToMerge2 = qSize2;
				qSize2 = tmp;
			// this is swapping the queue that we put successive sub-merges 
        (**q).next = (*nodeToRemove).next;
		printf("biglefts: %d %d\n", bigLeftToMerge1, bigLeftToMerge2);
		else{
			tmp = bigLeftToMerge1;
		qSize2 = tmp;
				else if(strcmp(head1, head2) > 0){

int min(int a, int b){
				// if we hit the end of the queue we're merging, stop
	*b = dummy;

		}
3/21	4:30pm		.5 hours	Put more detailed comments in the code
	while(!isEmptyQ(&q1)){
	while(!isEmptyQ(&q1)){
{
		// now we've finished the merging -- now some housekeeping
		while(bigLeftToMerge1 > 0){
		}
				swap(&q1, &q2);
					return 1;

				if(!headQ(&q1, &head1) || !headQ(&q2, &head2)){
		if(!headQ(&q1, &head1) || !headQ(&q2, &head2)){
		// this probably shouldn't ever happen but i'll do this just in case
				if(!addQ(&q1, stringToAdd)){
		while(bigLeftToMerge2 > 0){
// whether queue is empty

#include <string.h>
#include <string.h>

		swap(&q1, &q2);
		// if we have a tie, remove from the queue that has priority
    Node *newNode = malloc(sizeof(Node));
					return 1;
			return 1;
						return 1;
		bigLeftToMerge2 = qSize2;
	// argumentString = strcat(argumentString, argv[1]);
	// fileArg is the index of argv where files start, sizeToMerge is the

{
		if(line[0] == ','){
		qSize2 = tmp;
	bigLeftToMerge2 = qSize2;
				qSize1++;
						DIE("removeQ failed");
			if(!removeQ(&q1, &stringToAdd)){
			while(leftToMerge1 > 0){
	FILE *inFile;
		qSize1 = qSize2;
// Queue.c by Dennis Duan
					qSize1--;
	}
void swapQueues(Queue *arg1, Queue *arg2);
	// otherwise there's stuff left over from the second queue
		qSize1 = qSize2;
	// if there's stuff left over from the first queue
				// between the two queues
					bigLeftToMerge1--;
	while(!isEmptyQ(&q1) && !isEmptyQ(&q2)){
			while(leftToMerge1 > 0){
// function to swap two queues (i.e. swap the pointers to the two nodes)
		}
				else if(strcmp(head1, head2) > 0){
		line2 = newGetLine(argv, argc, &inFile, &fileArg);
				return 1;
					}
				// switch up the queues so that you split up the strings

	Queue dummy = *q1;

				if(!headQ(&q1, &head1) || !headQ(&q2, &head2)){
	*q1 = *q2;
				DIE("removeQ failed");
			}
		leftToMerge1 = leftToMerge2 = sizeToMerge;
				int tmp = qSize1;
	}
				qSize1++;
		// this probably shouldn't ever happen but i'll do this just in case
// function to swap two queues (i.e. swap the pointers to the two nodes)
					leftToMerge1--;
					return 1;
					return 1;
			if(!addQ(&q1, stringToAdd)){
					return 1;
m
				if(!addQ(&q1, line)){

			DIE("removeQ failed");

				if(!addQ(&q1, stringToAdd)){
					leftToMerge2--;
	while(!isEmptyQ(&q1) && !isEmptyQ(&q2)){
		if(!removeQ(&q2, &stringToAdd)){
			len = INT_MAX;
					DIE("addQ failed");
		free(stringToAdd);

	while(!isEmptyQ(&q2)){
	// one
					if(!removeQ(&q2, &stringToAdd)){
// should take at most N*log2(N) adds.
					leftToMerge1--;
				printf("bigLeftToMerges: %d %d\n", bigLeftToMerge1, bigLeftToMerge2);
				}
				printf("size we're merging: %d\n", sizeToMerge);
	while(!isEmptyQ(&q2)){

	bigLeftToMerge2 = qSize2;
		printf("%s", stringToAdd);
	}
				swap(&q1, &q2);
					bigLeftToMerge1--;
								and Annie Chen						
		}
				leftToMerge2--;
		else if(strcmp(head1, head2) > 0){
		while(bigLeftToMerge2 > 0){
			swap(&stopMergeIndex2, &stopMergeIndex1);
		qSize1 = qSize2;
				}
		qSize2 = tmp;
		// if fopen throws an error
					return 1;
		inFile = fopen(argv[i], "r");
			}
	}
		bigLeftToMerge2 = qSize2;
3/9		4:30pm		1 hour		It now sorts but only handles powers of 2 and is
	// inFile is a pointer to the file we're reading in
					if(!removeQ(&q1, &stringToAdd)){
	// if there's stuff left over from the first queue
				}
	}
    *q = newNode;
					DIE("addQ failed");
	// now we print out the things in the queues, doing the last merge at
	char *line, *head1, *head2, *stringToAdd;
			while(qPos1 < stopMergeIndex1 && qPos2 < stopMergeIndex2) {	
		}
		fullCommand = memset(fullCommand, 0, fullLength);
// offset the bottom one by one. Then keep comparing heads until
			}
					return 1;
					return 1;
				}
					qSize1--;
				DIE("addQ failed");
// offset the bottom one by one. Then keep comparing heads until
			swap(&startSize1, &startSize2);

		else{
	// if there's stuff left over from the first queue
		inFile = fopen(argv[i], "r");
				// so we have to check whether the queues are reversed
			if(!removeQ(&q2, &stringToAdd)){
 				
			swapQueues(&q1, &q2);
		// empty
			if(!removeQ(&q2, &stringToAdd)){
						return 1;
	}
	}
					leftToMerge1--;
			}
				// now add the string to whichever queue we're currently adding to 
	long pos, len;
			}
3/10	9:30pm		.5 hours	Debugged, but now it infinite loops instead of
// should take at most N*log2(N) adds.


				DIE("removeQ failed");

					DIE("addQ failed");
	// the same time
		}
	// offset1 and offset2 are the indices where we want to start comparing
			}
#include <string.h>
	to call getLine() twice per loop and then running a lot of cases on which
		qSize2 = tmp;
	// if we have a hyphen on the first argument, we have POS
	destroyQ(&q1);
			tmp = bigLeftToMerge1;
			}
				// if we have a tie, remove from the queue that has priority
	// make sure there's at least one argument after Merge16
		printf("biglefts: %d %d\n", bigLeftToMerge1, bigLeftToMerge2);
		printf("%s", stringToAdd);
								queues
				if(!removeQ(&q2, &stringToAdd)){
	if(!createQ(&q1) || !createQ(&q2)){
			stopMergeIndex1 = min(stopMergeIndex1 + sizeToMerge, startSize1);


			while(leftToMerge1 > 0 && leftToMerge2 > 0){
			}
				if(!addQ(&q1, stringToAdd)){
		if(inFile == NULL){
					if(!removeQ(&q2, &stringToAdd)){
					}
	for(int i = firstFileArg; i < argc; i++){
					qSize2--;
				}
						DIE("removeQ failed");
	}
	if(argc == 1){
#include <stdlib.h>

		bigLeftToMerge1 = qSize1;
			int tmp = qSize1;
			}
	// we'll always add to q1, then swap each time
			while(qPos1 < stopMergeIndex1){
		while(bigLeftToMerge2 > 0){

		inFile = fopen(argv[i], "r");
// main function...goes through each of the arguments and interprets them as
		if(line[0] == ','){
	// if we've had an odd number of swaps, swap again to keep q1 as priority
					qSize1--;
// function to swap two queues (i.e. swap the pointers to the two nodes)
	return 0;
	while(!isEmptyQ(&q1) && !isEmptyQ(&q2)){
			tmp = bigLeftToMerge1;
		printf("size to merge bottom: %d\n", sizeToMerge);

int main(int argc, char *argv[]){
	// now we print out the things in the queues, doing the last merge at
		// read in the next line for line2

				}
				DIE("removeQ failed");
		if(!removeQ(&q2, &stringToAdd)){

			DIE("removeQ failed");
}// hold two copies of the list in the beginning and 
		qSize2 = tmp;
				}
				qSize1++;

				if(!addQ(&q1, line)){
}
				qSize1++;
			//free(line);
			DIE("File could not be opened!");
		firstFileArg = 2;
	}
#include <stdio.h>
			len = strtol(line + 1, &line, 10);
			while((line = getLine(inFile)) != NULL){
		// if we have a tie, remove from the queue that has priority
			}
3/21	4:30pm		.5 hours	Put more detailed comments in the code
					qSize1--;
					}
				DIE("removeQ failed");
			bigLeftToMerge2 = tmp;
		bigLeftToMerge2 = qSize2;
					leftToMerge1--;
			bigLeftToMerge1--;
	}
    // if the queue is empty, it has no head, so it fails
			}
		while(bigLeftToMerge1 > 0){
// the list (or NULL if the queue is empty).
    if(s == NULL){
// you finish the first merging, alternating which queue you push to
		}
	destroyQ(&q1);
	while(2 * sizeToMerge < numElements){
			if(!removeQ(&q1, &stringToAdd)){
			return 1;
					DIE("removeQ failed");
			len = INT_MAX;
				leftToMerge2--;
				DIE("removeQ failed");
				DIE("removeQ failed");
				line2[lineSize2 - 1] = '\0';
					}
			// if there's stuff left over from the first queue
				if(!addQ(&q1, stringToAdd)){
		}
				qSize1++;
		for(int i = 1; i < argc; i++){
					DIE("headQ failed");
			fullCommand = strcat(fullCommand, argv[i]);


					}
				}
					DIE("removeQ failed");
// offset the bottom one by one. Then keep comparing heads until
				DIE("addQ failed");
			// if there's stuff left over from the first queue
	Queue q1 = NULL, q2 = NULL;
	Queue q1 = NULL, q2 = NULL;
    }
		else{
				return 1;
					qSize2--;
				}
    }
			}
		else{
	}
#include <stdio.h>
					}
				if(!headQ(&q1, &head1) || !headQ(&q2, &head2)){
	// if we have a hyphen on the first argument, we have POS
		free(stringToAdd);
				}
		inFile = fopen(argv[i], "r");
					return 1;
			}
3/9		7:30pm		1 hour		Sorts a little bit better but somehow breaks


			// otherwise there's stuff left over from the second queue
					bigLeftToMerge1--;
		else if(line1[0] == '\0'){

				if(!addQ(&q1, stringToAdd)){
    // loop through all the nodes and call removeQ() on all of them (which
			leftToMerge1 = leftToMerge2 = sizeToMerge;
#include "/c/cs223/Hwk4/Queue.h"

	worked between files, and it worked splendidly.
	}
		// if fopen throws an error
	if(argc == 1){
#include <stdio.h>
	// the same time. Loop through until one of the queues is empty
	// the same time
	}
#define DIE(msg) exit(fprintf(stderr, "%s\n", msg))
}
			while((line = getLine(inFile)) != NULL){
			if(!removeQ(&q1, &stringToAdd)){
	// if getLine doesn't fail, return its result
					qSize1--;
			}
3/10	8:30pm		1 hour		Change method of keeping track of indexes when
			return 1;
#include <string.h>

				}
	}
					return 1;

				// switch up the queues so that you split up the strings
				// now add the string to whichever queue we're currently adding to 
// Returns true if operation succeeded, false if it failed
		int tmp = qSize1;
			while(leftToMerge1 > 0){
3/3		10:15pm		1 hour		Worked out stable mergesort algorithm using two
				bigLeftToMerge1--;
	}
					DIE("headQ failed");
					return 1;
						return 1;
				}
				}
			swap(&startSize1, &startSize2);
			bigLeftToMerge2--;
				if(!addQ(&q1, line1)){
	while(sizeToMerge * 2 < numElements){ 
			// otherwise there's stuff left over from the second queue
					bigLeftToMerge2--;
				}
	char *line, *head1, *head2, *stringToAdd;
			len = strtol(line + 1, &line, 10);
				}
// function to swap two queues (i.e. swap the pointers to the two nodes)
        // if removeQ returns false, we're screwed
	// for(int i = 2; i < argc; i++){

					leftToMerge1--;
				if(!removeQ(&q1, &stringToAdd)){
					DIE("addQ failed");
						return 1;
#define DIE(msg) exit(fprintf(stderr, "%s\n", msg))
					DIE("headQ failed");
			bigLeftToMerge1--;
				}
				DIE("addQ failed");
	// make sure there's at least one argument after Merge16
				// now add the string to whichever queue we're currently adding to 
	// if we have a hyphen on the first argument, we have POS
#include <stdio.h>
				// we don't free since the queue still points to the same addr
*/
				}
				// if we have a tie, remove from the queue that has priority
			while(leftToMerge1 > 0){
								merging
		inFile = fopen(argv[i], "r");
			qSize2--;
				if(!headQ(&q1, &head1) || !headQ(&q2, &head2)){
			if(!removeQ(&q2, &stringToAdd)){
			}
	// otherwise there's stuff left over from the second queue
		printf("%s", stringToAdd);
 				
			//free(line);
			DIE("removeQ failed");
				qSize1++;
		printf("size to merge bottom: %d\n", sizeToMerge);
					return 1;
		}
			}
void swap(Queue *q1, Queue *q2){
					return 1;
				if(strncmp(head1 + offset1, head2 + offset2, len) < 0){
// function to replace getLine. Takes in a pointer to argv, argc, a pointer to
		printf("biglefts: %d %d\n", bigLeftToMerge1, bigLeftToMerge2);
    return true;
			qSize1 = qSize2;
					qSize1--;
void swap(Queue *q1, Queue *q2){
// function to swap two queues (i.e. swap the pointers to the two nodes)
			return 1;
			qSize2--;
			if(!removeQ(&q1, &stringToAdd)){
			}
3/3		10:15pm		1 hour		Worked out stable mergesort algorithm using two
		else{

				qSize2 = tmp;
		int lineSize1 = strlen(line1);
				if(!addQ(&q1, stringToAdd)){
	destroyQ(&q1);
	*q1 = *q2;
		offset2 = min(pos, strlen(head2));

			return 1;

				DIE("removeQ failed");
		leftToMerge1 = leftToMerge2 = sizeToMerge;
    char *dummyS;
			}
					return 1;
				DIE("addQ failed");
						return 1;

				// we don't free since the queue still points to the same addr
char *newGetLine(char *argv[], int argc, FILE **fileToRead, int *fileIndex){
		// if fopen throws an error
		}

			}
				// between the two queues
		free(stringToAdd);

}
		if(!removeQ(&q2, &stringToAdd)){
	}
				DIE("removeQ failed");
}

		// remove the newline (set the newline character to the null character)
			len = INT_MAX;
// offset the bottom one by one. Then keep comparing heads until
	// we don't have to merge the last time -- just print out
}
				DIE("removeQ failed");
			bigLeftToMerge1--;
        free(*q);
				}
// function to swap two queues (i.e. swap the pointers to the two nodes)
				DIE("addQ failed");
    // frees each of the nodes)
		inFile = fopen(argv[i], "r");
		stopMergeIndex1 = stopMergeIndex2 = 0;
	int leftToMerge1 = 1, leftToMerge2 = 1;
    return true;
					bigLeftToMerge1--;
	if(argc == 1){
						DIE("removeQ failed");
					if(!removeQ(&q1, &stringToAdd)){
					}
		// if fopen throws an error
				// compare the two values, remove from whichever one is smaller
	// now loop through the rest of the args and read them as files
				qSize2 = tmp;
				qSize1++;
				printf("two heads are %s %s\n", head1, head2);
		return 1;
				// update the size each time, again incrementing by two
		}
// between consecutive merges
				leftToMerge1--;
		// if we have excess on the first queue...the other queue should be
	// we don't have to merge the last time -- just print out
	// }
		// compare the two values, remove from whichever one is smaller
		printf("%s", stringToAdd);
	while(!isEmptyQ(&q1)){

#define DIE(msg) exit(fprintf(stderr, "%s\n", msg))
					if(!removeQ(&q1, &stringToAdd)){
	if(qSize2 > qSize1){
			len = INT_MAX;
	if(qSize2 > qSize1){
		}
					return 1;
				}
		return 1;
		// call headQ and store values into head1 and head2
			while((line = getLine(inFile)) != NULL){

		else{
						DIE("removeQ failed");
    if(s == NULL){
		sizeToMerge *= 2;
// and false otherwise
		// if we have a tie, remove from the queue that has priority
				// add two lines at a time
					return 1;
// Function that takes in a pointer to a queue (q) and destroys it, freeing all
		// if fopen throws an error
	char *line, *head1, *head2, *stringToAdd;
	Once I had the algorithm, it was then difficult to get it under N Log(N)
			while(leftToMerge2 > 0){
		}
				printf("left to merges: %d %d\n", leftToMerge1, leftToMerge2);
				numElements++;
				}
			DIE("removeQ failed");
								not stable
		}
typedef struct node {           
	// merge size (e.g. this )
			}
					DIE("addQ failed");
		}
	// otherwise there's stuff left over from the second queue
					return 1;
					DIE("headQ failed");
				}
// function to swap two queues (i.e. swap the pointers to the two nodes)
	int leftToMerge1 = 1, leftToMerge2 = 1;

			// do line+1 to make sure we don't include the comma
	// we don't have to merge the last time -- just print out
			while(leftToMerge1 > 0 && leftToMerge2 > 0){
				// we don't free since the queue still points to the same addr
					}
						return 1;
				return 1;
		pos = strtol(argv[1] + 1, &line, 10);
		swap(&q1, &q2);
	// if we've had an odd number of swaps, swap again to keep q1 as priority
// the list (or NULL if the queue is empty).
					}
			if(!removeQ(&q1, &stringToAdd)){
	int leftToMerge1 = 1, leftToMerge2 = 1;
				if(!removeQ(&q2, &stringToAdd)){
// offset the bottom one by one. Then keep comparing heads until
				qSize1++;
	}
		qSize1 = qSize2;

	}
				}
}// hold two copies of the list in the beginning and 
					leftToMerge2--;
				DIE("removeQ failed");
			if(!removeQ(&q2, &stringToAdd)){
				qSize1 = qSize2;
// memory associated with it
		// call headQ and store values into head1 and head2
			}
	int qSize1 = 0, qSize2 = 0, bigLeftToMerge2, bigLeftToMerge1;
		free(stringToAdd);
		if(line[0] == ','){

			if(!removeQ(&q2, &stringToAdd)){
				}
3/21	4:30pm		.5 hours	Put more detailed comments in the code
				// we don't free since the queue still points to the same addr

    while(!isEmptyQ(q)){
	}
				else{
					if(!removeQ(&q1, &stringToAdd)){
    else{
#include "/c/cs223/Hwk3/getLine.h"
				}
				if(!addQ(&q1, stringToAdd)){
				printf("two heads are %s %s\n", head1, head2);
			}
		bigLeftToMerge1 = qSize1;
			}
			qSize2--;
	// now we print out the things in the queues, doing the last merge at
					DIE("addQ failed");
				else if(strcmp(head1, head2) > 0){
					if(!removeQ(&q1, &stringToAdd)){
				}
					return 1;
	int dummy = *a;
			}
		bigLeftToMerge1 = qSize1;
				qSize1++;
	various while loops, so it took me three or four tries of redoing my code
	bigLeftToMerge1 = qSize1;

	long pos, len;
					DIE("addQ failed");
			return 1;

// between consecutive merges
	char *line1, *line2, *head1, *head2, *stringToAdd;
				// call headQ and store values into head1 and head2
				}
			}
	// if there's stuff left over from the first queue
	// are the indices in the merge that we've been through

		// remove the newline (set the newline character to the null character)
// you finish the first merging, alternating which queue you push to
			}
			// otherwise there's stuff left over from the second queue
		return 1;
					qSize1--;
				}
	int firstFileArg = 1, sizeToMerge = 1, numElements = 0;
// should take at most N*log2(N) adds.
		// compare the two values, remove from whichever one is smaller
	// now loop through the rest of the args and read them as files
					DIE("removeQ failed");
				}
					if(isEmptyQ(&q1)){
	while(!isEmptyQ(&q2)){
// between consecutive merges

				swap(&q1, &q2);

		// if fopen throws an error
	// otherwise there's stuff left over from the second queue
				return 1;
		fullCommand = strcat(fullCommand, stdInput);
				if(!addQ(&q1, line)){
	// if there's stuff left over from the first queue
			qSize2--;
			}
				if(!addQ(&q1, line)){
					if(!removeQ(&q2, &stringToAdd)){
	for(int i = firstFileArg; i < argc; i++){
			bigLeftToMerge1 = bigLeftToMerge2;
	// make sure there's at least one argument after Merge16
				if(!addQ(&q1, line1)){
								and	now I'm dealing with a lot of seg faults
		swap(&q1, &q2);
			bigLeftToMerge2--;
				qSize1++;
	Queue dummy = *q1;

	FILE *inFile;
			}
		free(stringToAdd);
		}
			DIE("removeQ failed");
    // loop through all the nodes and call removeQ() on all of them (which
						printf("q1 is empty\n");
					DIE("removeQ failed");
			}
				qSize1 = qSize2;
	}
		// if we have excess on the first queue...the other queue should be
int main(int argc, char *argv[]){
	}
				if(!addQ(&q1, line)){
		qSize1 = qSize2;
				printf("two heads are %s %s\n", head1, head2);
	}
					if(!removeQ(&q1, &stringToAdd)){
		firstFileArg = 2;
					qSize2--;
int removeQ (Queue *q, char **s)
	}

								and Annie Chen						
		sizeToMerge *= 2;
			return 1;
		else if(reversed){

						DIE("removeQ failed");
// Defines Node type and functions to add, remove, peek, destroy, and check
					return 1;
	fclose(inFile);
// function to swap two queues (i.e. swap the pointers to the two nodes)
					DIE("addQ failed");
void swap(Queue *arg1, Queue *arg2);
	}
			}
{

			bigLeftToMerge1--;
		qSize2 = tmp;
			qSize1 = qSize2;
						DIE("removeQ failed");
		}
				return 1;
		}

		if(inFile == NULL){
			}
			}
 				


	}
			DIE("removeQ failed");
				if(!addQ(&q1, line)){
				DIE("removeQ failed");

				swap(&q1, &q2);
			qSize1++;
	// otherwise there's stuff left over from the second queue
			if(!addQ(&q1, stringToAdd)){
}// hold two copies of the list in the beginning and 
				if(!headQ(&q1, &head1) || !headQ(&q2, &head2)){
// Defines Node type and functions to add, remove, peek, destroy, and check
		free(line);
		stdInput = strncpy(stdInput, line, strlen(line) - 1);
		firstFileArg = 2;
// you finish the first merging, alternating which queue you push to
								merging

					if(!removeQ(&q1, &stringToAdd)){
			numElements++;

				if(!addQ(&q1, stringToAdd)){

		// now check if LEN is specified, and if it isn't, set it to INT_MAX
				}
						return 1;
	while(!isEmptyQ(&q2)){
					}
		if(strcmp(head1, head2) < 0){
			int tmp = qSize1;
	}
				printf("left to merges: %d %d\n", leftToMerge1, leftToMerge2);
					return 1;
				}
				}
				qSize1++;
					qSize1--;
	if(argv[1][0] == '-'){

						printf("q1 is empty\n");
		}
    }

				qSize1++;
					if(!removeQ(&q2, &stringToAdd)){
		}
	}
					if(!removeQ(&q1, &stringToAdd)){
		leftToMerge1 = leftToMerge2 = sizeToMerge;
// From then on, just keep comparing heads until one of the queues is empty
		fullCommand = strcat(fullCommand, stdInput);

		}
				// add each line in q1
		if(!removeQ(&q1, &stringToAdd)){
		}
				}
				}
				if(!addQ(&q1, stringToAdd)){
				return 1;
		printf("size to merge bottom: %d\n", sizeToMerge);
				}
	if(!createQ(&q1) || !createQ(&q2)){
	// we don't have to merge the last time -- just print out
int createQ (Queue *q)

	while(!isEmptyQ(&q1) && !isEmptyQ(&q2)){
			while(leftToMerge1 > 0){
	if(!createQ(&q1) || !createQ(&q2)){
			if(!removeQ(&q2, &stringToAdd)){
				DIE("removeQ failed");
        // if removeQ returns false, we're screwed

			swap(&startSize1, &startSize2);
	// inFile is a pointer to the file we're reading in
				}
			}
		free(stringToAdd);
		// if we've reached the end of the arguments, return NULL
		fullCommand = strcat(fullCommand, stdInput);
			// otherwise there's stuff left over from the second queue
		swap(&q1, &q2);
	}
					leftToMerge1--;
#include <string.h>
	// the same time
				bigLeftToMerge2--;
	// now loop through the rest of the args and read them as files
				}
					if(!removeQ(&q1, &stringToAdd)){
		}
		printf("%s", stringToAdd);
			}
		reversed = !reversed;
#include <stdlib.h>
				DIE("removeQ failed");
				// we don't free since the queue still points to the same addr
					return 1;
			bigLeftToMerge1 = bigLeftToMerge2;

		else if(strcmp(head1, head2) > 0){
3/7		4:00pm		.5 hours	Started implementation of mergesort, didn't get
				// and update the size and position
		// now we've finished the merging -- now some housekeeping
		}
					leftToMerge2--;
				printf("size we're merging: %d\n", sizeToMerge);

	// now we print out the things in the queues, doing the last merge at
					leftToMerge1--;
				}
			}
		}
		if(line[0] == ','){
    }
		bigLeftToMerge1 = qSize1;


					return 1;
		if(inFile == NULL){
3/15	9:00pm		1 hour		Sorts fine, mostly stable, seems to work with PO								S,LEN
				DIE("removeQ failed");
 -- Getting the algorithm for two-queue mergesort was difficult to begin with.
				return 1;
			reversed = !reversed;
	// now we print out the things in the queues, doing the last merge at
		line2 = newGetLine(argv, argc, &inFile, &fileArg);
		inFile = fopen(argv[i], "r");
					bigLeftToMerge2--;

					DIE("headQ failed");
	// if we have a hyphen on the first argument, we have POS
	for(int i = firstFileArg; i < argc; i++){

			}
    if(isEmptyQ(q)){
				}

			bigLeftToMerge2--;


		qSize2 = tmp;
		else{
		// if we've reached the end of the arguments, return NULL

			}
    *q = temp;
			DIE("File could not be opened!");
				if(!addQ(&q1, stringToAdd)){
				swap(&q1, &q2);
					}
					bigLeftToMerge1--;
		bigLeftToMerge1 = qSize1;
// between consecutive merges
		reversed = !reversed;
			return 1;
#include <limits.h>
	return 0;
	// if we have a hyphen on the first argument, we have POS
/*Progress report: sorts, but doesn't handle it when there's leftover between merges (i.e. when one bigleft is nonzero but the other is zero)
		free(stringToAdd);
#include <stdlib.h>

// (next) to the next node in the linked list
#include "/c/cs223/Hwk3/getLine.h"
	int qSize1 = 0, qSize2 = 0, bigLeftToMerge2, bigLeftToMerge1;
	if(!createQ(&q1) || !createQ(&q2)){
				qSize1++;
			// open the file and loop through the lines
// the list (or NULL if the queue is empty).
				printf("two heads are %s %s\n", head1, head2);
			}
void swap(int *a, int *b){
		// compare the two values, remove from whichever one is smaller
					DIE("addQ failed");

		}
		firstFileArg = 2;
		printf("size to merge bottom: %d\n", sizeToMerge);
		while(bigLeftToMerge2 > 0){
	// we'll always add to q1, then swap each time
		else{
			}
			//free(line);
a
	*q2 = dummy;
				if(!addQ(&q1, line)){
		else if(strcmp(head1, head2) > 0){
// and prints the sorted lines to the standard output
					DIE("addQ failed");
// Returns true if operation succeeded, false if it failed
				return 1;
			if(!removeQ(&q1, &stringToAdd)){
				DIE("removeQ failed");
				printf("size we're merging: %d\n", sizeToMerge);
					qSize1--;
		if(!removeQ(&q2, &stringToAdd)){

				numElements++;
					DIE("addQ failed");
		// if fopen throws an error
				int tmp = qSize1;
#include <stdbool.h>
		}
		int tmp = qSize1;
					DIE("removeQ failed");
		while(bigLeftToMerge1 > 0 && bigLeftToMerge2 > 0){
			if(line2[lineSize2 - 1] == '\n'){
				return 1;
					}
	int qSize1 = 0, qSize2 = 0, bigLeftToMerge2, bigLeftToMerge1;
								and Annie Chen						
		// empty
		if(reversed){
	// we don't have to merge the last time -- just print out
	}

			}
		while(bigLeftToMerge2 > 0){
			while(leftToMerge1 > 0 && leftToMerge2 > 0){
				// now add the string to whichever queue we're currently adding to 
3/10	8:30pm		1 hour		Change method of keeping track of indexes when
				// if we hit the end of the queue we're merging, stop
			if(!addQ(&q1, stringToAdd)){
				// we don't free since the queue still points to the same addr
		printf("%s", stringToAdd);
		if(!removeQ(&q1, &stringToAdd)){
					return 1;
				qSize1++;
			while(leftToMerge1 > 0 && leftToMerge2 > 0){
		printf("%s", stringToAdd);
	if(!createQ(&q1) || !createQ(&q2)){

						DIE("removeQ failed");
		swap(&q1, &q2);
	while(!isEmptyQ(&q1)){
#include <stdlib.h>
			if(line2[lineSize2 - 1] == '\n'){

				leftToMerge1--;
			if(!removeQ(&q2, &stringToAdd)){
				}
		else{
	*q1 = *q2;
		// if we have a tie, remove from the queue that has priority
		sizeToMerge *= 2;
				if(!addQ(&q1, line)){
	int firstFileArg = 1, sizeToMerge = 1, numElements = 0;
			bigLeftToMerge1 = bigLeftToMerge2;

			if(!removeQ(&q2, &stringToAdd)){
				numElements++;
	*q1 = *q2;

	// the same time. Loop through until one of the queues is empty

				// switch up the queues so that you split up the strings
		pos = strtol(argv[1] + 1, &line, 10);
				if(strcmp(head1, head2) < 0){
			if(!removeQ(&q1, &stringToAdd)){


			swap(&stopMergeIndex2, &stopMergeIndex1);
			}
	int qSize1 = 0, qSize2 = 0, bigLeftToMerge2, bigLeftToMerge1;

					qSize1--;
					return 1;
		int tmp = qSize1;
			swap(&q1, &q2);

						return 1;
	while(!isEmptyQ(&q1) && !isEmptyQ(&q2)){
						DIE("removeQ failed");
				else if(strcmp(head1, head2) > 0){
	*q2 = dummy;
	*q1 = *q2;
		free(stringToAdd);
				}
			return 1;
			// if there's stuff left over from the first queue
					DIE("removeQ failed");
			if(!addQ(&q1, stringToAdd)){
	int qSize1 = 0, qSize2 = 0, bigLeftToMerge2, bigLeftToMerge1;
				printf("bigLeftToMerges: %d %d\n", bigLeftToMerge1, bigLeftToMerge2);
		if(inFile == NULL){
	int leftToMerge1 = 1, leftToMerge2 = 1;
				}
    }
			if(!removeQ(&q2, &stringToAdd)){
					return 1;
								queues
				if(!removeQ(&q1, &stringToAdd)){
		qSize2 = tmp;
3/10	9:30pm		.5 hours	Debugged, but now it infinite loops instead of
		}
				printf("size we're merging: %d\n", sizeToMerge);
	}
		}
			while(leftToMerge1 > 0){
		bigLeftToMerge1 = qSize1;
				qSize1++;
					qSize1--;
	if((line1 = getLine(*fileToRead)) == NULL){

					if(!removeQ(&q1, &stringToAdd)){
				qSize2--;
		// empty
	if(qSize2 > qSize1){
		else{
        free(*q);
					return 1;
	char *line, *head1, *head2, *stringToAdd;
	two at a time and essentially do the first merge as I filled in the queues
}
	*a = *b;
		else{
void swap(Queue *arg1, Queue *arg2);
					DIE("addQ failed");
					return 1;
						return 1;
    if(newNode == NULL){
	// where we want to stop once qPos1 or qPos2 hits them (i.e. the end of a
int main(int argc, char *argv[]){
			return 1;
				}
			DIE("removeQ failed");
				numElements++;
					bigLeftToMerge1--;
			// open the file and loop through the lines

				DIE("removeQ failed");
					DIE("addQ() failed!");
			qSize2 = tmp;
void swap(Queue *q1, Queue *q2){
						return 1;
3/8		3:00pm		1 hour		Finished implementing all of mergesort but it

		// this probably shouldn't ever happen but i'll do this just in case
				if(!addQ(&q1, stringToAdd)){
					}
				if(strcmp(head1, head2) < 0){
		if(inFile == NULL){
			bigLeftToMerge1--;
		}
	Eventually I realized (with the help of Will) that I could read in the lines
// between consecutive merges
	}
			bigLeftToMerge2 = tmp;
				}
				DIE("removeQ failed");
		while(bigLeftToMerge1 > 0){
// hold two copies of the list in the beginning and 
			}
	while(!isEmptyQ(&q2)){
ESTIMATE of total time I will spend: 16 hours
		else{
			while(leftToMerge1 > 0 && leftToMerge2 > 0){
					leftToMerge1--;
		else{
		//stdInput[strlen(line) - 1] = '\0';
	// where we want to stop once qPos1 or qPos2 hits them (i.e. the end of a
				else{
		else if(strcmp(head1, head2) > 0){
		}
int headQ (Queue *q, char **s)

// should take at most N*log2(N) adds.
		}
				if(!addQ(&q1, line)){
		if(line[0] == ','){
}// hold two copies of the list in the beginning and 
				printf("size we're merging: %d\n", sizeToMerge);
		qSize1 = qSize2;
		bigLeftToMerge2 = qSize2;
				if(!headQ(&q1, &head1) || !headQ(&q2, &head2)){
				}
				DIE("addQ failed");
TOTAL time spent: 14.5 hours
3/3		1:30pm		1 hour		Started work on Queue.c, have first version of

    *q = temp;
					DIE("addQ failed!");
		}
				}
					qPos2++;
					}
			}
		}
#include "/c/cs223/Hwk4/Queue.h"
        (**q).next = (*nodeToRemove).next;
		bigLeftToMerge2 = qSize2;
// circular list.  The Queue data type is a pointer to the LAST node in
				}
				// switch up the queues so that you split up the strings
		// otherwise, DIE
	two at a time and essentially do the first merge as I filled in the queues
	}

    if(s == NULL){
			DIE("removeQ failed");
	while(!isEmptyQ(&q1)){
				}
		DIE("createQ() failed!");
				leftToMerge1--;
						return 1;

}
				}
			if(!removeQ(&q2, &stringToAdd)){
	various while loops, so it took me three or four tries of redoing my code
				qSize2--;
				}
				leftToMerge2--;
				// between the two queues
				}
				DIE("addQ failed");
	// if there's no files
			int tmp = qSize1;
		firstFileArg = 2;
					qSize2--;
						DIE("removeQ failed");
	if(argc == 1){
	char *line, *head1, *head2, *stringToAdd;
								not stable
	}
Difficulties I ran into:

			len = strtol(line + 1, &line, 10);
		stdInput = memset(stdInput, 0, strlen(line));
					DIE("addQ failed");
			if(!removeQ(&q1, &stringToAdd)){
	various while loops, so it took me three or four tries of redoing my code
    // otherwise make s point to the string that the next node contains
				}
				DIE("removeQ failed");
				DIE("addQ failed");
			reversed = !reversed;
			bigLeftToMerge2 = tmp;
----	-----		----		-----
		// POS or the end of the string)
					return 1;
				}
// This program takes in the names of one or more files, reads all the lines,
	bigLeftToMerge2 = qSize2;

		else{
				// switch up the queues so that you split up the strings
		DIE("createQ() failed!");
}
	if(argc == 1){
	if(argv[1][0] == '-'){
// the node contains.
	Once I had the algorithm, it was then difficult to get it under N Log(N)
	}
{
#include <string.h>
				}
		return 1;
		while(bigLeftToMerge1 > 0){
					bigLeftToMerge2--;
			// make sure LEN is nonempty positive digits
int main(int argc, char *argv[]){
		bigLeftToMerge2 = qSize2;
		printf("%s", stringToAdd);
		// empty
	}
		}
	to call getLine() twice per loop and then running a lot of cases on which
			}
        *q = NULL;
			}
			return 1;
        if(!removeQ(q, &dummyS)){
				if(!addQ(&q1, stringToAdd)){
		printf("size to merge bottom: %d\n", sizeToMerge);
			DIE("File could not be opened!");
				DIE("removeQ failed");
	int firstFileArg = 1, sizeToMerge = 1, numElements = 0;
		if(inFile == NULL){
				if(strcmp(head1, head2) < 0){
// you finish the first merging, alternating which queue you push to
						DIE("removeQ failed");
		}
						DIE("removeQ failed");
					return 1;
			qSize2 = tmp;
        // if removeQ returns false, we're screwed
		free(line);

    while(!isEmptyQ(q)){
			}
		firstFileArg = 2;
				// compare the two values, remove from whichever one is smaller
		}
					return 1;
				// compare the two values, remove from whichever one is smaller
			bigLeftToMerge1--;
					qSize1--;
		qSize1 = qSize2;
    *q = newNode;
		if(!removeQ(&q2, &stringToAdd)){

		while(bigLeftToMerge1 > 0 && bigLeftToMerge2 > 0){

			qSize2--;
		qSize2 = tmp;
// the node contains.
				swap(&q1, &q2);
 -- Implementing the mergesort was also very difficult. The algorithm involved
				}
						return 1;
		// to by checking whether the queues are switched
2/29	4:00pm		1 hour		Discussed problem statement with Jared Weinstein
			}
			}
		printf("biglefts: %d %d\n", bigLeftToMerge1, bigLeftToMerge2);
				DIE("removeQ failed");
	// otherwise there's stuff left over from the second queue
				qSize2--;
				if(!removeQ(&q1, &stringToAdd)){
		bigLeftToMerge1 = qSize1;

			bigLeftToMerge1 = bigLeftToMerge2;
					if(!removeQ(&q1, &stringToAdd)){

				DIE("removeQ failed");
				}

				// add each line in q1
#include <string.h>
	destroyQ(&q1);
					DIE("addQ() failed!");
	int leftToMerge1 = 1, leftToMerge2 = 1;
				else{
				}
			// otherwise there's stuff left over from the second queue
					if(!removeQ(&q2, &stringToAdd)){
		qSize1 = qSize2;
		}
			DIE("removeQ failed");

			if(!addQ(&q1, stringToAdd)){
			swap(&qPos1, &qPos2);
				if(!addQ(&q1, line1)){
			if(!removeQ(&q1, &stringToAdd)){
	if(!createQ(&q1) || !createQ(&q2)){
					if(!removeQ(&q1, &stringToAdd)){
				DIE("removeQ failed");
		free(stringToAdd);

			bigLeftToMerge1 = bigLeftToMerge2;
		// now we've finished the merging -- now some housekeeping
#include "/c/cs223/Hwk3/getLine.h"

				}
				DIE("removeQ failed");
		// subqueues

		if(line[0] == ','){
						return 1;
 				
			}
					if(!removeQ(&q1, &stringToAdd)){
			// open the file and loop through the lines
		}
		// now check if LEN is specified, and if it isn't, set it to INT_MAX
			len = INT_MAX;
			// if there's stuff left over from the first queue

			bigLeftToMerge2 = tmp;
			while(leftToMerge1 > 0){
				// compare the two values, remove from whichever one is smaller
	// if we've had an odd number of swaps, swap again to keep q1 as priority
	bigLeftToMerge1 = qSize1;
		int tmp = qSize1;
		swapQueues(&q1, &q2);
		}
			//free(line);
	// if getLine doesn't fail, return its result
					}
#include <string.h>

	}
				}

	while((line1 = newGetLine(argv, argc, &inFile, &fileArg)) != NULL){

			len = INT_MAX;
			DIE("removeQ failed");
	}
		}
				if(!headQ(&q1, &head1) || !headQ(&q2, &head2)){
			}
	Eventually I realized (with the help of Will) that I could read in the lines

					DIE("removeQ failed");

			if(!removeQ(&q1, &stringToAdd)){
				qSize1 = qSize2;
		else{
	long pos, len;
		while(bigLeftToMerge1 > 0 && bigLeftToMerge2 > 0){
	int firstFileArg = 1, sizeToMerge = 1, numElements = 0;
	// if there's stuff left over from the first queue
					if(!removeQ(&q2, &stringToAdd)){
			tmp = bigLeftToMerge1;
				if(!removeQ(&q1, &stringToAdd)){
						DIE("removeQ failed");
		bigLeftToMerge2 = qSize2;
		printf("%s", stringToAdd);
				}
			DIE("removeQ failed");
		else if(strcmp(head1, head2) > 0){
		fclose(*fileToRead);

					if(!removeQ(&q2, &stringToAdd)){
			// if there's anything trailing at the end, DIE
			while((line = getLine(inFile)) != NULL){
				}
3/15	9:00pm		1 hour		Sorts fine, mostly stable, seems to work with PO								S,LEN
					return 1;
				// switch up the queues so that you split up the strings
		pos = strtol(argv[1] + 1, &line, 10);
			DIE("removeQ failed");
	*q2 = dummy;
					}
		swap(&q1, &q2);
			swap(&startSize1, &startSize2);
	}
		// if we've reached the end of the arguments, return NULL
				leftToMerge2--;
	}
			}
#define DIE(msg) exit(fprintf(stderr, "%s\n", msg))
	// now we print out the things in the queues, doing the last merge at
#define DIE(msg) exit(fprintf(stderr, "%s\n", msg))
#include <limits.h>
					return 1;
		fclose(*fileToRead);


				// compare the two values, remove from whichever one is smaller
			}
	while(!isEmptyQ(&q1) && !isEmptyQ(&q2)){
					qSize2--;
			while(leftToMerge2 > 0){
	// if there's stuff left over from the first queue
	while(!isEmptyQ(&q2)){
3/15	9:00pm		1 hour		Sorts fine, mostly stable, seems to work with PO								S,LEN
	Eventually I realized (with the help of Will) that I could read in the lines
				swap(&q1, &q2);
		if(line[0] == ','){

    else{
	*q1 = *q2;

				DIE("addQ failed!");
					qSize1--;
		qSize1 = qSize2;
						DIE("removeQ failed");


		}
		while(bigLeftToMerge1 > 0 && bigLeftToMerge2 > 0){
	// if we have a hyphen on the first argument, we have POS
			if(!addQ(&q1, stringToAdd)){
					return 1;
	// now we print out the things in the queues, doing the last merge at
		leftToMerge1 = leftToMerge2 = sizeToMerge;
		while(bigLeftToMerge1 > 0 && bigLeftToMerge2 > 0){
	char *line, *head1, *head2, *stringToAdd;
				else{
	// if we have a hyphen on the first argument, we have POS
		stdInput = malloc(strlen(line));
// hold two copies of the list in the beginning and 
		if(line[0] == ','){
	bigLeftToMerge2 = qSize2;
// From then on, just keep comparing heads until one of the queues is empty
			return 1;
        (**q).next = (*nodeToRemove).next;
	if(!createQ(&q1) || !createQ(&q2)){
// the node
								merging
		}
				numElements++;
				bigLeftToMerge1--;
#define DIE(msg) exit(fprintf(stderr, "%s\n", msg))
					DIE("removeQ failed");
	*q2 = dummy;
int isEmptyQ (Queue *q)
			while(leftToMerge2 > 0){

			}
					qSize1--;
		else{
	destroyQ(&q1);
				swap(&q1, &q2);

				}
// function to swap two queues (i.e. swap the pointers to the two nodes)
			}
	}
	// if there's stuff left over from the first queue
	// we don't have to merge the last time -- just print out

		swap(&q1, &q2);
				DIE("addQ failed");
	destroyQ(&q1);
				if(!addQ(&q1, stringToAdd)){
	}
				int tmp = qSize1;
		// this probably shouldn't ever happen but i'll do this just in case

		// empty
}
}
			DIE("removeQ failed");
			return 1;
		if(!removeQ(&q1, &stringToAdd)){
		fclose(*fileToRead);
			}
					}
		sizeToMerge *= 2;
// offset the bottom one by one. Then keep comparing heads until
				// if we have a tie, remove from the queue that has priority
					if(!removeQ(&q1, &stringToAdd)){
	// the same time
	bigLeftToMerge2 = qSize2;
	FILE *inFile;
				bigLeftToMerge1--;
			DIE("removeQ failed");
					qSize1--;
3/9		4:30pm		1 hour		It now sorts but only handles powers of 2 and is
								doesn't work for big files
				bigLeftToMerge1--;
			while(leftToMerge1 > 0 && leftToMerge2 > 0){

	// otherwise there's stuff left over from the second queue

// Node struct will be used for each node in the linked list.
				}
		// this probably shouldn't ever happen but i'll do this just in case
3/21	4:30pm		.5 hours	Put more detailed comments in the code
					leftToMerge1--;
								merging incorrectly
		}
		qSize2 = tmp;
				}
				bigLeftToMerge1--;

					DIE("removeQ failed");
			// otherwise there's stuff left over from the second queue
				// keep updating size and position

		if(!removeQ(&q2, &stringToAdd)){
			while(leftToMerge1 > 0){
#include <stdbool.h>
				return 1;
	int stopMergeIndex1 = 0, stopMergeIndex2 = 0;

		}
		free(stringToAdd);
	while(!isEmptyQ(&q1)){
			if(!removeQ(&q2, &stringToAdd)){
		// if fopen throws an error
#include <limits.h>
								not stable
				qSize1 = qSize2;
				return 1;

// Function that takes in a pointer to a Queue q and a pointer to a string s,
	}
					return 1;
		else if(strcmp(head1, head2) > 0){
				}

				qSize1++;
		printf("%s", stringToAdd);
			while(leftToMerge1 > 0){
		return 1;
// From then on, just keep comparing heads until one of the queues is empty
			qSize1++;
#include "/c/cs223/Hwk4/Queue.h"
					leftToMerge1--;
		if(!removeQ(&q1, &stringToAdd)){
				qSize1++;
				}

				// now add the string to q1 (since we swap pointers, this will
		fullLength = strlen(echo) + strlen(stdInput) + strlen(subst16Command) + argLength + 1;
int removeQ (Queue *q, char **s)
// function to swap two queues (i.e. swap the pointers to the two nodes)
			}
			if(!removeQ(&q1, &stringToAdd)){
		}
int main(int argc, char *argv[]){
// function to swap two queues (i.e. swap the pointers to the two nodes)
int createQ (Queue *q)
				qSize1 = qSize2;
			bigLeftToMerge1--;

		inFile = fopen(argv[i], "r");
	addQ()s, as the one that I originally had workd in N ceil(Log(N)).
			if(!removeQ(&q1, &stringToAdd)){
				}
				}

				}
		stdInput = malloc(strlen(line));
		else if(strcmp(head1, head2) > 0){
		// if fopen throws an error
	for(int i = firstFileArg; i < argc; i++){
				if(!addQ(&q1, line)){
				if(qPos1 == startSize1 || qPos2 == startSize2){
								and	now I'm dealing with a lot of seg faults
		qSize1 = qSize2;
					qSize1--;

					leftToMerge2--;
		if(line[0] == ','){
		qSize1 = qSize2;
void swap(Queue *q1, Queue *q2){
		bigLeftToMerge2 = qSize2;
	while(!isEmptyQ(&q1) && !isEmptyQ(&q2)){
		firstFileArg = 2;
#include <string.h>
				return 1;

		bigLeftToMerge1 = qSize1;
	// if there's stuff left over from q1, print the rest of q1 and free each
			// open the file and loop through the lines
		}
    return true;
// function to swap two queues (i.e. swap the pointers to the two nodes)
				return 1;
				if(!addQ(&q1, line)){
			bigLeftToMerge2 = tmp;
					}
			qSize1 = qSize2;
					return 1;
		free(stringToAdd);
				printf("left to merges: %d %d\n", leftToMerge1, leftToMerge2);
				qSize1 = qSize2;
// The struct contains a string (value) for the contents of a node and a pointer
						DIE("removeQ failed");
		// if we have a tie, remove from the queue that has priority
// and false otherwise

					}
	// the same time
				}

				}
	if(!createQ(&q1) || !createQ(&q2)){
			// otherwise, we want to do the same with q2, still updating size
		else{
	for(int i = 1; i < argc; i++){
					if(!removeQ(&q1, &stringToAdd)){
	// make sure there's at least one argument after Merge16
#include <stdbool.h>

		fileArg++;
		qSize1 = qSize2;
	two at a time and essentially do the first merge as I filled in the queues
	// the same time
			}
						DIE("removeQ failed");

					}
				int tmp = qSize1;
		if(!removeQ(&q1, &stringToAdd)){
	// q1 will always have the same or one more element than q2
// should take at most N*log2(N) adds.
			len = strtol(line + 1, &line, 10);


		swap(&q1, &q2);
				// call headQ and store values into head1 and head2
		return 1;
					return 1;
				}
	int fullLength, argLength, test;
			}
	// if we have a hyphen on the first argument, we have POS

				// between the two queues

		}
					}
			// this loop checks whether we've reached the end of a sub-merge
			bigLeftToMerge2 = tmp;
		}
	if(inFile == NULL){
		bigLeftToMerge1 = qSize1;
 				
					if(!removeQ(&q2, &stringToAdd)){
ESTIMATE of total time I will spend: 16 hours
			swap(&qPos1, &qPos2);
		else{
*/
				leftToMerge1--;
						printf("q1 is empty\n");
				// between the two queues
			len = INT_MAX;
					DIE("headQ failed");
			swap(&stopMergeIndex2, &stopMergeIndex1);
						DIE("removeQ failed");

				// alternate which queue we add to) 
					if(!removeQ(&q1, &stringToAdd)){
		// call headQ and store values into head1 and head2
					return 1;
			while((line = getLine(inFile)) != NULL){
	for(int i = firstFileArg; i < argc; i++){
}// hold two copies of the list in the beginning and 
			if(!removeQ(&q2, &stringToAdd)){
	}
	int leftToMerge1 = 1, leftToMerge2 = 1;
			while(leftToMerge2 > 0){
		free(stringToAdd);
		int tmp = qSize1;
		swap(&q1, &q2);
					qSize1--;
			qSize2--;
		printf("size to merge bottom: %d\n", sizeToMerge);
		}
			qSize1 = qSize2;
				return 1;
			DIE("removeQ failed");
	// we'll always add to q1, then swap each time
				if(!addQ(&q1, stringToAdd)){
				leftToMerge1--;
				else if(strcmp(head1, head2) > 0){

				int tmp = qSize1;
		printf("%s", stringToAdd);
	while(!isEmptyQ(&q1) && !isEmptyQ(&q2)){
    }
						DIE("removeQ failed");

	while(!isEmptyQ(&q1) && !isEmptyQ(&q2)){

				printf("left to merges: %d %d\n", leftToMerge1, leftToMerge2);

    return true;
						return 1;
					return 1;
			while(leftToMerge1 > 0 && leftToMerge2 > 0){
				DIE("removeQ failed");
			if(!removeQ(&q1, &stringToAdd)){
		if(!headQ(&q1, &head1) || !headQ(&q2, &head2)){
		return 1;
		bigLeftToMerge1 = qSize1;
		swap(&qSize1, &qSize2);
			}
}
			fullCommand = strcat(fullCommand, argv[i]);
// offset the bottom one by one. Then keep comparing heads until
		if(!headQ(&q1, &head1) || !headQ(&q2, &head2)){
#include <limits.h>
				// call headQ and store values into head1 and head2
			}
		// if we have excess on the first queue...the other queue should be
	// we'll always add to q1, then swap each time

p
			if(!removeQ(&q1, &stringToAdd)){
				DIE("removeQ failed");
			if(!removeQ(&q1, &stringToAdd)){
// Function that takes in a pointer to a queue (q) and initializes it to point 
				DIE("removeQ failed");
	FILE *inFile;
			DIE("Invalid POS");
			return 1;
				// between the two queues
    Queue temp = NULL;
        if(!removeQ(q, &dummyS)){

					qSize1--;
	}
	}
				return 1;
						DIE("removeQ failed");
				DIE("removeQ failed");

	}
	// otherwise there's stuff left over from the second queue
	// if we have a hyphen on the first argument, we have POS
			//free(line);
			qSize2--;
			tmp = bigLeftToMerge1;
				qSize1++;
3/3		10:15pm		1 hour		Worked out stable mergesort algorithm using two
	if(argc == 1){

	int firstFileArg = 1, sizeToMerge = 1, numElements = 0;
		}
void swap(Queue *arg1, Queue *arg2);
	}
	// now we print out the things in the queues, doing the last merge at
		}
    return true;
	destroyQ(&q1);
	while(!isEmptyQ(&q1) && !isEmptyQ(&q2)){
				DIE("removeQ failed");
					qSize1--;
			DIE("removeQ failed");

				bigLeftToMerge2--;
					bigLeftToMerge2--;
		// if we have excess on the first queue...the other queue should be
	FILE *inFile;
	for(int i = firstFileArg; i < argc; i++){
		return 1;
// Returns true if operation succeeded, false if it failed
			if(!removeQ(&q1, &stringToAdd)){
		}
	for(int i = 1; i < argc; i++){
					if(isEmptyQ(&q1)){
			qSize1++;

		}
			qSize1++;
	}
					DIE("headQ failed");
		// now we've finished the merging -- now some housekeeping
						DIE("removeQ failed");
				bigLeftToMerge2--;
			}
			}
				if(!addQ(&q1, stringToAdd)){
	various while loops, so it took me three or four tries of redoing my code
	char *line, *head1, *head2, *stringToAdd;

// between consecutive merges
				// start comparing either at POS or the end of the string,
		// empty
				DIE("addQ failed");
				swap(&q1, &q2);
				bigLeftToMerge2--;
			bigLeftToMerge1--;
		bigLeftToMerge2 = qSize2;
    *q = newNode;
		swap(&q1, &q2);
		// recursive call on the new file
#include <limits.h>
		return 1;

					leftToMerge1--;

			qSize1 = qSize2;

	// reversed is true if the queues are reversed (i.e. if q2 points to the
			return 1;

		return 1;
		//stdInput[strlen(line) - 1] = '\0';
				// if we have a tie, remove from the queue that has priority
			len = strtol(line + 1, &line, 10);
// them point to the other address
				DIE("addQ failed");
	// if we have a hyphen on the first argument, we have POS
				// we don't free since the queue still points to the same addr
// Returns true if operation succeeded, false if it failed
3/15	8:00pm		1 hour		Now it sorts! Working on incorporating pos,len,


					return 1;
#include <stdio.h>
				}
				DIE("removeQ failed");
						return 1;
// function to swap two queues (i.e. swap the pointers to the two nodes)

    // if there's more than one node

						DIE("removeQ failed");
	}
    if(isEmptyQ(q)){
			if(!addQ(&q1, stringToAdd)){
		while(bigLeftToMerge1 > 0 && bigLeftToMerge2 > 0){
				// add each line in q1
			}
						DIE("removeQ failed");
		free(stringToAdd);
				printf("left to merges: %d %d\n", leftToMerge1, leftToMerge2);
		}
					leftToMerge2--;
    }
			len = INT_MAX;
			DIE("removeQ failed");
	int leftToMerge1 = 1, leftToMerge2 = 1;

		if(inFile == NULL){
				printf("left to merges: %d %d\n", leftToMerge1, leftToMerge2);
		firstFileArg = 2;
    Node *newNode = malloc(sizeof(Node));
					qSize1--;

		}
		qSize2 = tmp;
	}
				bigLeftToMerge1--;
			}
	call got NULL, and I had to worry about whether the next file existed, or
	}
			while(leftToMerge1 > 0){
    Queue temp = NULL;
					bigLeftToMerge2--;

	// now we can finally start mergesorting!
// memory associated with it
void swap(int *arg1, int *arg2);
// Returns true if operation succeeded, false if it failed

				printf("two heads are %s %s\n", head1, head2);
		// now check if LEN is specified, and if it isn't, set it to INT_MAX
/*Progress report: sorts, but doesn't handle it when there's leftover between merges (i.e. when one bigleft is nonzero but the other is zero)
			bigLeftToMerge2 = tmp;
					if(!removeQ(&q1, &stringToAdd)){

	}
			bigLeftToMerge1--;

		}
		offset2 = min(pos, strlen(head2));
    else{

	return 0;
		}
			// this is swapping the queue that we put successive sub-merges 
								merging incorrectly
				qSize2--;
 				
			leftToMerge1 = leftToMerge2 = sizeToMerge;
				return 1;
	// free(argumentString);
		printf("size to merge bottom: %d\n", sizeToMerge);
					qPos1++;
			DIE("removeQ failed");
			DIE("file open failed");
			leftToMerge1 = leftToMerge2 = sizeToMerge;
		if(strncmp(head1 + offset1, head2 + offset2, len) < 0){
			swap(&q1, &q2);
		// compare the two values, remove from whichever one is smaller
		}
				qSize1++;
				DIE("addQ failed!");

				// we don't free since the queue still points to the same addr

			qSize2 = tmp;
				numElements += 2;
						return 1;
		pos = strtol(argv[1] + 1, &line, 10);
			bigLeftToMerge1 = bigLeftToMerge2;
				if(!addQ(&q1, line1)){
				if(!removeQ(&q2, &stringToAdd)){
					if(!removeQ(&q2, &stringToAdd)){
				return 1;
					}
				return 1;
	// now we can finally start mergesorting!
		while(bigLeftToMerge1 > 0 && bigLeftToMerge2 > 0){
						return 1;
			}
	}
			while(leftToMerge1 > 0){
				// call headQ and store values into head1 and head2

		leftToMerge1 = leftToMerge2 = sizeToMerge;
			}
				}
				}
		else{
	}
			// open the file and loop through the lines
					bigLeftToMerge1--;
	// one
				int tmp = qSize1;
					DIE("addQ failed");
	// otherwise there's stuff left over from the second queue
								merging
#include "/c/cs223/Hwk3/getLine.h"
			while(leftToMerge1 > 0){
    Queue temp = NULL;
			return 1;
			DIE("File could not be opened!");
        (*newNode).next = (**q).next;
	}
					DIE("removeQ failed");
		printf("%s", stringToAdd);
					DIE("removeQ failed");
				}
				if(!addQ(&q1, stringToAdd)){
		// if LEN is not specified, the character after POS should be null
				qSize2--;
				// compare the two values, remove from whichever one is smaller
		printf("%s\n", stringToAdd);
				// first, which is the one that q1 originally pointed to
				if(!addQ(&q1, stringToAdd)){
					if(!removeQ(&q2, &stringToAdd)){

	}
#include "/c/cs223/Hwk4/Queue.h"

			if(!removeQ(&q2, &stringToAdd)){
			}
				}
{
			qSize2--;
Date	Start		Time		Notes
			return 1;
	// we don't have to merge the last time -- just print out
					return 1;
					}

#include <limits.h>
	while(2 * sizeToMerge < numElements){
				}
			// otherwise there's stuff left over from the second queue
		printf("%s", stringToAdd);
				DIE("removeQ failed");
					}
				bigLeftToMerge2--;
				return 1;
	while(!isEmptyQ(&q1) && !isEmptyQ(&q2)){
		DIE("createQ() failed!");
	FILE *inFile;
					bigLeftToMerge2--;
			len = strtol(line + 1, &line, 10);
		}
3/3		1:30pm		1 hour		Started work on Queue.c, have first version of
			if(!removeQ(&q1, &stringToAdd)){
	// make sure there's at least one argument after Merge16
				leftToMerge2--;
					return 1;
	}
				DIE("addQ failed");
// function to swap two queues (i.e. swap the pointers to the two nodes)
	// argumentString = strcat(argumentString, argv[1]);

				// we don't free since the queue still points to the same addr
			// if there's stuff left over from the first queue
		fullCommand = malloc(fullLength);

	// the same time
		}
int createQ (Queue *q)
		// make sure POS is positive digits

}
#define DIE(msg) exit(fprintf(stderr, "%s\n", msg))
		// if we've reached the end of the arguments, return NULL
	}
						DIE("removeQ failed");
	// if getLine doesn't fail, return its result
		inFile = fopen(argv[i], "r");
					leftToMerge1--;
		pos = strtol(argv[1] + 1, &line, 10);
	if(argc == 1){
*/
				if(!addQ(&q1, line)){
			}
		system(fullCommand);
				DIE("addQ failed");
		}
3/3		7:00pm		1 hour		Main function can read files and add lines to a 
				bigLeftToMerge2--;
			while(leftToMerge1 > 0){
		qSize1 = qSize2;

			return 1;
			}
#include <stdio.h>
		if(inFile == NULL){
	while(2 * sizeToMerge < numElements){


	int firstFileArg = 1, sizeToMerge = 1, numElements = 0;
		printf("%s", stringToAdd);
	}
	while(2 * sizeToMerge < numElements){
				DIE("removeQ failed");
				}
	while(!isEmptyQ(&q1)){
// offset the bottom one by one. Then keep comparing heads until
	}
// Function that takes in a pointer to a queue (q) and a pointer to a string s
				// call headQ and store values into head1 and head2
				DIE("removeQ failed");
				// add each line in q1
		// now check if there's a comma next
			len = INT_MAX;
// removes the first node from the queue, and makes s point to the value that
		offset2 = min(pos, strlen(head2));
						return 1;
	}
			// otherwise there's stuff left over from the second queue
		}
	if(argv[1][0] == '-'){
					DIE("addQ() failed!");
3/15	9:00pm		1 hour		Sorts fine, mostly stable, seems to work with PO								S,LEN
    }
			if(!addQ(&q1, stringToAdd)){
				return 1;
	// we don't have to merge the last time -- just print out
					DIE("addQ failed");
	// now we can finally start mergesorting!
		}
	Queue q1 = NULL, q2 = NULL;
		free(stringToAdd);
	bigLeftToMerge2 = qSize2;
			if(!removeQ(&q1, &stringToAdd)){
			DIE("removeQ failed");
/*Progress report: sorts, but doesn't handle it when there's leftover between merges (i.e. when one bigleft is nonzero but the other is zero)
				qSize1 += 2;
		}
v
			int tmp = qSize1;
			if(!removeQ(&q1, &stringToAdd)){
		// remove the newline (set the newline character to the null character)
			}
}
3/9		8:45pm		1 hour		Mostly fixed the mergesort algorithm, but it
	// otherwise do the same with q2
	FILE *inFile;
// between consecutive merges
			len = INT_MAX;
	int firstFileArg = 1, sizeToMerge = 1, numElements = 0;
		}

				qSize1 = qSize2;
								merging incorrectly
		if(strcmp(head1, head2) < 0){
		}
						DIE("removeQ failed");
				swap(&q1, &q2);
			bigLeftToMerge1--;
i
						DIE("removeQ failed");
		while(bigLeftToMerge1 > 0 && bigLeftToMerge2 > 0){
				// between the two queues
	Queue dummy = *q1;
				return 1;
				DIE("removeQ failed");
					return 1;
						return 1;
			reversed = !reversed;
			}
    else{
			bigLeftToMerge1--;
				printf("size we're merging: %d\n", sizeToMerge);
				if(strcmp(head1, head2) < 0){
		qSize1 = qSize2;
				// call headQ and store values into head1 and head2

				// switch up the queues so that you split up the strings
        (*newNode).next = newNode;
		// now check if LEN is specified, and if it isn't, set it to INT_MAX
					DIE("addQ failed");
		free(stringToAdd);
	call got NULL, and I had to worry about whether the next file existed, or
	// are the indices in the merge that we've been through
	}
	if(!createQ(&q1) || !createQ(&q2)){

3/3		1:30pm		1 hour		Started work on Queue.c, have first version of
	int qSize1 = 0, qSize2 = 0, bigLeftToMerge2, bigLeftToMerge1;
				printf("bigLeftToMerges: %d %d\n", bigLeftToMerge1, bigLeftToMerge2);

	// otherwise there's stuff left over from the second queue
			}
			}
						DIE("removeQ failed");
						return 1;
				}
	}
			len = INT_MAX;
		// if we have a tie, remove from the queue that has priority
		}
					return 1;
			// if there's stuff left over from the first queue
				if(!removeQ(&q1, &stringToAdd)){
				}
// Returns true if operation succeeded, false if it failed
				else{
				}

			DIE("removeQ failed");
				if(!removeQ(&q2, &stringToAdd)){
int min(int arg1, int arg2);
			len = INT_MAX;
			DIE("removeQ failed");
					if(!removeQ(&q1, &stringToAdd)){

				return 1;
			while(leftToMerge1 > 0){
			DIE("File could not be opened!");
				if(!headQ(&q1, &head1) || !headQ(&q2, &head2)){
		sizeToMerge *= 2;
			// open the file and loop through the lines
				// call headQ and store values into head1 and head2
								merging incorrectly
}
		}
				DIE("removeQ failed");
					DIE("headQ failed");
				if(!removeQ(&q2, &stringToAdd)){
				}
		}
		qSize2 = tmp;
		}
		qSize2 = tmp;
		// compare the two values, remove from whichever one is smaller
				bigLeftToMerge1--;

int main(int argc, char *argv[]){
					return 1;
					DIE("addQ failed");

    while(!isEmptyQ(q)){
		else{

		// keep looping through
			bigLeftToMerge1 = bigLeftToMerge2;
// file is empty, opens the next file and returns the next line it can find.
	}
	Queue q1 = NULL, q2 = NULL;

		else{
    return true;
{
					return 1;
// prototyping some helper functions (descriptions at the function definition)
			qSize2--;
int main(int argc, char *argv[]){
			qSize1++;
					DIE("addQ failed");
int destroyQ (Queue *q)
	return 0;
{
		}
				if(!addQ(&q1, stringToAdd)){
// Queue.c by Dennis Duan
				qSize1++;
3/3		1:30pm		1 hour		Started work on Queue.c, have first version of
	// now we can finally start mergesorting!
		int tmp = qSize1;
				// switch up the queues so that you split up the strings
			}
	if(!createQ(&q1) || !createQ(&q2)){
			}
	*q1 = *q2;
		// we want to start comparing line1 from the lesser of POS or the size
    }
	bigLeftToMerge2 = qSize2;
					qSize2--;
				bigLeftToMerge2--;
				int tmp = qSize1;
	}
		// make sure POS is positive digits
		// now check if LEN is specified, and if it isn't, set it to INT_MAX
		qSize2 = tmp;
// offset the bottom one by one. Then keep comparing heads until
			qSize2--;
			if(!removeQ(&q2, &stringToAdd)){
/*Progress report: sorts, but doesn't handle it when there's leftover between merges (i.e. when one bigleft is nonzero but the other is zero)
				qSize1++;
			len = strtol(line + 1, &line, 10);
								not stable

			if(!removeQ(&q1, &stringToAdd)){
    }
		firstFileArg = 2;
			}
				return 1;
				DIE("removeQ failed");
		swap(&q1, &q2);
				DIE("removeQ failed");
					qSize1--;
			while(leftToMerge1 > 0){
			}
		free(stringToAdd);
		else{
				if(!addQ(&q1, line)){
				// call headQ and store values into head1 and head2

		fullCommand = memset(fullCommand, 0, fullLength);
// The struct contains a string (value) for the contents of a node and a pointer
			// if there's stuff left over from the first queue
	// if we've had an odd number of swaps, swap again to keep q1 as priority
					}
					if(!removeQ(&q2, &stringToAdd)){
					}
	if(!createQ(&q1) || !createQ(&q2)){
				if(!removeQ(&q1, &stringToAdd)){
					DIE("addQ() failed!");
				// add each line in q1
		// call headQ and store values into head1 and head2
		free(stringToAdd);
	}
			if(!removeQ(&q2, &stringToAdd)){
					DIE("headQ failed");
        return false;
					DIE("addQ failed");
		}
// removes the first node from the queue, and makes s point to the value that
	}
			}
				int tmp = qSize1;
		firstFileArg = 2;

 				
				}
			len = INT_MAX;
					DIE("headQ failed");

	long pos, len;
			if(!removeQ(&q1, &stringToAdd)){
			// if there's stuff left over from the first queue
				bigLeftToMerge2--;
			while(leftToMerge1 > 0){
						return 1;

int main(int argc, char *argv[]){
}// hold two copies of the list in the beginning and 
				qSize2--;

				else{
		leftToMerge1 = leftToMerge2 = sizeToMerge;
// should take at most N*log2(N) adds.
				}
				qSize1++;
		swap(&q1, &q2);
				}
	// otherwise there's stuff left over from the second queue
	// }
#include <limits.h>

				DIE("addQ failed");
		printf("%s", stringToAdd);
					qSize1--;
 				
					qSize2--;
		while(bigLeftToMerge1 > 0 && bigLeftToMerge2 > 0){
#define DIE(msg) exit(fprintf(stderr, "%s\n", msg))
			while(leftToMerge1 > 0){
					return 1;
					if(!removeQ(&q2, &stringToAdd)){
			DIE("removeQ failed");
			len = strtol(line + 1, &line, 10);
			return 1;
								are reversed, plus one to keep track of when

    }

	// q1 will always have the same or one more element than q2
		leftToMerge1 = leftToMerge2 = sizeToMerge;
						DIE("removeQ failed");
	// fileArg is the index of argv where files start, sizeToMerge is the
 				
					leftToMerge2--;
			return 1;
				qSize2--;

		}
}
	while(!isEmptyQ(&q1) && !isEmptyQ(&q2)){
			DIE("File could not be opened!");
	// if getLine fails then we go on to the next file
		if(!headQ(&q1, &head1) || !headQ(&q2, &head2)){
			bigLeftToMerge2 = tmp;
				}
		}
			if(!removeQ(&q2, &stringToAdd)){
					DIE("addQ failed");
		// empty
			}
void swap(Queue *arg1, Queue *arg2);
}
		// subqueues
#include <stdbool.h>
 				
				}
					leftToMerge1--;
					bigLeftToMerge2--;
#include <stdbool.h>
				printf("size we're merging: %d\n", sizeToMerge);
						printf("q1 is empty\n");
					if(!removeQ(&q2, &stringToAdd)){
3/15	8:00pm		1 hour		Now it sorts! Working on incorporating pos,len,

					return 1;
				}
		// now check if LEN is specified, and if it isn't, set it to INT_MAX
		}
		qSize1 = qSize2;
			qSize2--;
				// add each line in q1
				DIE("removeQ failed");
	*q1 = *q2;
*/
					qSize2--;
#include <stdbool.h>
		}
					qSize1--;
			// merge or the end of a queue
					leftToMerge2--;
	for(int i = firstFileArg; i < argc; i++){
		while(bigLeftToMerge1 > 0){
				}
				else{
			}

				bigLeftToMerge2--;
// function to swap two queues. Takes pointers to two queues (q1 and q2) and 
	while(!isEmptyQ(&q1)){
// should take at most N*log2(N) adds.

		// if we have a tie, remove from the queue that has priority
				}

		pos = strtol(argv[1] + 1, &line, 10);
	if(argc == 1){
						return 1;

		bigLeftToMerge2 = qSize2;
			len = strtol(line + 1, &line, 10);
			len = INT_MAX;
				}
				// compare the two values, remove from whichever one is smaller
	char *line, *head1, *head2, *stringToAdd;
				}
		while(bigLeftToMerge1 > 0){
		}
	int qSize1 = 0, qSize2 = 0, bigLeftToMerge2, bigLeftToMerge1;
				printf("left to merges: %d %d\n", leftToMerge1, leftToMerge2);
			DIE("removeQ failed");
}
			qSize2 = tmp;
			bigLeftToMerge2 = tmp;
				else{

    (*newNode).value = s;
    *s = (*nodeToRemove).value;
		else{
		if(!removeQ(&q1, &stringToAdd)){
	while(!isEmptyQ(&q1)){
	long pos, len;
		while(bigLeftToMerge1 > 0 && bigLeftToMerge2 > 0){
#include <limits.h>
			if(!addQ(&q1, stringToAdd)){
				// update the size each time, again incrementing by two



// you finish the first merging, alternating which queue you push to

								not stable
		if(!headQ(&q1, &head1) || !headQ(&q2, &head2)){
			fullCommand = strcat(fullCommand, argv[i]);
}
				DIE("removeQ failed");
	// we'll always add to q1, then swap each time
		bigLeftToMerge2 = qSize2;
				return 1;
				if(!addQ(&q1, stringToAdd)){
		}
				if(!addQ(&q1, stringToAdd)){
		qSize2 = tmp;

		inFile = fopen(argv[i], "r");

    return true;
					DIE("addQ failed!");
				return 1;
		}
	}
		else{

	}
    struct node *next;
					qSize2--;
		}
					return 1;
			len = INT_MAX;
		return 1;
				}
					DIE("removeQ failed");
		}
	// otherwise do the same with q2
				if(strcmp(head1, head2) < 0){
		swap(&q1, &q2);
						return 1;
				if(!headQ(&q1, &head1) || !headQ(&q2, &head2)){
	}
#include "/c/cs223/Hwk4/Queue.h"
				}
			tmp = bigLeftToMerge1;
			// otherwise there's stuff left over from the second queue
				bigLeftToMerge2--;
						DIE("removeQ failed");
		}
		qSize2 = tmp;
			if(!removeQ(&q1, &stringToAdd)){
		if(!removeQ(&q1, &stringToAdd)){
		free(stringToAdd);
				qSize1 = qSize2;
			qSize1 = qSize2;
// offset the bottom one by one. Then keep comparing heads until
	}
#include <limits.h>
				swap(&q1, &q2);
						return 1;

			DIE("removeQ failed");
People I consulted with: Jared Weinstein, Annie Chen, Will Merrill
				DIE("removeQ failed");


		qSize1 = qSize2;
				}
				if(!headQ(&q1, &head1) || !headQ(&q2, &head2)){
				return 1;
				qSize1++;
			}
		swap(&q1, &q2);
				else{
				DIE("addQ failed");
	char *line1;
    // if the queue is empty, it has no head, so it fails
				bigLeftToMerge1--;
	Queue q1 = NULL, q2 = NULL;
// offset the bottom one by one. Then keep comparing heads until
					DIE("addQ failed");
		bigLeftToMerge2 = qSize2;
				}
		// call headQ and store values into head1 and head2
				// switch up the queues so that you split up the strings
// and false otherwise
	to call getLine() twice per loop and then running a lot of cases on which
			if(!removeQ(&q1, &stringToAdd)){
					if(!removeQ(&q2, &stringToAdd)){
					qSize1--;
			while(leftToMerge1 > 0 && leftToMerge2 > 0){
				// we don't free since the queue still points to the same addr

			DIE("File could not be opened!");
			bigLeftToMerge2--;
			DIE("removeQ failed");
	for(int i = firstFileArg; i < argc; i++){
				return 1;
					DIE("headQ failed");
					return 1;
		}
// reading. this function returns the next line in the current file, or if the 
#include "/c/cs223/Hwk4/Queue.h"
			while(leftToMerge1 > 0){
			}
		printf("%s", stringToAdd);
			qSize1 = qSize2;
			qSize2--;
		free(stringToAdd);
		fullCommand = malloc(fullLength);
	int qSize1 = 0, qSize2 = 0, bigLeftToMerge2, bigLeftToMerge1;
	// we don't have to merge the last time -- just print out
		}
					DIE("addQ() failed!");

Date	Start		Time		Notes
				if(!removeQ(&q1, &stringToAdd)){
	*q2 = dummy;
void swap(Queue *arg1, Queue *arg2);
	if(!createQ(&q1) || !createQ(&q2)){
		leftToMerge1 = leftToMerge2 = sizeToMerge;
				// call headQ and store values into head1 and head2
				qSize1 = qSize2;

				qSize1++;
			qSize2--;
			while(leftToMerge2 > 0){
		if(!removeQ(&q2, &stringToAdd)){
				leftToMerge1--;
			if(!removeQ(&q1, &stringToAdd)){
	// q1 will always have the same or one more element than q2
					DIE("addQ() failed!");
		// now check if LEN is specified, and if it isn't, set it to INT_MAX
	bigLeftToMerge2 = qSize2;
					}
	// if there's stuff left over from the first queue
	}
 				
	if(argc == 1){
				}
		}
void swap(Queue *arg1, Queue *arg2);
			}
#include <stdlib.h>
			// otherwise there's stuff left over from the second queue
			return 1;
// (next) to the next node in the linked list
		qSize1 = qSize2;
		}
					DIE("removeQ failed");
		if(inFile == NULL){
		// if we have excess on the first queue...the other queue should be
								queue
			}
		int tmp = qSize1;
			if(!removeQ(&q2, &stringToAdd)){
*/
// offset the bottom one by one. Then keep comparing heads until
	// now we print out the things in the queues, doing the last merge at
	*q2 = dummy;
	fclose(inFile);
		while(bigLeftToMerge2 > 0){

			while((line = getLine(inFile)) != NULL){
		printf("biglefts: %d %d\n", bigLeftToMerge1, bigLeftToMerge2);

			}
    // if the queue is empty, it has no head, so it fails
		}
	while(!isEmptyQ(&q1)){
    // if there's no node to remove, return false

						return 1;

			}
// The internal representation of a Queue is a headless, singly-linked,
// you finish the first merging, alternating which queue you push to
		// compare the two values, remove from whichever one is smaller
					leftToMerge2--;
		}
	}
	}
				DIE("removeQ failed");
    // if the queue is empty, it has no head, so it fails

	// we'll always add to q1, then swap each time
			qSize1 = qSize2;
				}
int main(int argc, char *argv[]){

	// the same time

		sizeToMerge *= 2;
ESTIMATE of total time I will spend: 16 hours
		fullLength = strlen(echo) + strlen(stdInput) + strlen(subst16Command) + argLength + 1;
					bigLeftToMerge1--;
// function to swap two queues (i.e. swap the pointers to the two nodes)
    // if there's more than one node
			while((line = getLine(inFile)) != NULL){
		// if we have a tie, remove from the queue that q1 originally pointed 
		}
		// otherwise, DIE
		}
					return 1;
		}
			}
			return 1;
					bigLeftToMerge1--;
		// compare the two values, remove from whichever one is smaller
#include <limits.h>
			len = strtol(line + 1, &line, 10);
	if(qSize2 > qSize1){
People I consulted with: Jared Weinstein, Annie Chen, Will Merrill
	}
	// for(int i = 2; i < argc; i++){
					DIE("headQ failed");
    Node *nodeToRemove = (**q).next;
	int qSize1 = 0, qSize2 = 0, startSize1, startSize2, qPos1, qPos2;
		qSize2 = tmp;
					qSize1--;
				// add each line in q1
				// call headQ and store values into head1 and head2
		free(stringToAdd);
					return 1;
	// make sure there's at least one argument after Merge16
		else if(strncmp(head1 + offset1, head2 + offset2, len) > 0){
			if(!removeQ(&q1, &stringToAdd)){

#include <limits.h>


#include <stdlib.h>
		qSize2 = tmp;
        *q = NULL;

					DIE("removeQ failed");

void swap(Queue *q1, Queue *q2){
				DIE("removeQ failed");

		qSize2 = tmp;
					DIE("headQ failed");
			//free(line);
	// now we can finally start mergesorting!
		else if(strcmp(head1, head2) > 0){
								doesn't work for big files
	for(int i = firstFileArg; i < argc; i++){
						DIE("removeQ failed");
								most functions								
#include "/c/cs223/Hwk3/getLine.h"

			if(strncmp(line1 + offset1, line2 + offset2, len) <= 0){
				printf("two heads are %s %s\n", head1, head2);
			qSize2--;
		}
		// while at least one of the queues has some un-merged elements, we 
						return 1;
			return 1;
		bigLeftToMerge1 = qSize1;
			leftToMerge1 = leftToMerge2 = sizeToMerge;

		}
				// now add the string to whichever queue we're currently adding to 
			if(!removeQ(&q2, &stringToAdd)){
				DIE("removeQ failed");
	}
		}
		if(!removeQ(&q2, &stringToAdd)){
		printf("%s", stringToAdd);

#include <stdlib.h>
	while(!isEmptyQ(&q2)){
	}
			if(!removeQ(&q1, &stringToAdd)){
	*q2 = dummy;
		stdInput = memset(stdInput, 0, strlen(line));

				leftToMerge2--;
					DIE("addQ failed");
					leftToMerge1--;
		// call headQ and store values into head1 and head2


				leftToMerge1--;

	}
		inFile = fopen(argv[i], "r");
			int tmp = qSize1;
		int tmp = qSize1;
// function to swap two queues (i.e. swap the pointers to the two nodes)
					}
	}
	int qSize1 = 0, qSize2 = 0, bigLeftToMerge2, bigLeftToMerge1;
}
/*Progress report: sorts, but doesn't handle it when there's leftover between merges (i.e. when one bigleft is nonzero but the other is zero)
		printf("%s", stringToAdd);
					}
		// if we have excess on the first queue...the other queue should be
		// if fopen throws an error
			if(!removeQ(&q2, &stringToAdd)){
				printf("two heads are %s %s\n", head1, head2);
			DIE("removeQ failed");
				printf("bigLeftToMerges: %d %d\n", bigLeftToMerge1, bigLeftToMerge2);
				return 1;
		free(stringToAdd);
		if(line[0] == ','){
// between consecutive merges
	}
#include <stdlib.h>
	}
				if(!addQ(&q1, stringToAdd)){
					return 1;
				qSize2--;
	while(2 * sizeToMerge < numElements){
	// now loop through the rest of the args and read them as files
				// between the two queues

        if(!removeQ(q, &dummyS)){
					}
				DIE("removeQ failed");

	if(argv[1][0] == '-'){
				if(!removeQ(&q2, &stringToAdd)){
	*q1 = *q2;
			}
				}
	Eventually I realized (with the help of Will) that I could read in the lines
		qSize1 = qSize2;
		// call headQ and store values into head1 and head2
				// now add the string to whichever queue we're currently adding to 
				}
			}
// the list (or NULL if the queue is empty).
								doesn't work for big files
// offset the bottom one by one. Then keep comparing heads until
				qSize1 = qSize2;
				}
			}
					bigLeftToMerge2--;
					DIE("headQ failed");
					bigLeftToMerge2--;
	}
				if(!removeQ(&q2, &stringToAdd)){
				leftToMerge2--;

	int leftToMerge1 = 1, leftToMerge2 = 1;
				printf("size we're merging: %d\n", sizeToMerge);
		bigLeftToMerge2 = qSize2;
	// if there's no files
	*q1 = *q2;
		inFile = fopen(argv[i], "r");
			DIE("File could not be opened!");
		// double each merge size so that we can merge adjacent sorted 
	// q1 will always have the same or one more element than q2
				int tmp = qSize1;
				if(!removeQ(&q1, &stringToAdd)){
			DIE("removeQ failed");

		// if there is no next line, then we just add the first line to q1
				int tmp = qSize1;
		if(line[0] == ','){
	// q1 will always have the same or one more element than q2

		swap(&q1, &q2);
								doesn't work...also seg faults in isEmptyQ
				else{


		// now we've finished the merging -- now some housekeeping
					}
	// the same time
					}
			len = strtol(line + 1, &line, 10);

		// if we have excess on the first queue...the other queue should be
	// now we print out the things in the queues, doing the last merge at
				leftToMerge1--;
		printf("%s", stringToAdd);
				printf("bigLeftToMerges: %d %d\n", bigLeftToMerge1, bigLeftToMerge2);
	// if there's stuff left over from the first queue
	while(!isEmptyQ(&q1) && !isEmptyQ(&q2)){
				return 1;
				}

	while(!isEmptyQ(&q2)){
			if(!removeQ(&q1, &stringToAdd)){
				}
			}
			return 1;
		}
					bigLeftToMerge2--;
		}
	// the same time
			DIE("removeQ failed");

	long pos, len;
		DIE("createQ() failed!");
		if(!removeQ(&q2, &stringToAdd)){
					}
		int tmp = qSize1;
	for(int i = 1; i < argc; i++){
	}
c
	return 0;
	// if we've had an odd number of swaps, swap again to keep q1 as priority
					return 1;
	while(!isEmptyQ(&q1)){
			while(leftToMerge1 > 0 && leftToMerge2 > 0){
	// now we can finally start mergesorting!
				printf("left to merges: %d %d\n", leftToMerge1, leftToMerge2);
    // if there's more than one node
				// switch up the queues so that you split up the strings
    else{
	// otherwise there's stuff left over from the second queue
		printf("%s\n", stringToAdd);
		pos = strtol(argv[1] + 1, &line, 10);
					qSize1--;
        (**q).next = newNode;
					qSize1--;
			DIE("removeQ failed");
	while(!isEmptyQ(&q2)){
	long pos, len;
				printf("bigLeftToMerges: %d %d\n", bigLeftToMerge1, bigLeftToMerge2);
	// we don't have to merge the last time -- just print out
				}
				// compare the two values, remove from whichever one is smaller
 				
				// between the two queues
	Queue q1 = NULL, q2 = NULL;
	while(!isEmptyQ(&q1)){
			qSize2--;
	*q1 = *q2;
				qSize1++;
								doesn't work for big files
	// the same time
					bigLeftToMerge2--;
					bigLeftToMerge2--;
				qSize1++;
#include <stdio.h>
	if(argc == 1){
				}
					leftToMerge1--;
		}
						return 1;

	// otherwise there's stuff left over from the second queue
				return 1;
				swap(&q1, &q2);
				qSize2 = tmp;
		if(line[0] == ','){
	// now loop through the rest of the args and read them as files

	various while loops, so it took me three or four tries of redoing my code
    }
} Node;
				// call headQ and store values into head1 and head2
	if(qSize2 > qSize1){
						printf("q1 is empty\n");
			}
					leftToMerge1--;
    if(s == NULL){
			if(!addQ(&q1, stringToAdd)){
	return 0;
	}
					DIE("addQ failed");
	FILE *inFile;

// makes them point to the other address
	// q1 will always have the same or one more element than q2
				DIE("addQ failed");
	// if we have a hyphen on the first argument, we have POS
			bigLeftToMerge2 = tmp;
3/8		3:00pm		1 hour		Finished implementing all of mergesort but it
				DIE("addQ failed");
				if(!removeQ(&q2, &stringToAdd)){
	bigLeftToMerge1 = qSize1;
2/29	4:00pm		1 hour		Discussed problem statement with Jared Weinstein
	FILE *inFile;
				bigLeftToMerge2--;
		}
Difficulties I ran into:
	// now loop through the rest of the args and read them as files
					if(!removeQ(&q1, &stringToAdd)){
			tmp = bigLeftToMerge1;
	// if we have a hyphen on the first argument, we have POS
			if(!addQ(&q1, stringToAdd)){

			return 1;

			len = INT_MAX;
3/8		3:00pm		1 hour		Finished implementing all of mergesort but it
				if(!addQ(&q1, stringToAdd)){
		qSize2 = tmp;
			}

			while((line = getLine(inFile)) != NULL){
								merging
				DIE("removeQ failed");
		}
	while(!isEmptyQ(&q2)){
			}
				int tmp = qSize1;
	*q1 = *q2;

			// if there's anything trailing at the end, DIE
	}
					leftToMerge1--;
				// add each line in q1

		if(!removeQ(&q2, &stringToAdd)){
		else if(strcmp(head1, head2) > 0){
				qSize1++;
					leftToMerge1--;

#include "/c/cs223/Hwk3/getLine.h"
		else{
						return 1;
		else if(strcmp(head1, head2) > 0){
*/
	int qSize1 = 0, qSize2 = 0, bigLeftToMerge2, bigLeftToMerge1;
				DIE("removeQ failed");
		else if(strcmp(head1, head2) > 0){
	to get a working version
			tmp = bigLeftToMerge1;


	return 0;



		}
				if(!removeQ(&q2, &stringToAdd)){
		inFile = fopen(argv[i], "r");
// Function that takes in a pointer to a Queue (q) and a string (s), then adds a
				return 1;
		}

			DIE("removeQ failed");
// removes the first node from the queue, and makes s point to the value that
	}
char *newGetLine(char *arg1[], int arg2, FILE **arg3, int *arg4);
	int leftToMerge1 = 1, leftToMerge2 = 1;
			len = INT_MAX;
			while(leftToMerge1 > 0 && leftToMerge2 > 0){
		free(stringToAdd);
		bigLeftToMerge1 = qSize1;
				// we don't free since the queue still points to the same addr
			}
				qSize1++;

// function to swap two queues (i.e. swap the pointers to the two nodes)
				if(!addQ(&q1, stringToAdd)){
	while(2 * sizeToMerge < numElements){
			DIE("Invalid POS,LEN");
					}
	if(qSize2 > qSize1){

								very far

	if(argv[1][0] == '-'){
#include <stdbool.h>
	// if there's stuff left over from the first queue
		}
    // by pointing it to the first node and making the previous node point to it
						return 1;
				DIE("addQ failed");
// The struct contains a string (value) for the contents of a node and a pointer
				// start comparing either at POS or the end of the string,
			// if there's anything trailing at the end, DIE
		}
		}
				// compare the two values (starting from the offset we defined)
		}
	while(!isEmptyQ(&q1)){
				if(qPos1 == startSize1 || qPos2 == startSize2){
			if(!addQ(&q1, stringToAdd)){
					leftToMerge1--;
		free(stringToAdd);
			while((line = getLine(inFile)) != NULL){
		free(stringToAdd);
		// now we've finished the merging -- now some housekeeping
// memory associated with it
			}
				}
	int leftToMerge1 = 1, leftToMerge2 = 1;
				}
    // if s doesn't point to anything
// the node contains.
	}
				DIE("removeQ failed");
					leftToMerge2--;
				DIE("removeQ failed");
    // if there's no node to remove, return false
						DIE("removeQ failed");
				if(strcmp(head1, head2) < 0){

		while(bigLeftToMerge1 > 0){
	fclose(inFile);
		// now check if LEN is specified, and if it isn't, set it to INT_MAX
		}
		// order

// function to swap two queues (i.e. swap the pointers to the two nodes)
				printf("left to merges: %d %d\n", leftToMerge1, leftToMerge2);
		}
    if(isEmptyQ(q)){
				// we don't free since the queue still points to the same addr

*/
		DIE("createQ() failed!");
					DIE("removeQ failed");
		}
				// we don't free since the queue still points to the same addr
	char *line, *head1, *head2, *stringToAdd;
				}
			}
		free(stringToAdd);
		stdInput = strncpy(stdInput, line, strlen(line) - 1);
		}
			// open the file and loop through the lines
		if(!removeQ(&q2, &stringToAdd)){
	while(!isEmptyQ(&q1) && !isEmptyQ(&q2)){
				DIE("removeQ failed");
	to get a working version
		free(stringToAdd);
		leftToMerge1 = leftToMerge2 = sizeToMerge;
					return 1;
				qSize1++;
	}
			}
								doesn't work for big files
#include <stdlib.h>
					DIE("addQ failed");
				printf("two heads are %s %s\n", head1, head2);
			}
		if(strcmp(head1, head2) < 0){
			qSize1++;
	Once I had the algorithm, it was then difficult to get it under N Log(N)
				}
				// if we have a tie, remove from the queue that has priority
				printf("two heads are %s %s\n", head1, head2);
	to call getLine() twice per loop and then running a lot of cases on which
// offset the bottom one by one. Then keep comparing heads until
				if(!addQ(&q1, stringToAdd)){
		free(stringToAdd);

			if(!removeQ(&q2, &stringToAdd)){
	while(!isEmptyQ(&q1) && !isEmptyQ(&q2)){
		DIE("createQ() failed!");
						DIE("removeQ failed");
		}

			if(!removeQ(&q1, &stringToAdd)){
				if(!addQ(&q1, stringToAdd)){

		return 1;
				qSize1++;


		bigLeftToMerge1 = qSize1;
	// otherwise there's stuff left over from the second queue
		firstFileArg = 2;
        return false;
				if(!headQ(&q1, &head1) || !headQ(&q2, &head2)){
		}
				}
	if(qSize2 > qSize1){
					qSize1--;
					DIE("headQ failed");
		if(!removeQ(&q2, &stringToAdd)){
				// whichever one comes earlier
	}
			bigLeftToMerge1--;
	bigLeftToMerge2 = qSize2;

								most functions								
		else if(strcmp(head1, head2) > 0){
				// if we have a tie, remove from the queue that has priority
			while(leftToMerge2 > 0){
						DIE("removeQ failed");

	}
				DIE("removeQ failed");
	int firstFileArg = 1, sizeToMerge = 1, numElements = 0;
		}
#include <stdio.h>
			qSize1 = qSize2;
		if(!removeQ(&q1, &stringToAdd)){
#include "/c/cs223/Hwk4/Queue.h"
				}
			int tmp = qSize1;
			return 1;
// Function that takes in a pointer to a queue (q) and destroys it, freeing all
	FILE *inFile;
	// if there's stuff left over from q1, print the rest of q1 and free each
			}

			// otherwise there's stuff left over from the second queue
					return 1;
				numElements += 2;

				qSize1++;
	}
		// if there is no next line, then we just add the first line to q1
			return 1;
					DIE("addQ failed");
		int tmp = qSize1;
		qSize1 = qSize2;
			int tmp = qSize1;
			}
	destroyQ(&q2);
void swap(Queue *q1, Queue *q2){
					DIE("headQ failed");
			}
		// now check if LEN is specified, and if it isn't, set it to INT_MAX
					if(!removeQ(&q1, &stringToAdd)){
	int leftToMerge1 = 1, leftToMerge2 = 1;
	while(sizeToMerge * 2 < numElements){ 
			return 1;
	// argumentString = strcpy(argumentString, " ");
				bigLeftToMerge1--;
			if(!addQ(&q1, line1)){
		else{

				qSize1++;
// offset the bottom one by one. Then keep comparing heads until
					if(!removeQ(&q1, &stringToAdd)){
				}
		// now we've finished the merging -- now some housekeeping
					return 1;
				printf("two heads are %s %s\n", head1, head2);
					DIE("removeQ failed");

		DIE("createQ() failed!");

			len = INT_MAX;
			while((line = getLine(inFile)) != NULL){
				if(!addQ(&q1, stringToAdd)){
	// free(argumentString);
// prototyping some helper functions (descriptions at the function definition)
					return 1;
					qPos1++;
	*q1 = *q2;
	// free the memory from each queue
				bigLeftToMerge2--;
			DIE("File could not be opened!");
		if(!removeQ(&q2, &stringToAdd)){
				DIE("addQ failed");
		}
		inFile = fopen(argv[i], "r");
		else if(strcmp(head1, head2) > 0){
void swap(int *a, int *b){
				DIE("removeQ failed");
*/
		}

Date	Start		Time		Notes
				qSize1 = qSize2;
		// now check if LEN is specified, and if it isn't, set it to INT_MAX
			DIE("removeQ failed");

void swap(Queue *arg1, Queue *arg2);

					if(!removeQ(&q2, &stringToAdd)){
		// now check if LEN is specified, and if it isn't, set it to INT_MAX
					if(!removeQ(&q1, &stringToAdd)){
		// call headQ and store values into head1 and head2
			if(!addQ(&q1, stringToAdd)){

								most functions								
		printf("%s", stringToAdd);

					}
					}
		// call headQ and store values into head1 and head2
				swap(&q1, &q2);
			DIE("Invalid POS,LEN");
        }
 -- Reading in the files was initially a challenge, as I was initally planning

				qSize2--;
								are reversed, plus one to keep track of when

					return 1;
			while(leftToMerge1 > 0 && leftToMerge2 > 0){
	while(!isEmptyQ(&q2)){
				// we don't free since the queue still points to the same addr
								and	now I'm dealing with a lot of seg faults

				if(!addQ(&q1, stringToAdd)){
		}
		while(bigLeftToMerge1 > 0){
		int tmp = qSize1;
				if(!addQ(&q1, stringToAdd)){
3/10	9:30pm		.5 hours	Debugged, but now it infinite loops instead of
		// double each merge size so that we can merge adjacent sorted 
				bigLeftToMerge1--;
	// make sure there's at least one argument after Merge16
			return 1;
// function to swap two queues (i.e. swap the pointers to the two nodes)
	}
		}



					DIE("removeQ failed");
#include <string.h>
#include "/c/cs223/Hwk3/getLine.h"
			tmp = bigLeftToMerge1;

				DIE("Invalid POS,LEN");
// offset the bottom one by one. Then keep comparing heads until
					DIE("addQ failed");
				if(!addQ(&q1, line)){
 				
	if(!createQ(&q1) || !createQ(&q2)){
						return 1;
}
	// the same time
				qSize1++;

        return false;
	return b;
	}
			return 1;
					DIE("removeQ failed");
*/
		}
// hold two copies of the list in the beginning and 
			bigLeftToMerge1--;
			while((line = getLine(inFile)) != NULL){
			qSize2 = tmp;
	}
	if(!createQ(&q1) || !createQ(&q2)){
						DIE("removeQ failed");

				DIE("removeQ failed");
				int tmp = qSize1;
}
						printf("q1 is empty\n");
		}
	for(int i = firstFileArg; i < argc; i++){
			DIE("removeQ failed");

				leftToMerge2--;

		fullCommand = memset(fullCommand, 0, fullLength);
        *s = (**q).next->value;
		qSize1 = qSize2;
		}
					DIE("headQ failed");
		}

	if(!createQ(&q1) || !createQ(&q2)){
// Returns true if operation succeeded, false if it failed
#include "/c/cs223/Hwk3/getLine.h"
						return 1;
		printf("%s", stringToAdd);
	*q2 = dummy;
					if(!removeQ(&q1, &stringToAdd)){
			return 1;
	*q2 = dummy;
				qSize1++;
		fclose(*fileToRead);
	while(!isEmptyQ(&q1) && !isEmptyQ(&q2)){
		printf("%s", stringToAdd);
				// switch up the queues so that you split up the strings
// the list (or NULL if the queue is empty).
			if(!addQ(&q1, stringToAdd)){
				// if we have a tie, remove from the queue that has priority
				return 1;
		bigLeftToMerge2 = qSize2;
		qSize2 = tmp;
		swap(&q1, &q2);
// between consecutive merges
			}
	if(qSize2 > qSize1){
		printf("%s", stringToAdd);
		// if we have excess on the first queue...the other queue should be
	// 	argumentString = strcat(argumentString, argv[i]);
	// merge size (e.g. this )
		// if we have a tie, remove from the queue that has priority
					DIE("removeQ failed");
			bigLeftToMerge2 = tmp;

				if(!removeQ(&q2, &stringToAdd)){
		inFile = fopen(argv[i], "r");
					qPos1++;
				qSize1++;
				if(!addQ(&q1, line1)){
				if(!headQ(&q1, &head1) || !headQ(&q2, &head2)){
					DIE("headQ failed");
				// update the size each time, incremeting by two since we 
		}
					return 1;
		// now check if LEN is specified, and if it isn't, set it to INT_MAX
			}
				qSize2--;
	*q2 = dummy;
				qSize1++;
 				
		swap(&q1, &q2);
	Queue dummy = *q1;
		// empty
void swap(Queue *q1, Queue *q2){
	Queue dummy = *q1;

		while(bigLeftToMerge1 > 0){

				bigLeftToMerge1--;
			if(!addQ(&q1, stringToAdd)){
			len = INT_MAX;
}// Queue.c by Dennis Duan
		if(!removeQ(&q1, &stringToAdd)){
				printf("bigLeftToMerges: %d %d\n", bigLeftToMerge1, bigLeftToMerge2);
				printf("size we're merging: %d\n", sizeToMerge);
		else{
}
				// if we have a tie, remove from the queue that has priority

		printf("%s\n", stringToAdd);
// function to swap two queues (i.e. swap the pointers to the two nodes)
		inFile = fopen(argv[i], "r");
			}
		}
m
		while(qPos1 < startSize1 || qPos2 < startSize2){
		// empty

}// hold two copies of the list in the beginning and 
#include "/c/cs223/Hwk3/getLine.h"
				qSize2 = tmp;
3/21	4:30pm		.5 hours	Put more detailed comments in the code
					qSize1--;
			while((line = getLine(inFile)) != NULL){
				// if we have a tie, remove from the queue that has priority
	inFile = fopen(argv[fileArg], "r");
		printf("%s", stringToAdd);
					}
		else{
	*q1 = *q2;
				qSize1++;
				// call headQ and store values into head1 and head2

	// if we have a hyphen on the first argument, we have POS
					DIE("addQ() failed!");

	Queue q1 = NULL, q2 = NULL;
3/10	9:30pm		.5 hours	Debugged, but now it infinite loops instead of
#include "/c/cs223/Hwk3/getLine.h"
				if(!addQ(&q1, stringToAdd)){
			// if there's stuff left over from the first queue
				bigLeftToMerge2--;
				if(!removeQ(&q1, &stringToAdd)){

    // set the contents of the new node to be the string

		inFile = fopen(argv[i], "r");
	while(!isEmptyQ(&q1) && !isEmptyQ(&q2)){
				}
			if(!removeQ(&q1, &stringToAdd)){
	Queue q1 = NULL, q2 = NULL;
				DIE("removeQ failed");
			qSize2 = tmp;

}
			qSize2--;
					}


	// printf("%d\n", argLength);
		firstFileArg = 2;
			qSize1 = qSize2;
					leftToMerge1--;
				DIE("removeQ failed");
			//free(line);

								doesn't work for big files
    // if s doesn't point to anything
					bigLeftToMerge1--;
	while(2 * sizeToMerge < numElements){
			//free(line);
	bigLeftToMerge1 = qSize1;
			}
				}
			swap(&q1, &q2);
	if(inFile == NULL){
int main(int argc, char *argv[]){
				if(!addQ(&q1, line1)){

	int firstFileArg = 1, sizeToMerge = 1, numElements = 0;
					DIE("addQ failed");
								to stop merging

				}
3/15	8:00pm		1 hour		Now it sorts! Working on incorporating pos,len,
					return 1;
				}
				leftToMerge2--;
			return 1;
/*Progress report: sorts, but doesn't handle it when there's leftover between merges (i.e. when one bigleft is nonzero but the other is zero)
				// switch up the queues so that you split up the strings
}
		else{

					return 1;
				qSize1++;
	// otherwise there's stuff left over from the second queue
	bigLeftToMerge1 = qSize1;

					if(isEmptyQ(&q1)){
			while(leftToMerge1 > 0 && leftToMerge2 > 0){
				else{
		}
#include <stdio.h>
				printf("bigLeftToMerges: %d %d\n", bigLeftToMerge1, bigLeftToMerge2);

// Returns true if operation succeeded, false if it failed
#include <stdbool.h>
		sizeToMerge *= 2;
	// otherwise there's stuff left over from the second queue
	for(int i = 1; i < argc; i++){
					DIE("addQ failed");
					bigLeftToMerge2--;
			}
			return 1;


				// add two lines at a time
				}

	*q2 = dummy;
			if(strncmp(line1 + offset1, line2 + offset2, len) <= 0){
				printf("bigLeftToMerges: %d %d\n", bigLeftToMerge1, bigLeftToMerge2);
			bigLeftToMerge2 = tmp;
		qSize2 = tmp;
	while(2 * sizeToMerge < numElements){
				// add each line in q1
// the list (or NULL if the queue is empty).


				}
				}

				qSize1++;

				if(!addQ(&q1, line)){
			qSize1 = qSize2;
			}

			qSize1++;
    if((**q).next == *q){
	// if there's stuff left over from the first queue
	}
				qSize1++;
		while(bigLeftToMerge1 > 0){
		if(inFile == NULL){
				qSize2 = tmp;
		}
		free(stdInput);
		qSize2 = tmp;
				if(!addQ(&q1, line)){
						return 1;
	// if there's stuff left over from the first queue

			while(qPos2 < stopMergeIndex2){
			DIE("removeQ failed");
		}
		bigLeftToMerge1 = qSize1;
					bigLeftToMerge2--;
				else{
				bigLeftToMerge1--;
    (*newNode).value = s;
						return 1;
	int leftToMerge1 = 1, leftToMerge2 = 1;
					}
// whether queue is empty
					return 1;
		if(line[0] == ','){
{
	FILE *inFile;
		}
	return 0;
					leftToMerge1--;
			}
	// make sure there's at least one argument after Merge16
	// if we have a hyphen on the first argument, we have POS
					qSize1--;
	destroyQ(&q1);
// them point to the other address
int main(int argc, char *argv[]){
	}

3/21	4:30pm		.5 hours	Put more detailed comments in the code
	// make sure there's at least one argument after Merge16
				// between the two queues
				}
	}
				}
3/10	9:30pm		.5 hours	Debugged, but now it infinite loops instead of
	bigLeftToMerge1 = qSize1;
}
				// now add the string to whichever queue we're currently adding to 
	*q1 = *q2;
						return 1;
				if(strcmp(head1, head2) < 0){
			// want to start comparing

					DIE("addQ() failed!");
// offset the bottom one by one. Then keep comparing heads until
			qSize1 = qSize2;
					}
					qSize1--;
		else{
			DIE("removeQ failed");
			while(leftToMerge1 > 0){
					}
	while(2 * sizeToMerge < numElements){

		free(stringToAdd);
					DIE("removeQ failed");
		}
					DIE("addQ failed");
				}
				}
			DIE("File could not be opened!");
				return 1;
#include "/c/cs223/Hwk3/getLine.h"
					return 1;
						DIE("removeQ failed");
					bigLeftToMerge1--;
	while(!isEmptyQ(&q2)){
		else{
	return line1;
	}

int headQ (Queue *q, char **s)

				if(!headQ(&q1, &head1) || !headQ(&q2, &head2)){
		bigLeftToMerge2 = qSize2;

		// compare the two values, remove from whichever one is smaller
				DIE("addQ failed");
				}
					if(!removeQ(&q1, &stringToAdd)){
			if(!removeQ(&q1, &stringToAdd)){
				qSize2 = tmp;
			}
	int leftToMerge1 = 1, leftToMerge2 = 1;
	for(int i = firstFileArg; i < argc; i++){
				DIE("removeQ failed");
								to stop merging
				if(!addQ(&q1, stringToAdd)){
TOTAL time spent: 14.5 hours
				leftToMerge1--;
    return true;

					DIE("addQ failed");
		// otherwise, open the new file, update the file pointer and return the
			return 1;
					}
    return true;
				qPos1++;
			//free(line);
		}
	}
								very far
					return 1;
				// call headQ and store values into head1 and head2
		// now check if LEN is specified, and if it isn't, set it to INT_MAX
				qSize1++;
				else{

				}
					DIE("addQ failed!");
        *s = (**q).next->value;
// Function that takes in a pointer to a Queue q and a pointer to a string s,
				return 1;
				DIE("addQ failed");
}

	// argumentString = strcpy(argumentString, " ");


            return false;

				if(!addQ(&q1, stringToAdd)){
			}
					DIE("removeQ failed");
			return 1;
		swap(&q1, &q2);
		if(!removeQ(&q2, &stringToAdd)){
*/
			DIE("File could not be opened!");
								merging
	// this loop is the start of each "level" of merge -- so the new bigger
					DIE("addQ failed");
	*q2 = dummy;
#include <stdlib.h>
 -- Getting the algorithm for two-queue mergesort was difficult to begin with.
					qSize1--;
    while(!isEmptyQ(q)){

	while(!isEmptyQ(&q2)){
					}
				DIE("addQ failed");

					if(isEmptyQ(&q1)){
    }
	}
		printf("biglefts: %d %d\n", bigLeftToMerge1, bigLeftToMerge2);
				printf("bigLeftToMerges: %d %d\n", bigLeftToMerge1, bigLeftToMerge2);
				printf("left to merges: %d %d\n", leftToMerge1, leftToMerge2);
		}
	return 0;
					}
				numElements++;
				swap(&q1, &q2);
		printf("%s", stringToAdd);
					if(isEmptyQ(&q1)){
		qSize2 = tmp;
					DIE("addQ failed");
	}
					return 1;

			}
		}
		// call headQ and store values into head1 and head2
				else{
// Function that takes in a pointer to a Queue (q) and a string (s), then adds a
		qSize2 = tmp;
	// if we have a hyphen on the first argument, we have POS
	was empty, or had another line. Then I wrote a new getLine function which
			DIE("removeQ failed");

				}
}



			int tmp = qSize1;
				// if we have a tie, remove from the queue that has priority
*/
p
			return 1;
	Queue dummy = *q1;
	if(!createQ(&q1) || !createQ(&q2)){
// to fileIndex, which represents the index of argv of the file we're currently
		pos = strtol(argv[1] + 1, &line, 10);

	if(argv[1][0] == '-'){
		}
					if(!removeQ(&q1, &stringToAdd)){
				printf("left to merges: %d %d\n", leftToMerge1, leftToMerge2);

	// we don't have to merge the last time -- just print out
			if(!addQ(&q1, stringToAdd)){
			len = INT_MAX;
			while(leftToMerge2 > 0){

	*q1 = *q2;
	}
3/9		9:45pm 		1 hour		Identified a few bugs, trying to fix them

#include <stdio.h>
					if(!removeQ(&q2, &stringToAdd)){
	// the same time
		// empty
			return 1;
	while(!isEmptyQ(&q1) && !isEmptyQ(&q2)){
				numElements++;
    Node *newNode = malloc(sizeof(Node));
	// make sure there's at least one argument after Merge16
					DIE("addQ() failed!");

				else if(strcmp(head1, head2) > 0){
					bigLeftToMerge2--;
	}
		leftToMerge1 = leftToMerge2 = sizeToMerge;
			if(!addQ(&q1, stringToAdd)){
				if(!addQ(&q1, stringToAdd)){

		// call headQ and store values into head1 and head2

// should take at most N*log2(N) adds.
					DIE("addQ failed");
				if(!addQ(&q1, line2)){
		int tmp = qSize1;
				return 1;
			qSize1++;
				printf("size we're merging: %d\n", sizeToMerge);
	while(!isEmptyQ(&q1)){

// From then on, just keep comparing heads until one of the queues is empty

		// now we've finished the merging -- now some housekeeping
			len = strtol(line + 1, &line, 10);
3/3		7:00pm		1 hour		Main function can read files and add lines to a 
// Macro to exit the program and print messages to standard error

			swap(&qSize1, &qSize2);
		pos = strtol(argv[1] + 1, &line, 10);

			}
			bigLeftToMerge2--;
		}
					return 1;
} Node;
	// now we print out the things in the queues, doing the last merge at
	char *line, *head1, *head2, *stringToAdd;
				// between the two queues
				// between the two queues
				if(!addQ(&q1, line)){

	// if we have a hyphen on the first argument, we have POS
					return 1;
			}
	if(!createQ(&q1) || !createQ(&q2)){
		pos = strtol(argv[1] + 1, &line, 10);
	// if we have a hyphen on the first argument, we have POS
		free(fullCommand);
				DIE("addQ failed");
				bigLeftToMerge2--;
			}
	// }
	// if we've had an odd number of swaps, swap again to keep q1 as priority
	}
		// otherwise, DIE
		if(!headQ(&q1, &head1) || !headQ(&q2, &head2)){
			}
				if(!addQ(&q1, stringToAdd)){
		// if we have a tie, remove from the queue that has priority

					DIE("addQ failed");
		bigLeftToMerge1 = qSize1;
					DIE("addQ failed");
				}
				// switch up the queues so that you split up the strings
#define DIE(msg) exit(fprintf(stderr, "%s\n", msg))
	*q2 = dummy;
    else{
				// first, which is the one that q1 originally pointed to
			offset2 = min(pos, lineSize2);
		if(!headQ(&q1, &head1) || !headQ(&q2, &head2)){
void swap(Queue *q1, Queue *q2){
	// if getLine doesn't fail, return its result
				DIE("addQ failed");
					}
			}
	if(argv[1][0] == '-'){
#include "/c/cs223/Hwk3/getLine.h"

    }
	int firstFileArg = 1, sizeToMerge = 1, numElements = 0;
		else if(strcmp(head1, head2) > 0){
		while(bigLeftToMerge2 > 0){
	// line1 and line2 will hold the two calls to newGetLine()
		free(stringToAdd);
// and false otherwise
				// add each line in q1
		while(bigLeftToMerge1 > 0){
// the node contains.
				else if(strcmp(head1, head2) > 0){
		// now we've finished the merging -- now some housekeeping
				if(!addQ(&q1, line)){
3/3		10:15pm		1 hour		Worked out stable mergesort algorithm using two
			if(!removeQ(&q2, &stringToAdd)){
			line1[lineSize1 - 1] = '\0';
	Queue dummy = *q1;
				qSize1 += 2;
				DIE("removeQ failed");
    return true;
				numElements++;
				if(strcmp(head1, head2) < 0){
			bigLeftToMerge1--;
				qSize1 = qSize2;

		// if we have excess on the first queue...the other queue should be
    if(isEmptyQ(q)){

		}
			while((line = getLine(inFile)) != NULL){
				// update the size each time, incremeting by two since we 
				swap(&q1, &q2);
	for(int i = firstFileArg; i < argc; i++){
				}
		else{
				}
		}
			DIE("removeQ failed");
	FILE *inFile;
	while(!isEmptyQ(&q1)){
			while((line = getLine(inFile)) != NULL){
    return (*q == NULL);
			DIE("removeQ failed");
				leftToMerge2--;
// should take at most N*log2(N) adds.
				qPos1++;
		free(stringToAdd);
			if(!removeQ(&q1, &stringToAdd)){
	destroyQ(&q2);
        (*newNode).next = (**q).next;
			qSize1 = qSize2;
			}
	while(!isEmptyQ(&q1)){


				leftToMerge1--;
		if(line2 == NULL){
				DIE("addQ failed");
				DIE("removeQ failed");
	}

#include <limits.h>
				qSize1++;
		firstFileArg = 2;
    // if malloc fails, return false
	// now we print out the things in the queues, doing the last merge at
			bigLeftToMerge2--;
		}
				// we don't free since the queue still points to the same addr
		if(inFile == NULL){
	// now we can finally start mergesorting!
				qSize1++;
					qSize2--;
		}
			return 1;
		if(!headQ(&q1, &head1) || !headQ(&q2, &head2)){
		}
			DIE("removeQ failed");
		qSize1 = qSize2;
	}
		if(line1[0] == ','){
		}
				else if(strcmp(head1, head2) > 0){
			}
	if(argc == 1){
					if(!removeQ(&q1, &stringToAdd)){
								very far
		}
						return 1;
		printf("%s\n", stringToAdd);
		}
								counter that keeps track of whether the queues
			len = INT_MAX;
    }
	return 0;
				}
			bigLeftToMerge2 = tmp;
				printf("size we're merging: %d\n", sizeToMerge);
			leftToMerge1 = leftToMerge2 = sizeToMerge;
		leftToMerge1 = leftToMerge2 = sizeToMerge;
		}
			// open the file and loop through the lines
		else{
#include "/c/cs223/Hwk4/Queue.h"
		qSize2 = tmp;
		printf("biglefts: %d %d\n", bigLeftToMerge1, bigLeftToMerge2);
		// empty
	// the same time
			DIE("removeQ failed");
				printf("size we're merging: %d\n", sizeToMerge);
 -- Reading in the files was initially a challenge, as I was initally planning
				if(!removeQ(&q1, &stringToAdd)){
					bigLeftToMerge1--;
		}
					return 1;
			}
			}
			bigLeftToMerge1--;

// you finish the first merging, alternating which queue you push to
		free(stringToAdd);
				}
					DIE("addQ failed");
			while(leftToMerge2 > 0){
				}
void swap(Queue *q1, Queue *q2){
				leftToMerge2--;
	// for(int i = 2; i < argc; i++){
					leftToMerge2--;
#include <stdbool.h>
	}
		pos = strtol(argv[1] + 1, &line, 10);
				// we don't free since the queue still points to the same addr
						printf("q1 is empty\n");
	*q2 = dummy;
					if(!removeQ(&q1, &stringToAdd)){
        (**q).next = newNode;
		free(stdInput);
		// this probably shouldn't ever happen but i'll do this just in case
// offset the bottom one by one. Then keep comparing heads until
				DIE("removeQ failed");
				}
		bigLeftToMerge1 = qSize1;
			return 1;
	}
	}
			qSize2 = tmp;
	return 0;
		qSize2 = tmp;
				leftToMerge2--;
// function to swap two queues (i.e. swap the pointers to the two nodes)
		DIE("createQ() failed!");

		else{
				// add each line in q1
#include <string.h>
	// if there's stuff left over from the first queue
			bigLeftToMerge1--;
        }
				if(!addQ(&q1, stringToAdd)){
				qSize1++;
				// switch up the queues so that you split up the strings

					DIE("headQ failed");
				}
	}
					DIE("addQ failed");
	long pos, len;
				// between the two queues
	// if we've had an odd number of swaps, swap again to keep q1 as priority
			if(!removeQ(&q2, &stringToAdd)){
					return 1;
		// if we have a tie, remove from the queue that has priority
		free(stringToAdd);
				DIE("addQ failed");
int addQ (Queue *q, char *s)
				DIE("removeQ failed");
			// with an empty list)
			len = INT_MAX;
	// now we print out the things in the queues, doing the last merge at
		// otherwise, DIE
				// now add the string to whichever queue we're currently adding to 
		// if we have excess on the first queue...the other queue should be
	// now we print out the things in the queues, doing the last merge at
		// if we have excess on the first queue...the other queue should be
		}
        (**q).next = newNode;
} Node;

			}
ESTIMATE of total time I will spend: 16 hours
					leftToMerge1--;
		// if we have excess on the first queue...the other queue should be
    else{
	FILE *inFile;
			// with an empty list)
	while(2 * sizeToMerge < numElements){


		printf("%s", stringToAdd);
		int tmp = qSize1;
    }
		}
#include <stdbool.h>
	bigLeftToMerge1 = qSize1;
	// make sure there's at least one argument after Merge16
		// this probably shouldn't ever happen but i'll do this just in case
	}
					DIE("removeQ failed");
	int qSize1 = 0, qSize2 = 0, bigLeftToMerge2, bigLeftToMerge1;
		free(stringToAdd);
		sizeToMerge *= 2;
		pos = strtol(argv[1] + 1, &line, 10);
			return 1;
	while(!isEmptyQ(&q1)){
				// if we have a tie, remove from the queue that has priority

		}
        *s = (**q).next->value;
					qSize1--;
	}
		offset1 = min(pos, lineSize1);
// should take at most N*log2(N) adds.
			// otherwise there's stuff left over from the second queue
				}
		// if we have a tie, remove from the queue that has priority
	// we don't have to merge the last time -- just print out
		int tmp = qSize1;
	int qSize1 = 0, qSize2 = 0, bigLeftToMerge2, bigLeftToMerge1;
					return 1;
			}
				// we don't free since the queue still points to the same addr

		qSize2 = tmp;
		for(int i = 1; i < argc; i++){
				qSize2--;
	to call getLine() twice per loop and then running a lot of cases on which

	// now we can finally start mergesorting!
		while(bigLeftToMerge1 > 0 && bigLeftToMerge2 > 0){
			len = INT_MAX;
			DIE("Invalid POS");
	// make sure there's at least one argument after Merge16
						DIE("removeQ failed");
		// call headQ and store values into head1 and head2
					leftToMerge1--;
			// if there's stuff left over from the first queue
	}
			while(leftToMerge1 > 0 && leftToMerge2 > 0){
}// hold two copies of the list in the beginning and 

	while(2 * sizeToMerge < numElements){
				if(!removeQ(&q2, &stringToAdd)){
	inFile = fopen(argv[fileArg], "r");
						return 1;
			}
		}
					if(!removeQ(&q1, &stringToAdd)){
					return 1;
	if(!createQ(&q1) || !createQ(&q2)){

			leftToMerge1 = leftToMerge2 = sizeToMerge;
		bigLeftToMerge1 = qSize1;
				qSize1++;
			if(!removeQ(&q2, &stringToAdd)){
				leftToMerge2--;
	bigLeftToMerge1 = qSize1;

void swap(Queue *q1, Queue *q2){
				// we don't free since the queue still points to the same addr
 -- Implementing the mergesort was also very difficult. The algorithm involved
		if(!removeQ(&q1, &stringToAdd)){
				// we don't free since the queue still points to the same addr
		fullCommand = strcat(fullCommand, subst16Command);
			//free(line);
	// free(argumentString);
		}
	}

        *s = (**q).next->value;
		}
				DIE("removeQ failed");
		if(!headQ(&q1, &head1) || !headQ(&q2, &head2)){
// you finish the first merging, alternating which queue you push to
								merging incorrectly
		pos = strtol(argv[1] + 1, &line, 10);

			// this will make the merging stop whenever it reaches the end of a
					if(isEmptyQ(&q1)){
		}
				// switch up the queues so that you split up the strings
					return 1;
		firstFileArg = 2;
	// q1 will always have the same or one more element than q2
				// first, which is the one that q1 originally pointed to

				DIE("addQ failed");
			}
	// the same time
						DIE("removeQ failed");
			while((line = getLine(inFile)) != NULL){
			}
		qPos1 = qPos2 = 0;
		leftToMerge1 = leftToMerge2 = sizeToMerge;
			DIE("File could not be opened!");
					DIE("addQ failed");
				// compare the two values, remove from whichever one is smaller
			if(!addQ(&q1, stringToAdd)){
#include <stdio.h>
				DIE("removeQ failed");
				qSize2 = tmp;
		pos = strtol(argv[1] + 1, &line, 10);
				if(!addQ(&q1, stringToAdd)){
				DIE("addQ failed");
		DIE("createQ() failed!");
		swap(&q1, &q2);
int main(int argc, char *argv[]){

	bigLeftToMerge1 = qSize1;
		// if we have excess on the first queue...the other queue should be
					DIE("addQ failed");
			if(!removeQ(&q1, &stringToAdd)){

	int qSize1 = 0, qSize2 = 0, bigLeftToMerge2, bigLeftToMerge1;
		}
	*q2 = dummy;

		// reset the queues if they're reversed (along with their sizes and 
								merging
		// if we've reached the end of the arguments, return NULL
	// if we have a hyphen on the first argument, we have POS
 -- Getting the algorithm for two-queue mergesort was difficult to begin with.
			}
					qSize2--;
#include "/c/cs223/Hwk3/getLine.h"
			return 1;
		// print the string with the newline and free it
		}
    if(isEmptyQ(q)){
	while(2 * sizeToMerge < numElements){
			}
		int tmp = qSize1;
		}
		// if we have a tie, remove from the queue that has priority
		swap(&q1, &q2);
			if(!removeQ(&q2, &stringToAdd)){
					}
				DIE("addQ failed");

					bigLeftToMerge1--;
		else{
	*q1 = *q2;
			if(!removeQ(&q1, &stringToAdd)){
		else{
				}
		// now we've finished the merging -- now some housekeeping
    // otherwise make s point to the string that the next node contains
			bigLeftToMerge2 = tmp;
a
int main(int argc, char *argv[]){


		while(bigLeftToMerge1 > 0){
			}
					DIE("removeQ failed");
			swap(&q1, &q2);
// function that takes in two ints (a and b) and returns the smaller of the two
	// we'll always add to q1, then swap each time
	// 	argumentString = strcat(argumentString, argv[i]);

		}

        *s = (**q).next->value;

	// if we have a hyphen on the first argument, we have POS

#include "/c/cs223/Hwk4/Queue.h"
		printf("%s", stringToAdd);
			// if there's stuff left over from the first queue
			if(!removeQ(&q1, &stringToAdd)){
// file names and stores the lines in two queues and mergesorts the two queues
	Queue dummy = *q1;

				}
				}
	// the same time
					return 1;
				}
		printf("biglefts: %d %d\n", bigLeftToMerge1, bigLeftToMerge2);
// should take at most N*log2(N) adds.

			while((line = getLine(inFile)) != NULL){
				// call headQ and store values into head1 and head2
*/
		free(stringToAdd);

#include <stdlib.h>
					}
		pos = strtol(argv[1] + 1, &line, 10);
			if(!removeQ(&q2, &stringToAdd)){
	// argumentString = strcat(argumentString, argv[1]);
				// now add the string to whichever queue we're currently adding to 

				// add each line in q1
		// if we have excess on the first queue...the other queue should be
			swap(&qSize1, &qSize2);
				}
	while(!isEmptyQ(&q2)){
	}
		int tmp = qSize1;
		printf("%s", stringToAdd);
    *s = (*nodeToRemove).value;
					DIE("removeQ failed");
								most functions								
					qSize1--;
	Queue dummy = *q1;
					if(!removeQ(&q1, &stringToAdd)){
		// this probably shouldn't ever happen but i'll do this just in case
					qSize1--;
		firstFileArg = 2;
			}
		free(stringToAdd);
		}
#include <stdbool.h>
        (*newNode).next = (**q).next;
				}
			DIE("File could not be opened!");
				// call headQ and store values into head1 and head2
			return 1;
			bigLeftToMerge2--;
				}
	int qSize1 = 0, qSize2 = 0, bigLeftToMerge2, bigLeftToMerge1;
		fullCommand = strcat(fullCommand, subst16Command);
			}
		printf("size to merge bottom: %d\n", sizeToMerge);
					return 1;
					DIE("addQ failed");
		// empty
				printf("two heads are %s %s\n", head1, head2);
					bigLeftToMerge1--;
			qSize1++;
	// now we can finally start mergesorting!
						return 1;
			bigLeftToMerge2--;
			// open the file and loop through the lines
		}
					if(!removeQ(&q1, &stringToAdd)){


	FILE *inFile;

// new node to the end of the linked list whose contents is the string
				}
				// we don't free since the queue still points to the same addr
		}

				if(strcmp(head1, head2) < 0){
				qSize2--;
			}
					qSize2--;
	// queue that q1 originally pointed to) and true otherwise
					DIE("addQ failed");
	bigLeftToMerge2 = qSize2;

				numElements++;
				bigLeftToMerge1--;
				return 1;
				}
				// switch up the queues so that you split up the strings
#include <string.h>
	}

void swap(Queue *arg1, Queue *arg2);
			len = strtol(line1 + 1, &line1, 10);
								counter that keeps track of whether the queues
			}
				bigLeftToMerge1--;
					qSize2--;
	if(qSize2 > qSize1){
				// switch up the queues so that you split up the strings
			}

		if(inFile == NULL){
		sizeToMerge *= 2;
		if(line[0] == ','){
		DIE("createQ() failed!");

					DIE("addQ failed");
		}
			int tmp = qSize1;
			qSize1 = qSize2;
				// we don't free since the queue still points to the same addr
// removes the first node from the queue, and makes s point to the value that
					if(!removeQ(&q1, &stringToAdd)){

				}
		// this probably shouldn't ever happen but i'll do this just in case
// Function takes in a pointer to a Queue, returns true if the Queue is empty
			}
					leftToMerge1--;
    // frees each of the nodes)
		qSize1 = qSize2;

						return 1;
					DIE("removeQ failed");
		int tmp = qSize1;

3/9		4:30pm		1 hour		It now sorts but only handles powers of 2 and is
				// compare the two values, remove from whichever one is smaller
			swap(&q1, &q2);
				DIE("removeQ failed");
	}
    }
			if(!removeQ(&q2, &stringToAdd)){
		printf("%s", stringToAdd);
				}
			}
	FILE *inFile;
			if(!addQ(&q1, stringToAdd)){

				bigLeftToMerge2--;
{
		}
		if(inFile == NULL){
								are reversed, plus one to keep track of when
			if(!addQ(&q1, stringToAdd)){
		if(line[0] == ','){
		swap(&q1, &q2);

	if(qSize2 > qSize1){
// Function that takes in a pointer to a queue (q) and a pointer to a string s
		// empty
	// if we've had an odd number of swaps, swap again to keep q1 as priority
			qSize1 = qSize2;
		}


	if(qSize2 > qSize1){
		// empty
					DIE("headQ failed");
		if(!removeQ(&q1, &stringToAdd)){
	}
				qSize1++;
			swap(&q1, &q2);
		free(stringToAdd);
		}
					DIE("removeQ failed");
 -- Reading in the files was initially a challenge, as I was initally planning
			leftToMerge1 = leftToMerge2 = sizeToMerge;

// Function that takes in a pointer to a Queue (q) and a string (s), then adds a
 				
					qSize1--;
				return 1;
		else{
			tmp = bigLeftToMerge1;
			if(!addQ(&q1, stringToAdd)){
				printf("two heads are %s %s\n", head1, head2);
					DIE("addQ() failed!");
	*q2 = dummy;
	}
		}
			}
					return 1;
		free(stringToAdd);
	while(!isEmptyQ(&q1) && !isEmptyQ(&q2)){
2/29	4:00pm		1 hour		Discussed problem statement with Jared Weinstein

		while(bigLeftToMerge2 > 0){
Date	Start		Time		Notes
    }
					return 1;
				printf("size we're merging: %d\n", sizeToMerge);
						DIE("removeQ failed");
	*q2 = dummy;
		else if(strcmp(head1, head2) > 0){
 				
		printf("%s", stringToAdd);
				// if we have a tie, remove from the queue that has priority
		DIE("createQ() failed!");
				DIE("addQ failed");
				printf("left to merges: %d %d\n", leftToMerge1, leftToMerge2);
	Queue q1 = NULL, q2 = NULL;
								merging
{
			len = strtol(line + 1, &line, 10);
				numElements++;
				if(!addQ(&q1, line)){
					bigLeftToMerge1--;
			return 1;
			}
			bigLeftToMerge1 = bigLeftToMerge2;
			if(!removeQ(&q1, &stringToAdd)){
				if(!removeQ(&q2, &stringToAdd)){
						return 1;
		}
	Queue q1 = NULL, q2 = NULL;
				printf("left to merges: %d %d\n", leftToMerge1, leftToMerge2);

		while(bigLeftToMerge1 > 0){
	to call getLine() twice per loop and then running a lot of cases on which
				qSize2 = tmp;
			if(!removeQ(&q1, &stringToAdd)){
// to an empty queue. Returns true
				printf("size we're merging: %d\n", sizeToMerge);
    if(isEmptyQ(q)){

		// if fopen throws an error

	while(!isEmptyQ(&q1)){
		if(strcmp(head1, head2) < 0){
// the node contains.
	FILE *inFile;
// should take at most N*log2(N) adds.
				// we don't free since the queue still points to the same addr
}
		if(inFile == NULL){
					leftToMerge1--;
		}
	// if we've had an odd number of swaps, swap again to keep q1 as priority
	if(qSize2 > qSize1){
					DIE("addQ failed");
			while((line = getLine(inFile)) != NULL){
	// we don't have to merge the last time -- just print out
			}
		return a;
			// otherwise there's stuff left over from the second queue
	for(int i = firstFileArg; i < argc; i++){
// From then on, just keep comparing heads until one of the queues is empty
				DIE("addQ failed");
	// otherwise there's stuff left over from the second queue
int main(int argc, char *argv[]){
int main(int argc, char *argv[]){
				printf("bigLeftToMerges: %d %d\n", bigLeftToMerge1, bigLeftToMerge2);
		while(bigLeftToMerge2 > 0){

						return 1;
	}
				return 1;
			qSize2 = tmp;
		// call headQ and store values into head1 and head2
				numElements++;
	int leftToMerge1 = 1, leftToMerge2 = 1;
				}
					if(!removeQ(&q1, &stringToAdd)){
	long pos, len;
				// we don't free since the queue still points to the same addr
 -- Implementing the mergesort was also very difficult. The algorithm involved
				else{
	// we don't have to merge the last time -- just print out
		// this probably shouldn't ever happen but i'll do this just in case
}
			// if there's anything trailing at the end, DIE
	}

	bigLeftToMerge1 = qSize1;
		printf("%s", stringToAdd);
#include "/c/cs223/Hwk4/Queue.h"

					leftToMerge2--;
		bigLeftToMerge1 = qSize1;
	// otherwise there's stuff left over from the second queue
		}
		bigLeftToMerge1 = qSize1;

		}

	for(int i = firstFileArg; i < argc; i++){
		free(stringToAdd);
	if(qSize2 > qSize1){

	long pos, len;
					leftToMerge2--;
		inFile = fopen(argv[i], "r");

		// if fopen throws an error
	for(int i = firstFileArg; i < argc; i++){
					}
		firstFileArg = 2;
				if(!addQ(&q1, line2)){

		while(bigLeftToMerge2 > 0){
	addQ()s, as the one that I originally had workd in N ceil(Log(N)).
			return 1;
		//stdInput[strlen(line) - 1] = '\0';
		free(stringToAdd);
		return 1;
		inFile = fopen(argv[i], "r");
		free(stringToAdd);
					qSize1--;
			swap(&q1, &q2);

	addQ()s, as the one that I originally had workd in N ceil(Log(N)).
				DIE("removeQ failed");
				if(!addQ(&q1, line)){
			tmp = bigLeftToMerge1;
				qSize2--;
#define DIE(msg) exit(fprintf(stderr, "%s\n", msg))
	if(!createQ(&q1) || !createQ(&q2)){

				// between the two queues
				}
#include <stdio.h>
			// if there's stuff left over from the first queue
			qSize2 = tmp;
			//free(line);
				// add each line in q1
				bigLeftToMerge2--;
					if(!removeQ(&q1, &stringToAdd)){
			qSize2--;
	FILE *inFile;
3/9		8:45pm		1 hour		Mostly fixed the mergesort algorithm, but it
// Function that takes in a pointer to a queue (q) and a pointer to a string s
	*q2 = dummy;
					bigLeftToMerge1--;
					if(isEmptyQ(&q1)){
					bigLeftToMerge2--;
		while(bigLeftToMerge2 > 0){
		firstFileArg = 2;
				qSize2--;
			while((line = getLine(inFile)) != NULL){
    struct node *next;
		}
	// if there's stuff left over from the first queue
        return false;

		qSize1 = qSize2;
					if(!removeQ(&q1, &stringToAdd)){
			}
// memory associated with it
// function to swap two queues (i.e. swap the pointers to the two nodes)
	}
				bigLeftToMerge2--;
int main(int argc, char *argv[]){
int main(int argc, char *argv[]){
int main(int argc, char *argv[]){
			}
				// add each line in q1
				// now add the string to whichever queue we're currently adding to 
	// now loop through the rest of the args and read them as files
					bigLeftToMerge2--;
	// now loop through the rest of the args and read them as files
// you finish the first merging, alternating which queue you push to
				// switch up the queues so that you split up the strings
	}
				}

					return 1;
		// now check if LEN is specified, and if it isn't, set it to INT_MAX
		printf("%s", stringToAdd);
				// we don't free since the queue still points to the same addr
	// now we print out the things in the queues, doing the last merge at
					return 1;
				return 1;
						DIE("removeQ failed");

{
					return 1;
				numElements++;
	// startSize2 are their sizes at the start of each merge, qPos1 and qPos2
		inFile = fopen(argv[i], "r");
	// now we can finally start mergesorting!
					}
	}
		stdInput = strncpy(stdInput, line, strlen(line) - 1);
				}
 -- Reading in the files was initially a challenge, as I was initally planning
	Eventually I realized (with the help of Will) that I could read in the lines
	// make sure there's at least one argument after Merge16
	Queue dummy = *q1;
			}
	if(a < b){
}
				qSize2 = tmp;
Date	Start		Time		Notes
						DIE("removeQ failed");
	}
	if(!createQ(&q1) || !createQ(&q2)){
/*Progress report: sorts, but doesn't handle it when there's leftover between merges (i.e. when one bigleft is nonzero but the other is zero)
	return line1;
					}
				DIE("removeQ failed");
	int leftToMerge1 = 1, leftToMerge2 = 1;
	// we'll always add to q1, then swap each time
		free(stringToAdd);
		}

	int leftToMerge1 = 1, leftToMerge2 = 1;
		while(bigLeftToMerge1 > 0 && bigLeftToMerge2 > 0){
				// now add the string to whichever queue we're currently adding to 
		// call headQ and store values into head1 and head2
				if(!removeQ(&q2, &stringToAdd)){
				return 1;
	bigLeftToMerge1 = qSize1;
#include <stdbool.h>

	while(2 * sizeToMerge < numElements){
			DIE("removeQ failed");
		while(bigLeftToMerge1 > 0 && bigLeftToMerge2 > 0){

				swap(&q1, &q2);
						printf("q1 is empty\n");
			while((line = getLine(inFile)) != NULL){
			}
		DIE("createQ() failed!");
		if(line[0] == ','){

		}
			}
					return 1;
				DIE("removeQ failed");
				if(!addQ(&q1, stringToAdd)){
// whether queue is empty
					bigLeftToMerge1--;
					}

					DIE("removeQ failed");
				}
				}
				}
					return 1;
			DIE("removeQ failed");
	}
		}
				return 1;
		printf("%s", stringToAdd);
	bigLeftToMerge2 = qSize2;
						DIE("removeQ failed");
	// if there's stuff left over from the first queue

	int firstFileArg = 1, sizeToMerge = 1, numElements = 0;
					bigLeftToMerge2--;
3/15	9:00pm		1 hour		Sorts fine, mostly stable, seems to work with PO								S,LEN
				int tmp = qSize1;
				DIE("removeQ failed");
				bigLeftToMerge1--;
		// files start at the next command line argument
		free(stringToAdd);
		else{

					}
	int firstFileArg = 1, sizeToMerge = 1, numElements = 0;
// From then on, just keep comparing heads until one of the queues is empty
		// if we have excess on the first queue...the other queue should be
			len = strtol(line + 1, &line, 10);
				DIE("removeQ failed");
				qSize1 = qSize2;
				printf("bigLeftToMerges: %d %d\n", bigLeftToMerge1, bigLeftToMerge2);
				if(!addQ(&q1, line)){
				leftToMerge2--;
			qSize1++;
// removes the first node from the queue, and makes s point to the value that
	// for(int i = 2; i < argc; i++){
	*q2 = dummy;
		argLength += (test + 1);
						return 1;
					bigLeftToMerge1--;
			DIE("removeQ failed");
				if(!removeQ(&q1, &stringToAdd)){
	bigLeftToMerge1 = qSize1;
		fullCommand = strcpy(fullCommand, echo);
void swap(Queue *q1, Queue *q2){
		// call headQ and store values into head1 and head2
}
			return 1;
			}
		}
	}
			}
			if(!removeQ(&q2, &stringToAdd)){
				return 1;
		sizeToMerge *= 2;
		int tmp = qSize1;

		printf("%s", stringToAdd);

/*Progress report: sorts, but doesn't handle it when there's leftover between merges (i.e. when one bigleft is nonzero but the other is zero)

				}
			tmp = bigLeftToMerge1;
					}
}
				return 1;
			while(leftToMerge1 > 0 && leftToMerge2 > 0){
					return 1;
				if(!addQ(&q1, stringToAdd)){
			if(!removeQ(&q1, &stringToAdd)){
			bigLeftToMerge1--;
	while(2 * sizeToMerge < numElements){
			DIE("removeQ failed");
				DIE("removeQ failed");
					DIE("removeQ failed");
		}
    else{
				swap(&q1, &q2);
				offset2 = min(pos, strlen(head2));
								doesn't work...also seg faults in isEmptyQ
	// if there's stuff left over from the first queue
void swap(Queue *arg1, Queue *arg2);
	addQ()s, as the one that I originally had workd in N ceil(Log(N)).
	}
    Queue temp = NULL;
	bigLeftToMerge1 = qSize1;
			if(!addQ(&q1, stringToAdd)){
// and prints out the sorted lines
    }

#include <limits.h>
					if(!removeQ(&q1, &stringToAdd)){
		}
		}
					bigLeftToMerge2--;
			return 1;
				else if(strcmp(head1, head2) > 0){

	}
	int qSize1 = 0, qSize2 = 0, bigLeftToMerge2, bigLeftToMerge1;
		qSize2 = tmp;
3/9		9:45pm 		1 hour		Identified a few bugs, trying to fix them
		free(stringToAdd);
				DIE("removeQ failed");
			bigLeftToMerge2--;
			qSize2--;
		printf("size to merge bottom: %d\n", sizeToMerge);

	// }
// the list (or NULL if the queue is empty).
    // if the queue is empty, it has no head, so it fails
			qSize2--;
				}
				}
	}
			while(leftToMerge2 > 0){
								doesn't work for big files
	int leftToMerge1 = 1, leftToMerge2 = 1;
	destroyQ(&q1);

#include "/c/cs223/Hwk4/Queue.h"

				else{
						printf("q1 is empty\n");
// function to swap two queues (i.e. swap the pointers to the two nodes)
			return 1;
								and Annie Chen						
			}
		}
Difficulties I ran into:
// function to swap two queues (i.e. swap the pointers to the two nodes)
		printf("size to merge bottom: %d\n", sizeToMerge);
		}

		swap(&q1, &q2);
	// q1 will always have the same or one more element than q2
				qSize2--;
				leftToMerge1--;
	bigLeftToMerge2 = qSize2;
		// now we've finished the merging -- now some housekeeping
	Queue dummy = *q1;
	}
				}
// Node struct will be used for each node in the linked list.
			}
				int tmp = qSize1;
			// otherwise there's stuff left over from the second queue
			if(!removeQ(&q2, &stringToAdd)){
				qSize2 = tmp;
			}
			// if there's stuff left over from the first queue
			}
	}
		while(bigLeftToMerge1 > 0){
			}
		if(!removeQ(&q2, &stringToAdd)){
	while(!isEmptyQ(&q1)){
			len = INT_MAX;
		while(bigLeftToMerge1 > 0){

					}
			return 1;
				numElements++;
				qSize1++;
void swap(Queue *q1, Queue *q2){

			if(!addQ(&q1, stringToAdd)){
void swap(Queue *arg1, Queue *arg2);
// (next) to the next node in the linked list
				DIE("addQ failed");
	int qSize1 = 0, qSize2 = 0, bigLeftToMerge2, bigLeftToMerge1;

// function to swap two queues (i.e. swap the pointers to the two nodes)
		bigLeftToMerge2 = qSize2;
			bigLeftToMerge1 = bigLeftToMerge2;
	}
// Implementation of Queue ADT using headless, singly-linked, circular list.
					}
			swap(&q1, &q2);
		else if(strcmp(head1, head2) > 0){
	if(qSize2 > qSize1){
// offset the bottom one by one. Then keep comparing heads until
	*q2 = dummy;
					DIE("headQ failed");
			}
    // if there's no node to remove, return false
}
    else{
			qSize2--;
 				
3/3		1:30pm		1 hour		Started work on Queue.c, have first version of
		free(stringToAdd);
		free(stringToAdd);
				if(!headQ(&q1, &head1) || !headQ(&q2, &head2)){
				printf("bigLeftToMerges: %d %d\n", bigLeftToMerge1, bigLeftToMerge2);

        (**q).next = newNode;
		if(!removeQ(&q2, &stringToAdd)){
					DIE("removeQ failed");
	}
					DIE("removeQ failed");
				}
			while(leftToMerge2 > 0){
	bigLeftToMerge1 = qSize1;

People I consulted with: Jared Weinstein, Annie Chen, Will Merrill

	// q1 will always have the same or one more element than q2
// between consecutive merges

    // if the queue is empty, it has no head, so it fails
// offset the bottom one by one. Then keep comparing heads until
			len = strtol(line + 1, &line, 10);
								doesn't work...also seg faults in isEmptyQ
				if(!addQ(&q1, stringToAdd)){
			}
					DIE("addQ failed");
	// if we have a hyphen on the first argument, we have POS
		int tmp = qSize1;
 				
	two at a time and essentially do the first merge as I filled in the queues
				DIE("removeQ failed");
		if(!headQ(&q1, &head1) || !headQ(&q2, &head2)){
				// compare the two values, remove from whichever one is smaller
				// if we have a tie, remove from the queue that has priority
3/10	8:30pm		1 hour		Change method of keeping track of indexes when
		bigLeftToMerge2 = qSize2;
 				
				printf("size we're merging: %d\n", sizeToMerge);
	while(!isEmptyQ(&q1) && !isEmptyQ(&q2)){
		//stdInput[strlen(line) - 1] = '\0';
// function that takes in two ints (a and b) and returns the smaller of the two
		// call headQ and store values into head1 and head2
		if(!headQ(&q1, &head1) || !headQ(&q2, &head2)){
	// if there's stuff left over from q1, print the rest of q1 and free each
*/
			}
					qSize2--;
						return 1;
					if(!removeQ(&q2, &stringToAdd)){
				DIE("removeQ failed");
			//free(line);
				}
			DIE("File could not be opened!");
				}
	int qSize1 = 0, qSize2 = 0, bigLeftToMerge2, bigLeftToMerge1;
				// compare the two values, remove from whichever one is smaller
			leftToMerge1 = leftToMerge2 = sizeToMerge;
		if(!removeQ(&q1, &stringToAdd)){
		printf("biglefts: %d %d\n", bigLeftToMerge1, bigLeftToMerge2);
					leftToMerge2--;
				if(!addQ(&q1, stringToAdd)){
    return true;
3/15	9:00pm		1 hour		Sorts fine, mostly stable, seems to work with PO								S,LEN
		if(strcmp(head1, head2) < 0){
// memory associated with it
		int tmp = qSize1;
				}
					leftToMerge2--;
						return 1;
	bigLeftToMerge2 = qSize2;
	return 0;
		}

				if(!addQ(&q1, stringToAdd)){
				}

			}
	if(qSize2 > qSize1){


			if(!addQ(&q1, stringToAdd)){
			}
3/21	4:30pm		.5 hours	Put more detailed comments in the code
	}
				printf("two heads are %s %s\n", head1, head2);
    *s = (*nodeToRemove).value;

				bigLeftToMerge1--;
	int dummy = *a;
						DIE("removeQ failed");
			DIE("removeQ failed");
				}

	}
			//free(line);
    Node *nodeToRemove = (**q).next;
								queues
				}
			bigLeftToMerge2--;
		}
		}
					DIE("removeQ failed");
	}
3/15	9:00pm		1 hour		Sorts fine, mostly stable, seems to work with PO								S,LEN
			len = strtol(line + 1, &line, 10);
	char *line, *head1, *head2, *stringToAdd;
				numElements++;
			}
#define DIE(msg) exit(fprintf(stderr, "%s\n", msg))
			len = INT_MAX;
				if(strcmp(head1, head2) < 0){
				DIE("removeQ failed");
		printf("biglefts: %d %d\n", bigLeftToMerge1, bigLeftToMerge2);
		if(strcmp(head1, head2) < 0){
			qSize1++;
				DIE("removeQ failed");
        *q = NULL;
    Node *nodeToRemove = (**q).next;
				DIE("removeQ failed");
/*Progress report: sorts, but doesn't handle it when there's leftover between merges (i.e. when one bigleft is nonzero but the other is zero)
						DIE("removeQ failed");
#include <stdbool.h>
				}
					}
			while(leftToMerge1 > 0 && leftToMerge2 > 0){

	// if we have a hyphen on the first argument, we have POS
			if(!removeQ(&q1, &stringToAdd)){
			}
		else{
				return 1;
	// now loop through the rest of the args and read them as files
				}
			bigLeftToMerge2--;

								queues
	// otherwise there's stuff left over from the second queue
		// call headQ and store values into head1 and head2
		qSize1 = qSize2;
					return 1;
		// call headQ and store values into head1 and head2
					return 1;
		swap(&q1, &q2);
		printf("%s", stringToAdd);
	// we don't have to merge the last time -- just print out
#include <limits.h>
		}
				}
// between consecutive merges
					qPos2++;
		DIE("createQ() failed!");

					}
		qSize2 = tmp;
					return 1;
						DIE("removeQ failed");
				int tmp = qSize1;
    return true;
		swap(&q1, &q2);
		printf("%s", stringToAdd);
			DIE("Invalid POS");
// function to swap two ints. Takes pointers to two ints (a and b) and makes 
				DIE("removeQ failed");
// function to swap two queues (i.e. swap the pointers to the two nodes)
		firstFileArg = 2;
		free(stringToAdd);
				leftToMerge2--;
void swap(Queue *q1, Queue *q2){
				// between the two queues
				DIE("removeQ failed");
								most functions								
		pos = strtol(argv[1] + 1, &line, 10);
	if(argc == 1){
				if(strcmp(head1, head2) < 0){
	// if we have a hyphen on the first argument, we have POS
		free(stringToAdd);
		}
	bigLeftToMerge2 = qSize2;
		printf("%s", stringToAdd);
			bigLeftToMerge1 = bigLeftToMerge2;
			if(!removeQ(&q1, &stringToAdd)){
					leftToMerge2--;
	// otherwise there's stuff left over from the second queue
#include <limits.h>
			qSize2 = tmp;
			len = strtol(line + 1, &line, 10);
					bigLeftToMerge2--;

			bigLeftToMerge2 = tmp;
				qSize1++;
		}
			DIE("removeQ failed");
					return 1;

		}
				if(strcmp(head1, head2) < 0){
		}
			}
	// if we have a hyphen on the first argument, we have POS
					}
	for(int i = firstFileArg; i < argc; i++){
		// read in the next line for line2
		printf("%s", stringToAdd);
}

		leftToMerge1 = leftToMerge2 = sizeToMerge;
		// this probably shouldn't ever happen but i'll do this just in case
	// if we've had an odd number of swaps, swap again to keep q1 as priority
		printf("%s", stringToAdd);
					return 1;
		else if(strcmp(head1, head2) > 0){
		inFile = fopen(argv[i], "r");
				printf("left to merges: %d %d\n", leftToMerge1, leftToMerge2);
				bigLeftToMerge1--;
		else{
#include "/c/cs223/Hwk3/getLine.h"

	*q1 = *q2;
	// line1 and line2 will hold the two calls to newGetLine()
		qSize2 = tmp;
		else{
				if(!addQ(&q1, line)){
			if(!addQ(&q1, stringToAdd)){
			swap(&q1, &q2);
			// if there's anything trailing at the end, DIE
		}


		// call headQ and store values into head1 and head2
		}
	int firstFileArg = 1, sizeToMerge = 1, numElements = 0;
				// compare the two values, remove from whichever one is smaller
		argLength += (test + 1);
	Queue dummy = *q1;
	// q1 will always have the same or one more element than q2
	FILE *inFile;
		// empty
	*q2 = dummy;


			bigLeftToMerge1 = bigLeftToMerge2;
				leftToMerge1--;
	if(argc == 1){
		int tmp = qSize1;
					if(!removeQ(&q2, &stringToAdd)){
			while(leftToMerge1 > 0){
3/9		7:30pm		1 hour		Sorts a little bit better but somehow breaks
			}
				leftToMerge2--;

	// if we have a hyphen on the first argument, we have POS
			}

				else{
			leftToMerge1 = leftToMerge2 = sizeToMerge;
	destroyQ(&q1);
#include "/c/cs223/Hwk3/getLine.h"
	destroyQ(&q1);
}#include <stdio.h>

// should take at most N*log2(N) adds.
				return 1;
		// now we've finished the merging -- now some housekeeping


		printf("%s", stringToAdd);

					}
			// open the file and loop through the lines
	destroyQ(&q1);
		else{
		// this probably shouldn't ever happen but i'll do this just in case
#include <limits.h>
					if(!removeQ(&q1, &stringToAdd)){
		printf("%s", stringToAdd);
		bigLeftToMerge2 = qSize2;
				qSize2--;
			// open the file and loop through the lines
					return 1;
		}
				if(strcmp(head1, head2) < 0){
			bigLeftToMerge2--;
			}
	if(qSize2 > qSize1){
			leftToMerge1 = leftToMerge2 = sizeToMerge;
				qSize1++;

		}
					qSize2--;
				}
			}
				else{
					qSize1--;
			}
		qSize1 = qSize2;
						return 1;
		// if we have excess on the first queue...the other queue should be
					qSize1--;
			swap(&startSize1, &startSize2);
*/
				DIE("removeQ failed");
// Returns true if operation succeeded, false if it failed
					DIE("removeQ failed");
				leftToMerge1--;
		}
	// now we print out the things in the queues, doing the last merge at

	*q1 = *q2;
	if(qSize2 > qSize1){
	various while loops, so it took me three or four tries of redoing my code
		// call headQ and store values into head1 and head2

			int tmp = qSize1;
int min(int arg1, int arg2);
				DIE("removeQ failed");
		else{
			offset2 = min(pos, lineSize2);
	// head1 and head2
			}
		free(stringToAdd);
		// call headQ and store values into head1 and head2
		printf("%s\n", stringToAdd);
			}
	while(2 * sizeToMerge < numElements){
		inFile = fopen(argv[i], "r");
	if(!createQ(&q1) || !createQ(&q2)){
					}
		// if we have excess on the first queue...the other queue should be
			while(leftToMerge1 > 0){
	char *line, *head1, *head2, *stringToAdd;
			}
	*q1 = *q2;
			swap(&q1, &q2);
			if(!removeQ(&q2, &stringToAdd)){
				if(!addQ(&q1, stringToAdd)){

				// so we have to check whether the queues are reversed
				DIE("addQ failed");
		}
			// otherwise there's stuff left over from the second queue
					return 1;

					qSize1--;
	// if there's stuff left over from the first queue
			DIE("removeQ failed");
			//free(line);
			}
			tmp = bigLeftToMerge1;

				printf("left to merges: %d %d\n", leftToMerge1, leftToMerge2);
	int firstFileArg = 1, sizeToMerge = 1, numElements = 0;
	*q2 = dummy;
		qSize2 = tmp;
		else if(strcmp(head1, head2) > 0){
					return 1;
					if(!removeQ(&q1, &stringToAdd)){
			if(!addQ(&q1, stringToAdd)){
	to call getLine() twice per loop and then running a lot of cases on which
 				
// between consecutive merges
void swap(Queue *arg1, Queue *arg2);
				}
			DIE("File could not be opened!");
					bigLeftToMerge2--;
				int tmp = qSize1;
			DIE("File could not be opened!");
				if(!removeQ(&q1, &stringToAdd)){
			if(!removeQ(&q2, &stringToAdd)){
			// if there's stuff left over from the first queue
			// if there's anything trailing at the end, DIE

				int tmp = qSize1;
				// between the two queues
			// otherwise there's stuff left over from the second queue
		return 1;
	while(!isEmptyQ(&q1) && !isEmptyQ(&q2)){
			tmp = bigLeftToMerge1;
				DIE("removeQ failed");
		printf("biglefts: %d %d\n", bigLeftToMerge1, bigLeftToMerge2);

					bigLeftToMerge2--;
				printf("two heads are %s %s\n", head1, head2);
				qSize1++;
					return 1;
				return 1;
		qSize1 = qSize2;
		if(!removeQ(&q2, &stringToAdd)){
				return 1;
	to get a working version
					qSize1--;
					}
		}
#define DIE(msg) exit(fprintf(stderr, "%s\n", msg))
			}

3/3		10:15pm		1 hour		Worked out stable mergesort algorithm using two
					return 1;

			if(!removeQ(&q2, &stringToAdd)){
			while(leftToMerge1 > 0){
3/10	9:30pm		.5 hours	Debugged, but now it infinite loops instead of
					qSize1--;
		while(bigLeftToMerge2 > 0){
			// on a queue or the end of one of the queues
				numElements++;
	Queue q1 = NULL, q2 = NULL;
// you finish the first merging, alternating which queue you push to
			return 1;
		}
				numElements++;
			qSize1 = qSize2;
		free(stringToAdd);
		}
			}
	for(int i = firstFileArg; i < argc; i++){
				if(!addQ(&q1, stringToAdd)){
// offset the bottom one by one. Then keep comparing heads until
					}
					if(!removeQ(&q2, &stringToAdd)){
// offset the bottom one by one. Then keep comparing heads until
	// pos and len hold the POS,LEN command line options
	// stopMergeIndex1 and stopMergeIndex2 are the indices which mark the place
					leftToMerge1--;
				qSize1++;
		// if fopen throws an error
				if(!addQ(&q1, stringToAdd)){
				qSize1++;

		offset1 = min(pos, strlen(head1));
}// hold two copies of the list in the beginning and 
					}
				qSize1 = qSize2;
			qSize2 = tmp;
			bigLeftToMerge1--;
			}
				}
			return 1;
				leftToMerge2--;
				qSize1++;
					qSize1--;
					DIE("addQ failed");
		}
					return 1;
		while(bigLeftToMerge1 > 0 && bigLeftToMerge2 > 0){
    }
			tmp = bigLeftToMerge1;


		while(bigLeftToMerge2 > 0){

					return 1;
		int tmp = qSize1;
    char *dummyS;
						return 1;
			if(!removeQ(&q2, &stringToAdd)){
			if(!removeQ(&q1, &stringToAdd)){
				qSize2 = tmp;
		}
				}
				if(!addQ(&q1, stringToAdd)){
		if(!removeQ(&q1, &stringToAdd)){
			if(!addQ(&q1, stringToAdd)){
    return true;
		}
		}
		swap(&q1, &q2);
					qSize1--;
		else{
			bigLeftToMerge1 = bigLeftToMerge2;
3/15	8:00pm		1 hour		Now it sorts! Working on incorporating pos,len,
	}
		leftToMerge1 = leftToMerge2 = sizeToMerge;
		if(!removeQ(&q1, &stringToAdd)){
		}
	// make sure there's at least one argument after Merge16
				qSize1++;
				}
				leftToMerge2--;
				printf("bigLeftToMerges: %d %d\n", bigLeftToMerge1, bigLeftToMerge2);
		qSize2 = tmp;
	// otherwise there's stuff left over from the second queue
				qSize2 = tmp;
				if(strcmp(head1, head2) < 0){
int main(int argc, char *argv[]){
    struct node *next;
			DIE("removeQ failed");
// between consecutive merges
	bigLeftToMerge1 = qSize1;
	// if we have a hyphen on the first argument, we have POS
				// add each line in q1
				printf("bigLeftToMerges: %d %d\n", bigLeftToMerge1, bigLeftToMerge2);
					}
		bigLeftToMerge2 = qSize2;
		free(stringToAdd);
					bigLeftToMerge1--;
		// otherwise, order line1 and line2, and add both to q1 in increasing
			while((line = getLine(inFile)) != NULL){

					qSize2--;
			}

					leftToMerge2--;
		// call headQ and store values into head1 and head2
				if(!addQ(&q1, stringToAdd)){
					DIE("removeQ failed");
	// now we can finally start mergesorting!

			DIE("File could not be opened!");
			swap(&q1, &q2);
		printf("%s", stringToAdd);
	}
		leftToMerge1 = leftToMerge2 = sizeToMerge;
	Queue q1 = NULL, q2 = NULL;
			bigLeftToMerge1 = bigLeftToMerge2;
		pos = strtol(argv[1] + 1, &line, 10);
			// otherwise there's stuff left over from the second queue
					return 1;
	// otherwise do the same with q2
		else if(strcmp(head1, head2) > 0){
	if(qSize2 > qSize1){
	bigLeftToMerge2 = qSize2;
						DIE("removeQ failed");
			qSize2 = tmp;
	// the same time
		}
				if(!addQ(&q1, stringToAdd)){
					if(!removeQ(&q1, &stringToAdd)){
			qSize1++;
				DIE("removeQ failed");
				printf("bigLeftToMerges: %d %d\n", bigLeftToMerge1, bigLeftToMerge2);
					}
	}
	*q2 = dummy;
					}
				DIE("addQ failed");
			}

				// update the size each time, again incrementing by two
			return 1;
				// if we have a tie, remove from the queue that has priority
		}
				if(!addQ(&q1, stringToAdd)){
		bigLeftToMerge2 = qSize2;
			if(!removeQ(&q1, &stringToAdd)){
				if(!removeQ(&q1, &stringToAdd)){
	while(!isEmptyQ(&q1)){
		qSize2 = tmp;
	bigLeftToMerge1 = qSize1;
			// open the file and loop through the lines
char *newGetLine(char *argv[], int argc, FILE **fileToRead, int *fileIndex){
				printf("left to merges: %d %d\n", leftToMerge1, leftToMerge2);
			}
		free(stringToAdd);
					qSize2--;
					DIE("addQ failed");
// should take at most N*log2(N) adds.
					}
				}
						DIE("removeQ failed");
		if(!removeQ(&q1, &stringToAdd)){
			if(!removeQ(&q1, &stringToAdd)){

		// now check if LEN is specified, and if it isn't, set it to INT_MAX
			qSize1 = qSize2;
				leftToMerge1--;
	Queue q1 = NULL, q2 = NULL;
#include "/c/cs223/Hwk4/Queue.h"
								doesn't work...also seg faults in isEmptyQ
			len = INT_MAX;
					bigLeftToMerge1--;
// between consecutive merges
	Queue q1 = NULL, q2 = NULL;
	}
			DIE("removeQ failed");
			if(!addQ(&q1, stringToAdd)){
		}
				// we don't free since the queue still points to the same addr
						DIE("removeQ failed");
			if(!removeQ(&q1, &stringToAdd)){
				// if we have a tie, remove from the queue that has priority
	// we don't have to merge the last time -- just print out
				int tmp = qSize1;

u
#include <stdlib.h>
					return 1;
					return 1;
	worked between files, and it worked splendidly.
	}
				qSize1++;
			tmp = bigLeftToMerge1;

	while(2 * sizeToMerge < numElements){
	int leftToMerge1 = 1, leftToMerge2 = 1;
						return 1;
		sizeToMerge *= 2;
/*Progress report: sorts, but doesn't handle it when there's leftover between merges (i.e. when one bigleft is nonzero but the other is zero)
	FILE *inFile;
					bigLeftToMerge1--;
	*q1 = *q2;

					DIE("addQ failed");

// offset the bottom one by one. Then keep comparing heads until
		}


			}
/*Progress report: sorts, but doesn't handle it when there's leftover between merges (i.e. when one bigleft is nonzero but the other is zero)
		int tmp = qSize1;
						DIE("removeQ failed");
						return 1;
				DIE("removeQ failed");
3/9		8:45pm		1 hour		Mostly fixed the mergesort algorithm, but it
				}
		swap(&q1, &q2);
		// this probably shouldn't ever happen but i'll do this just in case
    char *value;
			tmp = bigLeftToMerge1;
			if(!removeQ(&q2, &stringToAdd)){
			if(!removeQ(&q1, &stringToAdd)){
				DIE("Invalid POS,LEN");
		firstFileArg = 2;
				qSize1 = qSize2;
typedef struct node {           
    return true;
		// if we have excess on the first queue...the other queue should be
	Queue q1 = NULL, q2 = NULL;
				// compare the two values, remove from whichever one is smaller
						printf("q1 is empty\n");
			DIE("File could not be opened!");
				// if we have a tie, remove from the queue that has priority
		// if we have excess on the first queue...the other queue should be
			}
		swap(&q1, &q2);
				if(!addQ(&q1, line)){
				qSize1++;
		while(bigLeftToMerge1 > 0 && bigLeftToMerge2 > 0){
					DIE("addQ failed");
					qSize1--;
	}

					return 1;
					DIE("removeQ failed");
	various while loops, so it took me three or four tries of redoing my code
				// now add the string to whichever queue we're currently adding to 
								and Annie Chen						
			bigLeftToMerge2--;
{

	while(!isEmptyQ(&q1)){
3/15	9:00pm		1 hour		Sorts fine, mostly stable, seems to work with PO								S,LEN
// should take at most N*log2(N) adds.
				DIE("removeQ failed");
}
		// empty

			bigLeftToMerge1--;

{
						return 1;
			}

	return 0;
			len = INT_MAX;


		// call headQ and store values into head1 and head2
						DIE("removeQ failed");
					return 1;
	}
		}
			while(leftToMerge2 > 0){
			int tmp = qSize1;
		inFile = fopen(argv[i], "r");
		bigLeftToMerge2 = qSize2;
								to stop merging
			qSize2 = tmp;


			if(!removeQ(&q2, &stringToAdd)){
	Queue dummy = *q1;
// new node to the end of the linked list whose contents is the string
	if(!createQ(&q1) || !createQ(&q2)){
					}
					return 1;

			if(!removeQ(&q1, &stringToAdd)){
								merging
		qSize2 = tmp;
					if(!removeQ(&q1, &stringToAdd)){
			}
			len = strtol(line + 1, &line, 10);
		if(!removeQ(&q1, &stringToAdd)){
	if(argv[1][0] == '-'){
			return 1;
		if(!removeQ(&q2, &stringToAdd)){
					return 1;
	// now loop through the rest of the args and read them as files


					DIE("removeQ failed");
	// we'll always add to q1, then swap each time
				qSize2 = tmp;
			while(leftToMerge1 > 0){
			}
					DIE("addQ failed");
			qSize2 = tmp;
		}
// offset the bottom one by one. Then keep comparing heads until

		printf("%s", stringToAdd);
								and	now I'm dealing with a lot of seg faults
			if(!removeQ(&q1, &stringToAdd)){
3/9		4:30pm		1 hour		It now sorts but only handles powers of 2 and is
e
		qSize1 = qSize2;
#include <limits.h>
					DIE("removeQ failed");
			DIE("File could not be opened!");
					DIE("addQ failed");
	// line1 and line2 will hold the two calls to newGetLine()
	// q1 and q2 are the two queues we're using
#include "/c/cs223/Hwk4/Queue.h"
#define DIE(msg) exit(fprintf(stderr, "%s\n", msg))
	was empty, or had another line. Then I wrote a new getLine function which
	long pos, len;
        *s = (**q).next->value;
	while(2 * sizeToMerge < numElements){

				if(strcmp(head1, head2) < 0){
			// open the file and loop through the lines
			DIE("removeQ failed");
			DIE("File could not be opened!");

	if(a < b){
	*q2 = dummy;
		if(inFile == NULL){
				qSize2--;
	if(argc == 1){
		if(line[0] == ','){
#define DIE(msg) exit(fprintf(stderr, "%s\n", msg))

		bigLeftToMerge2 = qSize2;
			while(leftToMerge2 > 0){
 				
		// if we have a tie, remove from the queue that has priority
	}
				}

				}
	bigLeftToMerge1 = qSize1;
				DIE("Invalid LEN");
				}
	Queue dummy = *q1;
				}
		qSize1 = qSize2;
						DIE("removeQ failed");
// From then on, just keep comparing heads until one of the queues is empty
					if(isEmptyQ(&q1)){
				DIE("addQ failed");
				}
// offset the bottom one by one. Then keep comparing heads until
        (*newNode).next = (**q).next;
	// if there's stuff left over from the first queue

				swap(&q1, &q2);
		free(stringToAdd);
				qSize1++;
				numElements += 2;
int main(int argc, char *argv[]){
			reversed = !reversed;
	// where we want to stop once qPos1 or qPos2 hits them (i.e. the end of a
			return 1;
				return 1;
				qSize1++;
			stopMergeIndex1 = min(stopMergeIndex1 + sizeToMerge, startSize1);
		}
		printf("size to merge bottom: %d\n", sizeToMerge);

	}
 				
	while(!isEmptyQ(&q2)){
					DIE("addQ() failed!");
	long pos, len;
#include <string.h>
				DIE("removeQ failed");
// From then on, just keep comparing heads until one of the queues is empty
				}
			return 1;
	to get a working version
		else{
		}
		}
	bigLeftToMerge2 = qSize2;
	return 0;

	Queue dummy = *q1;
    // loop through all the nodes and call removeQ() on all of them (which
		printf("size to merge bottom: %d\n", sizeToMerge);
{
		free(stringToAdd);
				qSize1++;
		swap(&q1, &q2);
		else{
	}
				}
		printf("biglefts: %d %d\n", bigLeftToMerge1, bigLeftToMerge2);
l
		stdInput = malloc(strlen(line));
				}
					if(!removeQ(&q1, &stringToAdd)){
					bigLeftToMerge1--;
		printf("size to merge bottom: %d\n", sizeToMerge);

					return 1;
	if(qSize2 > qSize1){
			return 1;
		}
// removes the first node from the queue, and makes s point to the value that
3/9		4:30pm		1 hour		It now sorts but only handles powers of 2 and is
				}
	Queue dummy = *q1;
					bigLeftToMerge1--;
	// if we have a hyphen on the first argument, we have POS
				if(strcmp(head1, head2) < 0){
#include <stdbool.h>

				DIE("removeQ failed");
int addQ (Queue *q, char *s)
			if(!removeQ(&q1, &stringToAdd)){
					bigLeftToMerge1--;
				}
#include "/c/cs223/Hwk3/getLine.h"
			while(leftToMerge2 > 0){
				}
		}
				// switch up the queues so that you split up the strings
				printf("left to merges: %d %d\n", leftToMerge1, leftToMerge2);
				if(strcmp(head1, head2) < 0){
				DIE("removeQ failed");
		}
		inFile = fopen(argv[i], "r");


					DIE("addQ failed!");

	// otherwise there's stuff left over from the second queue
				}
			int tmp = qSize1;
				DIE("addQ failed");
			while((line = getLine(inFile)) != NULL){
			qSize1++;

		printf("%s", stringToAdd);
		}
	while(!isEmptyQ(&q1)){
		int tmp = qSize1;
				DIE("removeQ failed");
					return 1;
					DIE("headQ failed");
		// call headQ and store values into head1 and head2
// offset the bottom one by one. Then keep comparing heads until
				int tmp = qSize1;
	}
		if(!headQ(&q1, &head1) || !headQ(&q2, &head2)){

			qSize2 = tmp;
    else{
					}
								most functions								
					return 1;

	// now loop through the rest of the args and read them as files
				qSize1++;
				// compare the two values, remove from whichever one is smaller
	to call getLine() twice per loop and then running a lot of cases on which
				if(!removeQ(&q1, &stringToAdd)){
		}
				printf("left to merges: %d %d\n", leftToMerge1, leftToMerge2);
// From then on, just keep comparing heads until one of the queues is empty
	}

					return 1;
		if(line[0] == ','){
			if(!addQ(&q1, stringToAdd)){
	*q1 = *q2;
void swap(Queue *arg1, Queue *arg2);
				// now add the string to whichever queue we're currently adding to 
			}
				}
					}
}

	int leftToMerge1 = 1, leftToMerge2 = 1;
				qSize1++;
}#include <stdio.h>
				}
		if(inFile == NULL){
	}
			// if there's stuff left over from the first queue
// function that takes in two ints (a and b) and returns the smaller of the two
#include "/c/cs223/Hwk3/getLine.h"
	// now loop through the rest of the args and read them as files
					if(!removeQ(&q1, &stringToAdd)){
		qSize2 = tmp;
	to call getLine() twice per loop and then running a lot of cases on which
			//free(line);
	Queue q1 = NULL, q2 = NULL;
			}
				}
	Queue q1 = NULL, q2 = NULL;
			}
			}
	// the same time
	Eventually I realized (with the help of Will) that I could read in the lines
			while(leftToMerge2 > 0){
		qSize1 = qSize2;
			qSize1 = qSize2;
			while((line = getLine(inFile)) != NULL){
				leftToMerge2--;
		printf("biglefts: %d %d\n", bigLeftToMerge1, bigLeftToMerge2);
	// we don't have to merge the last time -- just print out
	}
					leftToMerge2--;
	*q1 = *q2;
		// make sure POS is positive digits
	while(!isEmptyQ(&q2)){
		// we also want to remember the starting size of each queue
#include "/c/cs223/Hwk4/Queue.h"
				}
    // set the contents of the new node to be the string
				qSize1++;
					leftToMerge2--;

						return 1;
			return 1;
			int tmp = qSize1;
    // if there's more than one node
		pos = strtol(argv[1] + 1, &line, 10);
				if(!addQ(&q1, stringToAdd)){
	destroyQ(&q1);
					qSize1--;
			// otherwise there's stuff left over from the second queue
			}
#include <limits.h>
	// now we print out the things in the queues, doing the last merge at
		free(stringToAdd);
		if(inFile == NULL){
					}
		else{
						return 1;
{
	// make sure there's at least one argument after Merge16
				DIE("removeQ failed");
					}
					qSize1--;
	int leftToMerge1 = 1, leftToMerge2 = 1;
		if(inFile == NULL){
		bigLeftToMerge1 = qSize1;
			}
				qSize1++;
		else if(strcmp(head1, head2) > 0){
// offset the bottom one by one. Then keep comparing heads until
	if(argv[1][0] == '-'){
		}
								queues
					DIE("headQ failed");
		// we want to start comparing line1 from the lesser of POS or the size
// From then on, just keep comparing heads until one of the queues is empty
						DIE("removeQ failed");
				}
			qSize2--;
		else{
void swap(Queue *arg1, Queue *arg2);
				qSize1++;
			return 1;
	if(qSize2 > qSize1){
					}
// Function that takes in a pointer to a Queue (q) and a string (s), then adds a
			while(leftToMerge2 > 0){
				else{
		int tmp = qSize1;
} Node;
    // if there is only one node
		qSize2 = tmp;
	Queue q1 = NULL, q2 = NULL;
		int tmp = qSize1;
		// double each merge size so that we can merge adjacent sorted 
#define DIE(msg) exit(fprintf(stderr, "%s\n", msg))
		if(strcmp(head1, head2) < 0){
			}
		// if we have a tie, remove from the queue that has priority
					DIE("addQ failed");
					leftToMerge2--;
	int leftToMerge1 = 1, leftToMerge2 = 1;
		// call headQ and store values into head1 and head2

		if(!removeQ(&q1, &stringToAdd)){
}
	}
        return false;
		}
		else if(strcmp(head1, head2) > 0){
			if(!removeQ(&q1, &stringToAdd)){
						return 1;
			}
		}
					return 1;
		else if(strcmp(head1, head2) > 0){
					return 1;
			return 1;
				printf("bigLeftToMerges: %d %d\n", bigLeftToMerge1, bigLeftToMerge2);
		free(stringToAdd);
					DIE("addQ failed");
		// if there is no next line, then we just add the first line to q1
	char *line, *head1, *head2, *stringToAdd;
void swap(Queue *arg1, Queue *arg2);
			len = INT_MAX;
		while(bigLeftToMerge1 > 0 && bigLeftToMerge2 > 0){
	}
	bigLeftToMerge2 = qSize2;
					qSize1--;
			return 1;
				qSize1 = qSize2;
		}

			int tmp = qSize1;
// From then on, just keep comparing heads until one of the queues is empty
					leftToMerge1--;
		printf("biglefts: %d %d\n", bigLeftToMerge1, bigLeftToMerge2);
				// compare the two values, remove from whichever one is smaller
#include "/c/cs223/Hwk4/Queue.h"
}// hold two copies of the list in the beginning and 
		int tmp = qSize1;
			}
		else{
	// we don't have to merge the last time -- just print out

					DIE("addQ failed");
		if(!removeQ(&q2, &stringToAdd)){
				leftToMerge1--;
3/9		8:45pm		1 hour		Mostly fixed the mergesort algorithm, but it
			}
	}
	if(qSize2 > qSize1){
				else if(strcmp(head1, head2) > 0){
				qSize1++;
					if(!removeQ(&q2, &stringToAdd)){
				// now add the string to whichever queue we're currently adding to 

		}
		// this probably shouldn't ever happen but i'll do this just in case
			return 1;
	// make sure there's at least one argument after Merge16
	// now we print out the things in the queues, doing the last merge at
					return 1;
					}
				// add each line in q1
					leftToMerge2--;

				}
#include "/c/cs223/Hwk4/Queue.h"
		free(stringToAdd);
				qSize1 = qSize2;
		inFile = fopen(argv[i], "r");
			bigLeftToMerge1 = bigLeftToMerge2;
				}
		else if(strcmp(head1, head2) > 0){
	}
			leftToMerge1 = leftToMerge2 = sizeToMerge;
		qSize1 = qSize2;
	return 0;
	bigLeftToMerge2 = qSize2;

					}
					bigLeftToMerge2--;
		qSize1 = qSize2;
	while(!isEmptyQ(&q1)){

		leftToMerge1 = leftToMerge2 = sizeToMerge;
			int tmp = qSize1;
		}
		qSize2 = tmp;
	while(!isEmptyQ(&q1) && !isEmptyQ(&q2)){

	was empty, or had another line. Then I wrote a new getLine function which
			if(!removeQ(&q1, &stringToAdd)){
				if(!removeQ(&q1, &stringToAdd)){
 				
		int tmp = qSize1;
				bigLeftToMerge2--;
				// if we have a tie, remove from the queue that has priority
		leftToMerge1 = leftToMerge2 = sizeToMerge;
		while(bigLeftToMerge1 > 0 && bigLeftToMerge2 > 0){
			}
	}
				if(!addQ(&q1, line)){
				// switch up the queues so that you split up the strings

// sorts the files using Mergesort (implemented using exactly two queues),
	// we'll always add to q1, then swap each time
				}
// file names and stores the lines in two queues and mergesorts the two queues
								queues
				if(!headQ(&q1, &head1) || !headQ(&q2, &head2)){
	// otherwise there's stuff left over from the second queue
		// call headQ and store values into head1 and head2
				DIE("removeQ failed");
// Looks at the first node in the queue and makes s point to the contents of
					qSize1--;
		return 1;
			//free(line);
		}
				return 1;
				qSize1 = qSize2;
	// we'll always add to q1, then swap each time
// between consecutive merges
				bigLeftToMerge2--;
						DIE("removeQ failed");
	was empty, or had another line. Then I wrote a new getLine function which
// a file pointer (fileToRead) that we're currently reading from, and a pointer

	// now loop through the rest of the args and read them as files
void swap(Queue *q1, Queue *q2){
		bigLeftToMerge2 = qSize2;
					if(!removeQ(&q1, &stringToAdd)){
				// between the two queues
					qSize1--;
		else{
	}
			}
			if(!removeQ(&q1, &stringToAdd)){

	// make sure there's at least one argument after Merge16
    }
					bigLeftToMerge1--;
		}
			}
#include "/c/cs223/Hwk3/getLine.h"
    *s = (*nodeToRemove).value;
				// between the two queues
			while(leftToMerge1 > 0){
				}
		qSize2 = tmp;
			qSize2 = tmp;
				DIE("removeQ failed");
						DIE("removeQ failed");
			bigLeftToMerge2 = tmp;
	}
#include <stdbool.h>
		}
			bigLeftToMerge1--;
				qSize1++;
					leftToMerge1--;
			// otherwise there's stuff left over from the second queue
// Function that takes in a pointer to a queue (q) and a pointer to a string s
3/3		10:15pm		1 hour		Worked out stable mergesort algorithm using two

	// now loop through the rest of the args and read them as files
				else{
}
			swap(&q1, &q2);
					leftToMerge1--;
					DIE("addQ failed");
					DIE("addQ failed");
	// //argumentString = memset(argumentString, '\0', argLength + 1);
					if(!removeQ(&q1, &stringToAdd)){
				qSize1++;
	while(2 * sizeToMerge < numElements){
// makes them point to the other address
		if(!removeQ(&q2, &stringToAdd)){
					bigLeftToMerge2--;
				leftToMerge2--;
		swap(&q1, &q2);
					}
			if(!addQ(&q1, stringToAdd)){
// function to swap two queues (i.e. swap the pointers to the two nodes)
				return 1;

		swap(&q1, &q2);
		// call headQ and store values into head1 and head2

#include "/c/cs223/Hwk3/getLine.h"
				// switch up the queues so that you split up the strings

				if(strcmp(head1, head2) < 0){
    // set the contents of the new node to be the string
		leftToMerge1 = leftToMerge2 = sizeToMerge;
					qSize1--;
				if(!removeQ(&q1, &stringToAdd)){
			swap(&startSize1, &startSize2);
					DIE("addQ failed");
    return true;
			qSize1 = qSize2;
			bigLeftToMerge1 = bigLeftToMerge2;
		}

					}
 -- Reading in the files was initially a challenge, as I was initally planning
				qSize1++;
	call got NULL, and I had to worry about whether the next file existed, or
				DIE("removeQ failed");
	}

				DIE("removeQ failed");
		qSize2 = tmp;
	while(!isEmptyQ(&q2)){
	// the same time
		bigLeftToMerge2 = qSize2;
		swap(&q1, &q2);
		swap(&q1, &q2);
				if(!addQ(&q1, stringToAdd)){
		// this probably shouldn't ever happen but i'll do this just in case
					return 1;
		pos = strtol(argv[1] + 1, &line, 10);
	while(!isEmptyQ(&q1)){
				DIE("removeQ failed");
			while(leftToMerge1 > 0 && leftToMerge2 > 0){
		qSize1 = qSize2;
					qSize1--;
			}
					}
			while(leftToMerge1 > 0 && leftToMerge2 > 0){
		}
						return 1;
				}
			}
			len = strtol(line + 1, &line, 10);
}
				if(!addQ(&q1, stringToAdd)){
					}
	if(a < b){
	// start reading in the first file (if there is one)

			DIE("removeQ failed");
			qSize1++;
		free(stringToAdd);
					DIE("addQ failed");
			qSize1 = qSize2;
			if(!removeQ(&q2, &stringToAdd)){

		}
					DIE("removeQ failed");
				qSize1 = qSize2;
					bigLeftToMerge1--;
		else if(reversed){
 				
				DIE("removeQ failed");
				// compare the two values, remove from whichever one is smaller
				DIE("removeQ failed");
// Returns true if operation succeeded, false if it failed
			while(leftToMerge1 > 0){
				// compare the two values, remove from whichever one is smaller
			while(leftToMerge1 > 0){

						return 1;
		if(line1[lineSize1 - 1] == '\n'){
	}
				// compare the two values, remove from whichever one is smaller
				DIE("removeQ failed");
		if(inFile == NULL){
						printf("q1 is empty\n");

	// now loop through the rest of the args and read them as files
			}
			leftToMerge1 = leftToMerge2 = sizeToMerge;
	int leftToMerge1 = 1, leftToMerge2 = 1;
		}
			qSize1 = qSize2;
		DIE("createQ() failed!");
						DIE("removeQ failed");
		// if we have a tie, remove from the queue that has priority
	if(argv[1][0] == '-'){
    char *dummyS;
		}
			}
}// hold two copies of the list in the beginning and 
		qPos1 = qPos2 = 0;
				}
			}
				DIE("removeQ failed");
	// if there's stuff left over from the first queue
	// now we print out the things in the queues, doing the last merge at


	// start reading in the first file (if there is one)
			while((line = getLine(inFile)) != NULL){
			leftToMerge1 = leftToMerge2 = sizeToMerge;
	// the lines (either pos or the length of the string)
			if(line1[0] != '\0'){
	// q1 will always have the same or one more element than q2
			len = strtol(line + 1, &line, 10);
}#include <stdio.h>
		if(!headQ(&q1, &head1) || !headQ(&q2, &head2)){
		}
				bigLeftToMerge1--;
		}

				qSize2--;
ESTIMATE of total time I will spend: 16 hours
					DIE("addQ() failed!");

				// we don't free since the queue still points to the same addr
				if(!removeQ(&q2, &stringToAdd)){
			swap(&stopMergeIndex2, &stopMergeIndex1);
			}
						DIE("removeQ failed");
			bigLeftToMerge1--;
        return false;
// Node struct will be used for each node in the linked list.
	while(!isEmptyQ(&q2)){
					if(!removeQ(&q2, &stringToAdd)){
					return 1;
w
	}

			if(!addQ(&q1, stringToAdd)){
		DIE("File could not be opened!");
				// so we have to check whether the queues are reversed
				DIE("removeQ failed");
				return 1;
				else{
				if(qPos1 == startSize1 || qPos2 == startSize2){
	// line1 and line2 will hold the two calls to newGetLine()
				}
	while(2 * sizeToMerge < numElements){
					DIE("headQ failed");
		// compare the two values, remove from whichever one is smaller
	// now we print out the things in the queues, doing the last merge at
				leftToMerge1--;

				DIE("removeQ failed");
				if(!addQ(&q1, line)){
						return 1;
				if(!removeQ(&q1, &stringToAdd)){
			// if there's stuff left over from the first queue
		}
		fullCommand = strcpy(fullCommand, echo);
			bigLeftToMerge2--;
	// q1 will always have the same or one more element than q2
					DIE("addQ() failed!");
			bigLeftToMerge1 = bigLeftToMerge2;

					return 1;
					DIE("addQ failed");
				}
			fullCommand = strcat(fullCommand, argv[i]);

*/
			swap(&q1, &q2);

	int fullLength, argLength, test;
			bigLeftToMerge2 = tmp;
void swap(Queue *arg1, Queue *arg2);
3/10	9:30pm		.5 hours	Debugged, but now it infinite loops instead of
				}
				// if we have a tie, remove from the queue that has priority
	if(argv[1][0] == '-'){
    return true;
			qSize2 = tmp;
	// now we can finally start mergesorting!
				// call headQ and store values into head1 and head2
					if(!removeQ(&q1, &stringToAdd)){
				DIE("removeQ failed");
					qSize1--;
				// switch up the queues so that you split up the strings

		//printf("%s\n", fullCommand);
		// compare the two values, remove from whichever one is smaller
// main function...goes through each of the arguments and interprets them as
					if(!removeQ(&q1, &stringToAdd)){
// From then on, just keep comparing heads until one of the queues is empty
3/9		7:30pm		1 hour		Sorts a little bit better but somehow breaks
	}
void swap(Queue *arg1, Queue *arg2);
		return 1;
/*Progress report: sorts, but doesn't handle it when there's leftover between merges (i.e. when one bigleft is nonzero but the other is zero)
				DIE("removeQ failed");
				printf("two heads are %s %s\n", head1, head2);
		}
	while(!isEmptyQ(&q1) && !isEmptyQ(&q2)){
			while(qPos1 < stopMergeIndex1){
				int tmp = qSize1;
					DIE("addQ failed");
					DIE("addQ failed");
				numElements++;
		// record the offset where we want to start comparing (again, either 
	// now we can finally start mergesorting!
						DIE("removeQ failed");
}
		printf("%s", stringToAdd);
			}
	}
					}
		return 1;

		// this probably shouldn't ever happen but i'll do this just in case
        (*newNode).next = newNode;
	}
	// we don't have to merge the last time -- just print out
					return 1;
// The internal representation of a Queue is a headless, singly-linked,
				// update the size each time, again incrementing by two
		pos = strtol(argv[1] + 1, &line, 10);
				DIE("addQ failed");
	}
			bigLeftToMerge1--;

// From then on, just keep comparing heads until one of the queues is empty

			bigLeftToMerge1--;
		bigLeftToMerge1 = qSize1;

					qSize2--;
	}

					if(!removeQ(&q1, &stringToAdd)){
}// hold two copies of the list in the beginning and 
					}
				if(!addQ(&q1, line)){
				DIE("addQ failed");
#include "/c/cs223/Hwk3/getLine.h"
						return 1;
			while(leftToMerge2 > 0){
	}
				qSize1 = qSize2;
			}
				bigLeftToMerge1--;

					}
				DIE("removeQ failed");
			}
				DIE("addQ failed");
	// loop through all of the files and read in their lines
#include <stdio.h>
	// if we have a hyphen on the first argument, we have POS
		while(bigLeftToMerge2 > 0){
					qSize2--;
				// switch up the queues so that you split up the strings
				DIE("removeQ failed");

		printf("%s", stringToAdd);
			}
	int firstFileArg = 1, sizeToMerge = 1, numElements = 0;
				qSize1++;
	if(!createQ(&q1) || !createQ(&q2)){
				if(!removeQ(&q1, &stringToAdd)){
			}
#include <stdlib.h>
				DIE("removeQ failed");
	char *subst16Command = " | /c/cs223/Hwk3/Merge16", *echo = "echo ";
				printf("size we're merging: %d\n", sizeToMerge);
		}
			DIE("removeQ failed");
						DIE("removeQ failed");
		}
	while(2 * sizeToMerge < numElements){
		}
2/29	4:00pm		1 hour		Discussed problem statement with Jared Weinstein
		// if we have excess on the first queue...the other queue should be
				int tmp = qSize1;
				swap(&q1, &q2);
// function to swap two queues (i.e. swap the pointers to the two nodes)
					bigLeftToMerge1--;
 -- Implementing the mergesort was also very difficult. The algorithm involved
				// keep updating size and position
3/8		3:00pm		1 hour		Finished implementing all of mergesort but it
		swapQueues(&q1, &q2);
		// compare the two values, remove from whichever one is smaller
    if((**q).next == *q){
				// if we have a tie, remove from the queue that has priority

			if(!addQ(&q1, stringToAdd)){

	// sub-merge or the end of the queue)
	char *line, *head1, *head2, *stringToAdd;
		// compare the two values, remove from whichever one is smaller
		if(!removeQ(&q1, &stringToAdd)){
					}
	}
	while(!isEmptyQ(&q1) && !isEmptyQ(&q2)){
				swap(&q1, &q2);
	while(!isEmptyQ(&q1) && !isEmptyQ(&q2)){
	// now loop through the rest of the args and read them as files
// Returns true if operation succeeded, false if it failed
					DIE("addQ failed");
	// now loop through the rest of the args and read them as files
	// includes the space before each argument
				// switch up the queues so that you split up the strings
				// if we have a tie, remove from the queue that has priority
		return 1;
				if(qPos1 == startSize1 || qPos2 == startSize2){

	}
			bigLeftToMerge1--;
				}
		if(strcmp(head1, head2) < 0){
#define DIE(msg) exit(fprintf(stderr, "%s\n", msg))
	addQ()s, as the one that I originally had workd in N ceil(Log(N)).
#include <string.h>
				}
		return 1;
		free(stringToAdd);
			if(line1[0] != '\0'){
						return 1;
	int offset1, offset2;
		qSize1 = qSize2;
				swap(&q1, &q2);
	// the same time
		printf("%s", stringToAdd);
			swapQueues(&q1, &q2);
			int tmp = qSize1;
				if(!addQ(&q1, stringToAdd)){

					DIE("headQ failed");
	int qSize1 = 0, qSize2 = 0, bigLeftToMerge2, bigLeftToMerge1;
				// add each line in q1
			while(leftToMerge1 > 0 && leftToMerge2 > 0){
		}
#include <string.h>
	while(2 * sizeToMerge < numElements){
{
			}
	// the same time
				}
 				
----	-----		----		-----
		DIE("createQ() failed!");
    // if there is only one node
	}
    // if there's no node to remove, return false
			bigLeftToMerge1--;
		if(!removeQ(&q1, &stringToAdd)){
	Eventually I realized (with the help of Will) that I could read in the lines
					}
// you finish the first merging, alternating which queue you push to
					bigLeftToMerge1--;
				DIE("addQ failed");
		if(!headQ(&q1, &head1) || !headQ(&q2, &head2)){
		free(stringToAdd);
		swap(&q1, &q2);
				if(!addQ(&q1, stringToAdd)){
					bigLeftToMerge2--;
3/9		9:45pm 		1 hour		Identified a few bugs, trying to fix them
	if(!createQ(&q1) || !createQ(&q2)){
		}
	// inFile is a pointer to the file we're reading in
#include <stdbool.h>
					bigLeftToMerge1--;
	}
		if(!removeQ(&q2, &stringToAdd)){
		}
	// we'll always add to q1, then swap each time
		sizeToMerge *= 2;
				}
    }
		if(argv[1][1] < '0' || argv[1][1] > '9'){
				leftToMerge2--;
// should take at most N*log2(N) adds.
					DIE("addQ failed");
		argLength += (test + 1);
			if(!addQ(&q1, stringToAdd)){
#include "/c/cs223/Hwk4/Queue.h"
		// order
				qSize1++;
}
		pos = strtol(argv[1] + 1, &line1, 10);
    else{
		return 1;
					if(!removeQ(&q2, &stringToAdd)){
		else{
		}
		if(line1[0] == ','){
		}
		leftToMerge1 = leftToMerge2 = sizeToMerge;

				}

				}
/*Progress report: sorts, but doesn't handle it when there's leftover between merges (i.e. when one bigleft is nonzero but the other is zero)
				}
				else{
					}
		leftToMerge1 = leftToMerge2 = sizeToMerge;
			DIE("removeQ failed");
				qSize2--;

				qSize1 = qSize2;
		// we also want to remember the starting size of each queue
					if(!removeQ(&q2, &stringToAdd)){

	int leftToMerge1 = 1, leftToMerge2 = 1;

	if((line1 = getLine(*fileToRead)) == NULL){
				swap(&q1, &q2);
		int tmp = qSize1;
			while(leftToMerge2 > 0){
		}
#include "/c/cs223/Hwk3/getLine.h"
		int tmp = qSize1;

					if(!removeQ(&q1, &stringToAdd)){
#include "/c/cs223/Hwk4/Queue.h"
	}
3/10	9:30pm		.5 hours	Debugged, but now it infinite loops instead of

void swap(Queue *q1, Queue *q2){
				}
				if(!addQ(&q1, stringToAdd)){
					qSize2--;
	}
	}
			}
				printf("size we're merging: %d\n", sizeToMerge);
		}
				if(!addQ(&q1, stringToAdd)){
		printf("biglefts: %d %d\n", bigLeftToMerge1, bigLeftToMerge2);
				return 1;
		}
			bigLeftToMerge2 = tmp;
			if(!addQ(&q1, stringToAdd)){
						DIE("removeQ failed");
    // if there's more than one node
		printf("%s", stringToAdd);
						return 1;
					return 1;

Date	Start		Time		Notes
			bigLeftToMerge2 = tmp;
					leftToMerge1--;
			DIE("removeQ failed");
		qSize2 = tmp;
			// if there's stuff left over from the first queue
				else if(strcmp(head1, head2) > 0){
				qSize2 = tmp;
			return 1;
	}
		}
					bigLeftToMerge2--;
			qSize2 = tmp;
					qSize1--;
	// if we have a hyphen on the first argument, we have POS
	// q1 will always have the same or one more element than q2
					qSize1--;
		swap(&q1, &q2);
} Node;

		if(!headQ(&q1, &head1) || !headQ(&q2, &head2)){
			// if there's stuff left over from the first queue
// Function that takes in a pointer to a queue (q) and destroys it, freeing all
		else{
		DIE("createQ() failed!");
	// if there's stuff left over from the first queue
					return 1;

				return 1;
		fullCommand = malloc(fullLength);

	keeping track of a lot of indices, pointers, and so on, all within
	destroyQ(&q1);
// and prints out the sorted lines
			}
				swap(&q1, &q2);
				// between the two queues
{
		}
				qSize1++;
	if(argv[1][0] == '-'){
// From then on, just keep comparing heads until one of the queues is empty

			bigLeftToMerge2--;
			}
				if(!addQ(&q1, line)){
				DIE("removeQ failed");
	keeping track of a lot of indices, pointers, and so on, all within
	// size of each subQueue we're merging, numElements is total number of 
			if(line1[0] != '\0'){
		swap(&q1, &q2);
				leftToMerge1--;

					DIE("headQ failed");
				// add each line in q1
			if(!removeQ(&q2, &stringToAdd)){
#include "/c/cs223/Hwk4/Queue.h"
	addQ()s, as the one that I originally had workd in N ceil(Log(N)).
m

				if(strcmp(head1, head2) < 0){
				}
			bigLeftToMerge1--;
		}
#define DIE(msg) exit(fprintf(stderr, "%s\n", msg))
					return 1;
		// now check if LEN is specified, and if it isn't, set it to INT_MAX
				return 1;
								and	now I'm dealing with a lot of seg faults
			qSize2--;
			DIE("removeQ failed");
								and Annie Chen						
					}
			}

			if(!addQ(&q1, stringToAdd)){
	while(!isEmptyQ(&q1)){
		leftToMerge1 = leftToMerge2 = sizeToMerge;
	if(argc == 1){
			if(!addQ(&q1, stringToAdd)){
				qSize1++;
			// onto as well as the respective indices and positions
#include <string.h>
3/15	8:00pm		1 hour		Now it sorts! Working on incorporating pos,len,
		// if fopen throws an error

		// keep looping through
 -- Getting the algorithm for two-queue mergesort was difficult to begin with.
			DIE("removeQ failed");
			if(!removeQ(&q2, &stringToAdd)){
		// if we have excess on the first queue...the other queue should be
			}
	// we'll always add to q1, then swap each time

	}
	// if we have a hyphen on the first argument, we have POS
}// hold two copies of the list in the beginning and 
    // if there is only one node
		free(stringToAdd);
		free(stringToAdd);
}// Queue.c by Dennis Duan
	if(argv[1][0] == '-'){
			}
					leftToMerge1--;
			// with an empty list)
					bigLeftToMerge1--;
#define DIE(msg) exit(fprintf(stderr, "%s\n", msg))
// Node struct will be used for each node in the linked list.
		free(fullCommand);
				numElements++;
void swap(Queue *q1, Queue *q2){
		if(line[0] == ','){
	// q1 will always have the same or one more element than q2

		reversed = !reversed;
				// call headQ and store values into head1 and head2

			DIE("removeQ failed");
		free(stringToAdd);
				}
				else{
			DIE("removeQ failed");
				qPos2++;
					leftToMerge1--;
        free(nodeToRemove);
			}
			if(!addQ(&q1, stringToAdd)){
#include <stdbool.h>
					return 1;
			if(!removeQ(&q1, &stringToAdd)){
// function to swap two queues (i.e. swap the pointers to the two nodes)
	}
		}
	*q2 = dummy;

				}
						return 1;
	// stringToAdd will point to the string that is smaller when comparing
    Queue temp = NULL;
// Returns true if operation succeeded, false if it failed
				DIE("removeQ failed");
}
			bigLeftToMerge1 = bigLeftToMerge2;
		bigLeftToMerge1 = qSize1;
				// we don't free since the queue still points to the same addr
	char *line, *head1, *head2, *stringToAdd;
			tmp = bigLeftToMerge1;
		swap(&q1, &q2);
	// if we've had an odd number of swaps, swap again to keep q1 as priority
People I consulted with: Jared Weinstein, Annie Chen, Will Merrill
						DIE("removeQ failed");

			len = INT_MAX;
					return 1;
3/10	9:30pm		.5 hours	Debugged, but now it infinite loops instead of
3/10	9:30pm		.5 hours	Debugged, but now it infinite loops instead of
				}
						return 1;
			qSize2 = tmp;

void swapQueues(Queue *arg1, Queue *arg2);
    if((**q).next == *q){
				DIE("removeQ failed");

		fclose(*fileToRead);
		}
					DIE("addQ failed!");
				printf("bigLeftToMerges: %d %d\n", bigLeftToMerge1, bigLeftToMerge2);
#include <stdbool.h>
#include <stdlib.h>
				}


// between consecutive merges
			if(!removeQ(&q1, &stringToAdd)){

		if(!headQ(&q1, &head1) || !headQ(&q2, &head2)){
				if(!headQ(&q1, &head1) || !headQ(&q2, &head2)){
		printf("%s", stringToAdd);
					DIE("removeQ failed");
			DIE("File could not be opened!");
	}
		// if fopen throws an error
		}
	bigLeftToMerge1 = qSize1;
				// add each line in q1
					if(!removeQ(&q1, &stringToAdd)){
	if(argc == 1){
	*q1 = *q2;
void swap(Queue *arg1, Queue *arg2);
		// keep looping through

				// alternate which queue we add to) 
			return 1;

			bigLeftToMerge2--;
		// call headQ and store values into head1 and head2
		startSize1 = qSize1;
					if(!removeQ(&q2, &stringToAdd)){
					leftToMerge1--;
				qSize1++;
					if(!removeQ(&q2, &stringToAdd)){
	if(inFile == NULL){
v
				DIE("addQ failed");
			DIE("removeQ failed");
			tmp = bigLeftToMerge1;
				// now add the string to q1 (since we swap pointers, this will
int main(int argc, char *argv[]){
				}
					DIE("headQ failed");
	if(argv[1][0] == '-'){

	if(qSize2 > qSize1){
			qSize1++;
    (*newNode).value = s;
	if(argv[1][0] == '-'){
	long pos, len;
					return 1;
				}
	// are the indices in the merge that we've been through

	}
					}

	// make sure there's at least one argument after Merge16
			while(leftToMerge1 > 0 && leftToMerge2 > 0){
				qSize1++;
		free(stringToAdd);
	// q1 will always have the same or one more element than q2
				// we don't free since the queue still points to the same addr
// function to swap two queues (i.e. swap the pointers to the two nodes)
	// we don't have to merge the last time -- just print out
    }
		if(inFile == NULL){
								doesn't work for big files
			while(leftToMerge1 > 0 && leftToMerge2 > 0){
	while((line = getLine(stdin)) != NULL){
		if(strcmp(head1, head2) < 0){
	// 	argumentString = strcat(argumentString, argv[i]);
					bigLeftToMerge1--;
			return 1;
	}
----	-----		----		-----
			DIE("removeQ failed");
					DIE("addQ failed");
					return 1;
				}
				if(strcmp(head1, head2) < 0){
TOTAL time spent: 14.5 hours
					DIE("addQ failed");
		pos = strtol(argv[1] + 1, &line, 10);
				DIE("removeQ failed");
		// if fopen throws an error
			qSize2 = tmp;
						return 1;
			tmp = bigLeftToMerge1;
			len = strtol(line + 1, &line, 10);
				}
		// if we have a tie, remove from the queue that has priority
			DIE("removeQ failed");
	inFile = fopen(argv[fileArg], "r");
			// with an empty list)
#include "/c/cs223/Hwk3/getLine.h"
			if(!removeQ(&q2, &stringToAdd)){
			if(!addQ(&q1, stringToAdd)){
		// this probably shouldn't ever happen but i'll do this just in case
		pos = strtol(argv[1] + 1, &line, 10);
		if(strcmp(head1, head2) < 0){
				qSize1 = qSize2;
	bigLeftToMerge2 = qSize2;
			// do line+1 to make sure we don't include the comma
				bigLeftToMerge1--;
3/9		4:30pm		1 hour		It now sorts but only handles powers of 2 and is
		free(stringToAdd);
		}
					return 1;
		// compare the two values, remove from whichever one is smaller
			}
					if(!removeQ(&q1, &stringToAdd)){

			bigLeftToMerge2 = tmp;
#include "/c/cs223/Hwk4/Queue.h"
			int tmp = qSize1;
				qSize1 = qSize2;
			if(!addQ(&q1, stringToAdd)){

			swapQueues(&q1, &q2);
				qSize1++;
		bigLeftToMerge2 = qSize2;
// between consecutive merges
	while(2 * sizeToMerge < numElements){
				// call headQ and store values into head1 and head2
					qPos1++;
					leftToMerge1--;
	while(!isEmptyQ(&q1)){
		inFile = fopen(argv[i], "r");
	// the same time

			// otherwise there's stuff left over from the second queue
		}
					DIE("addQ failed");
		free(stringToAdd);
		}
// offset the bottom one by one. Then keep comparing heads until
				qSize1++;
		if(!headQ(&q1, &head1) || !headQ(&q2, &head2)){

				}
			}
		qSize2 = tmp;
				printf("two heads are %s %s\n", head1, head2);
			swap(&q1, &q2);
				DIE("addQ failed");

	to call getLine() twice per loop and then running a lot of cases on which
					qPos1++;
			while((line = getLine(inFile)) != NULL){
				DIE("removeQ failed");
		// compare the two values, remove from whichever one is smaller
	}
					DIE("addQ failed");
				// if we have a tie, remove from the queue that has priority

#include <stdlib.h>
					leftToMerge1--;
					qSize1--;
	// now loop through the rest of the args and read them as files
						return 1;
		// now check if LEN is specified, and if it isn't, set it to INT_MAX
			}
		// this probably shouldn't ever happen but i'll do this just in case
					DIE("addQ failed");
				qSize2 = tmp;
			}
	destroyQ(&q1);
		}
		}
		}
				qSize2--;
						return 1;
			return 1;
			len = strtol(line + 1, &line, 10);
	}
void swap(int *a, int *b){

				// switch up the queues so that you split up the strings
						DIE("removeQ failed");
	for(int i = firstFileArg; i < argc; i++){
// between consecutive merges
					if(isEmptyQ(&q1)){
			qSize1 = qSize2;
		firstFileArg = 2;
				return 1;
				}
	// the same time
		// otherwise, DIE
			bigLeftToMerge1--;
		}
				DIE("removeQ failed");
		printf("%s", stringToAdd);
// Function that takes in a pointer to a Queue (q) and a string (s), then adds a
					bigLeftToMerge1--;
					DIE("removeQ failed");
					}
					return 1;
// whether queue is empty
	int firstFileArg = 1, sizeToMerge = 1, numElements = 0;
			swap(&q1, &q2);
	bigLeftToMerge1 = qSize1;
// offset the bottom one by one. Then keep comparing heads until
		}
	// includes the space before each argument
				if(!addQ(&q1, stringToAdd)){
		// now we've finished the merging -- now some housekeeping
		firstFileArg = 2;
	bigLeftToMerge1 = qSize1;
				if(!addQ(&q1, stringToAdd)){
3/9		9:45pm 		1 hour		Identified a few bugs, trying to fix them
		printf("%s", stringToAdd);

			len = strtol(line + 1, &line, 10);
3/9		9:45pm 		1 hour		Identified a few bugs, trying to fix them
#include <stdbool.h>
				leftToMerge2--;
				DIE("removeQ failed");
			// otherwise there's stuff left over from the second queue
		offset1 = min(pos, strlen(head1));
		// call headQ and store values into head1 and head2
					bigLeftToMerge1--;
		else if(line1[0] == '\0'){
				}
    }

		printf("biglefts: %d %d\n", bigLeftToMerge1, bigLeftToMerge2);
			}
		printf("size to merge bottom: %d\n", sizeToMerge);
3/20	9:30pm		1 hour		I think this works! Redid it to use another
		if(line[0] == ','){
		// call headQ and store values into head1 and head2
			bigLeftToMerge1--;
		else{
		}
	}
	bigLeftToMerge2 = qSize2;
		}
				DIE("addQ failed");
	// q1 will always have the same or one more element than q2
		if(!headQ(&q1, &head1) || !headQ(&q2, &head2)){
	}
					DIE("addQ failed!");
				}
		qSize1 = qSize2;
				}
	// now we print out the things in the queues, doing the last merge at
		sizeToMerge *= 2;
	}
								queue
#include <string.h>
	was empty, or had another line. Then I wrote a new getLine function which

			if(!removeQ(&q1, &stringToAdd)){
					bigLeftToMerge1--;
		return 1;

		swap(&q1, &q2);

int main(int argc, char *argv[]){
					DIE("addQ() failed!");
			while(leftToMerge1 > 0 && leftToMerge2 > 0){
		}
					if(isEmptyQ(&q1)){
		DIE("createQ() failed!");
				if(!addQ(&q1, line)){
			return 1;
		if(!headQ(&q1, &head1) || !headQ(&q2, &head2)){
{
	}
		DIE("createQ() failed!");
				}
				DIE("removeQ failed");
			}
		bigLeftToMerge2 = qSize2;
// prototyping some helper functions (descriptions at the function definition)
	while(!isEmptyQ(&q1)){
	while(!isEmptyQ(&q2)){
			while((line = getLine(inFile)) != NULL){
				DIE("addQ failed");

	for(int i = firstFileArg; i < argc; i++){
    // by pointing it to the first node and making the previous node point to it
	addQ()s, as the one that I originally had workd in N ceil(Log(N)).
				leftToMerge2--;
	// if we've had an odd number of swaps, swap again to keep q1 as priority
	}
	// if there's stuff left over from the first queue
 -- Reading in the files was initially a challenge, as I was initally planning
				numElements++;
		free(stringToAdd);
				DIE("removeQ failed");
	}
				}
				// if we have a tie, remove from the queue that has priority
					DIE("addQ() failed!");
    *s = (*nodeToRemove).value;
		DIE("createQ() failed!");
				}

					DIE("addQ failed");
// The internal representation of a Queue is a headless, singly-linked,
				printf("left to merges: %d %d\n", leftToMerge1, leftToMerge2);
		}

#include <limits.h>
		}
ESTIMATE of total time I will spend: 16 hours
		free(stringToAdd);
			if(!removeQ(&q2, &stringToAdd)){
		if(strncmp(head1 + offset1, head2 + offset2, len) < 0){
	// reversed is true if the queues are reversed (i.e. if q2 points to the
			}
		}
			// make sure LEN is nonempty positive digits
		free(stringToAdd);
	int qSize1 = 0, qSize2 = 0, bigLeftToMerge2, bigLeftToMerge1;
				if(!removeQ(&q2, &stringToAdd)){

				if(!removeQ(&q1, &stringToAdd)){
	if(argc == 1){
	}
								doesn't work...also seg faults in isEmptyQ
			// this loop checks whether we've reached the end of a sub-merge
			// if there's stuff left over from the first queue

// This program takes in the names of one or more files, reads all the lines,
	// q1 will always have the same or one more element than q2
	for(int i = firstFileArg; i < argc; i++){
	if(qSize2 > qSize1){
    }
		while(bigLeftToMerge1 > 0 && bigLeftToMerge2 > 0){
					DIE("removeQ failed");
				printf("two heads are %s %s\n", head1, head2);

#include "/c/cs223/Hwk3/getLine.h"
			tmp = bigLeftToMerge1;
				qSize1 = qSize2;
	if(argc == 1){
// (next) to the next node in the linked list
				}
	inFile = fopen(argv[fileArg], "r");
				}

*/
				qSize1++;
3/7		4:00pm		.5 hours	Started implementation of mergesort, didn't get
				}

}
        free(*q);
		}
	int qSize1 = 0, qSize2 = 0, bigLeftToMerge2, bigLeftToMerge1;
	char *line, *head1, *head2, *stringToAdd;
			}
		}
#include "/c/cs223/Hwk3/getLine.h"
	// q1 will always have the same or one more element than q2
// should take at most N*log2(N) adds.
    Node *nodeToRemove = (**q).next;
	// we'll always add to q1, then swap each time
// should take at most N*log2(N) adds.
				else if(strcmp(head1, head2) > 0){
		if(!removeQ(&q1, &stringToAdd)){

			if(!removeQ(&q2, &stringToAdd)){
int main(int argc, char *argv[]){
	// head1 and head2 will point to the results of headQ() on the two queues
#include <stdbool.h>
			DIE("removeQ failed");

		swap(&q1, &q2);
			leftToMerge1 = leftToMerge2 = sizeToMerge;
#include "/c/cs223/Hwk4/Queue.h"
	Queue dummy = *q1;
			swap(&q1, &q2);
			if(!removeQ(&q1, &stringToAdd)){
			}
				DIE("removeQ failed");
	// we'll always add to q1, then swap each time
	}
	// now loop through the rest of the args and read them as files
			bigLeftToMerge1 = bigLeftToMerge2;
	bigLeftToMerge2 = qSize2;
				leftToMerge2--;
					DIE("addQ failed");
				return 1;
		// compare the two values, remove from whichever one is smaller
3/9		9:45pm 		1 hour		Identified a few bugs, trying to fix them


					}
				leftToMerge2--;
				// if we hit the end of the queue we're merging, stop
				printf("left to merges: %d %d\n", leftToMerge1, leftToMerge2);
					return 1;
}
		printf("biglefts: %d %d\n", bigLeftToMerge1, bigLeftToMerge2);
			}
			while(leftToMerge2 > 0){

		qSize1 = qSize2;
				leftToMerge1--;
// Function that takes in a pointer to a queue (q) and a pointer to a string s
	}
			// otherwise there's stuff left over from the second queue
				leftToMerge2--;
		}
		// this probably shouldn't ever happen but i'll do this just in case
					qPos1++;
			}
				// between the two queues
						return 1;
	// now loop through the rest of the args and read them as files
						return 1;
			return 1;
					bigLeftToMerge1--;

		else{
		// empty
	for(int i = firstFileArg; i < argc; i++){
					bigLeftToMerge2--;
		else{

			if(!addQ(&q1, stringToAdd)){
	Queue dummy = *q1;
						return 1;
		argLength += (test + 1);
					return 1;
						DIE("removeQ failed");
				}

				printf("bigLeftToMerges: %d %d\n", bigLeftToMerge1, bigLeftToMerge2);
		free(stringToAdd);
		// if we have a tie, remove from the queue that has priority
	// stopMergeIndex1 and stopMergeIndex2 are the indices which mark the place
// The internal representation of a Queue is a headless, singly-linked,


		printf("size to merge bottom: %d\n", sizeToMerge);
				numElements += 2;
			//free(line);
					return 1;
int main(int argc, char *argv[]){
		free(stringToAdd);
		// if we have excess on the first queue...the other queue should be
				if(!removeQ(&q1, &stringToAdd)){


		}
			return 1;
#include "/c/cs223/Hwk4/Queue.h"
					return 1;


		leftToMerge1 = leftToMerge2 = sizeToMerge;

		else{
	int leftToMerge1 = 1, leftToMerge2 = 1;
*/
			qSize2--;
				DIE("removeQ failed");
					if(!removeQ(&q1, &stringToAdd)){
		qSize1 = qSize2;
			qSize2--;
		}
		// if fopen throws an error
			// open the file and loop through the lines


	various while loops, so it took me three or four tries of redoing my code
			//free(line);
}
		// this probably shouldn't ever happen but i'll do this just in case
			//free(line);
					bigLeftToMerge1--;
	if(qSize2 > qSize1){
			if(!removeQ(&q1, &stringToAdd)){
			bigLeftToMerge2 = tmp;
	// if there's stuff left over from the first queue
		// recursive call on the new file
		// now we've finished the merging -- now some housekeeping
						printf("q1 is empty\n");
	int qSize1 = 0, qSize2 = 0, bigLeftToMerge2, bigLeftToMerge1;
	}
*/
	while(!isEmptyQ(&q1)){
				}
3/3		10:15pm		1 hour		Worked out stable mergesort algorithm using two
		while(bigLeftToMerge2 > 0){
	bigLeftToMerge1 = qSize1;
#include <limits.h>
		if(!headQ(&q1, &head1) || !headQ(&q2, &head2)){
				// switch up the queues so that you split up the strings
		//stdInput[strlen(line) - 1] = '\0';
{
	// if we have a hyphen on the first argument, we have POS
				qSize2 = tmp;
			if(!removeQ(&q2, &stringToAdd)){
			bigLeftToMerge1--;
		// empty
		printf("%s", stringToAdd);
		printf("%s", stringToAdd);
				// compare the two values, remove from whichever one is smaller
		if(inFile == NULL){
			reversed = !reversed;
			}
				// we don't free since the queue still points to the same addr
			bigLeftToMerge1 = bigLeftToMerge2;
				if(strcmp(head1, head2) < 0){
		bigLeftToMerge2 = qSize2;
		if(line1[0] == ','){
3/7		4:00pm		.5 hours	Started implementation of mergesort, didn't get

				if(!addQ(&q1, line)){
		while(bigLeftToMerge2 > 0){
		else{
	// now loop through the rest of the args and read them as files
		if(inFile == NULL){
				qSize1++;
			// if there's stuff left over from the first queue, just keep 
	*q1 = *q2;
	destroyQ(&q2);
				if(!removeQ(&q1, &stringToAdd)){
		qSize2 = tmp;
			len = INT_MAX;
		sizeToMerge *= 2;
			}
				qSize2 = tmp;

// Looks at the first node in the queue and makes s point to the contents of
#include <stdlib.h>
	}
		swap(&q1, &q2);
		}
		if(!removeQ(&q1, &stringToAdd)){

			}
	while(!isEmptyQ(&q1) && !isEmptyQ(&q2)){
			return 1;
		printf("biglefts: %d %d\n", bigLeftToMerge1, bigLeftToMerge2);
				DIE("removeQ failed");
				// now add the string to whichever queue we're currently adding to 
			if(!removeQ(&q1, &stringToAdd)){
				}
		qSize1 = qSize2;
			// open the file and loop through the lines

				}
			if(!removeQ(&q2, &stringToAdd)){
	}
	// if there's stuff left over from q1, print the rest of q1 and free each
			DIE("removeQ failed");
			if(!removeQ(&q2, &stringToAdd)){
	*q2 = dummy;
	Queue dummy = *q1;

				if(!addQ(&q1, line)){
	bigLeftToMerge2 = qSize2;
			// if there's stuff left over from the first queue
			DIE("removeQ failed");
			swap(&qPos1, &qPos2);
	// lines
					bigLeftToMerge1--;
			//free(line);
// you finish the first merging, alternating which queue you push to


	// otherwise there's stuff left over from the second queue
		printf("%s", stringToAdd);
		bigLeftToMerge1 = qSize1;
// removes the first node from the queue, and makes s point to the value that
		stdInput = strncpy(stdInput, line, strlen(line) - 1);
		qSize1 = qSize2;
			len = INT_MAX;
		if(inFile == NULL){
		// various indices)
		else if(reversed){
			fullCommand = strcat(fullCommand, " ");
		bigLeftToMerge2 = qSize2;

	while(!isEmptyQ(&q1)){
				return 1;
		swap(&q1, &q2);
		// otherwise, open the new file, update the file pointer and return the
				qSize2--;
	Queue q1 = NULL, q2 = NULL;
		// read in the next line for line2
	return 0;
			int tmp = qSize1;
		DIE("createQ() failed!");
				// now add the string to whichever queue we're currently adding to 

					DIE("addQ() failed!");
					DIE("addQ() failed!");
						return 1;

					if(isEmptyQ(&q1)){
		}
			qSize2 = tmp;
People I consulted with: Jared Weinstein, Annie Chen, Will Merrill
				if(!addQ(&q1, stringToAdd)){
	FILE *inFile;
		}
			len = strtol(line + 1, &line, 10);
				}

int main(int argc, char *argv[]){
					return 1;
	int offset1, offset2;
			stopMergeIndex1 = min(stopMergeIndex1 + sizeToMerge, startSize1);
		// now we've finished the merging -- now some housekeeping

						return 1;
		qSize2 = tmp;
				printf("bigLeftToMerges: %d %d\n", bigLeftToMerge1, bigLeftToMerge2);
// The struct contains a string (value) for the contents of a node and a pointer
    else{
				qSize1++;
	destroyQ(&q1);
		}
	if(argv[1][0] == '-'){
}
			if(!removeQ(&q2, &stringToAdd)){
	}
	// if we have a hyphen on the first argument, we have POS
					return 1;
				// call headQ and store values into head1 and head2
			swap(&q1, &q2);
				// if we have a tie, remove from the queue that has priority
		leftToMerge1 = leftToMerge2 = sizeToMerge;
		}
		printf("%s", stringToAdd);
				if(!addQ(&q1, stringToAdd)){
// the node
				if(!addQ(&q1, stringToAdd)){
				// now add the string to whichever queue we're currently adding to 
		else{
				if(!addQ(&q1, line)){
    return true;
// function to replace getLine. Takes in a pointer to argv, argc, a pointer to
	}
	FILE *inFile;

		else if(strcmp(head1, head2) > 0){
			leftToMerge1 = leftToMerge2 = sizeToMerge;
        return false;

				}
								and	now I'm dealing with a lot of seg faults
		}
					DIE("addQ failed!");
				}
			}
		else{
					DIE("removeQ failed");
				qSize1 = qSize2;
		sizeToMerge *= 2;
								merging
			tmp = bigLeftToMerge1;
			if(!removeQ(&q2, &stringToAdd)){
	FILE *inFile;
					leftToMerge2--;
		// if we have excess on the first queue...the other queue should be
					}
					bigLeftToMerge1--;
2/29	4:00pm		1 hour		Discussed problem statement with Jared Weinstein
				}

#include <stdlib.h>
#include "/c/cs223/Hwk3/getLine.h"
	// if we've had an odd number of swaps, swap again to keep q1 as priority
								very far
			// if there's stuff left over from the first queue

		if(!removeQ(&q1, &stringToAdd)){
					DIE("addQ failed");
		qSize1 = qSize2;
		// this probably shouldn't ever happen but i'll do this just in case
					return 1;
	if(argc == 1){
	*b = dummy;
		printf("size to merge bottom: %d\n", sizeToMerge);
3/9		9:45pm 		1 hour		Identified a few bugs, trying to fix them
				DIE("removeQ failed");
// Function that takes in a pointer to a queue (q) and initializes it to point 

	if(!createQ(&q1) || !createQ(&q2)){
		printf("%s", stringToAdd);
			DIE("removeQ failed");
				if(!removeQ(&q1, &stringToAdd)){
			qSize2 = tmp;
#include <string.h>
				// add each line in q1
		}

	}
				bigLeftToMerge2--;
			// otherwise there's stuff left over from the second queue
	*q2 = dummy;
	}
	destroyQ(&q1);
				printf("left to merges: %d %d\n", leftToMerge1, leftToMerge2);
			DIE("File could not be opened!");
				// between the two queues
				qSize2 = tmp;
	
		if(!headQ(&q1, &head1) || !headQ(&q2, &head2)){
				return 1;
				if(!removeQ(&q2, &stringToAdd)){
		else{
					}
	FILE *inFile;

			DIE("File could not be opened!");
			if(!removeQ(&q2, &stringToAdd)){
			qSize2--;
				}
					}
					leftToMerge1--;
	if(qSize2 > qSize1){
				// compare the two values, remove from whichever one is smaller
		printf("%s", stringToAdd);
		}
		if(strcmp(head1, head2) < 0){

			}
				// now add the string to whichever queue we're currently adding to 
		// compare the two values, remove from whichever one is smaller
	if(argc == 1){
		}
					DIE("addQ() failed!");
						return 1;
				if(!headQ(&q1, &head1) || !headQ(&q2, &head2)){
	// the same time
				return 1;
		}
					DIE("headQ failed");
					return 1;
			}
3/3		10:15pm		1 hour		Worked out stable mergesort algorithm using two
	int firstFileArg = 1, sizeToMerge = 1, numElements = 0;
		// now we've finished the merging -- now some housekeeping
					if(!removeQ(&q1, &stringToAdd)){
				}
		inFile = fopen(argv[i], "r");
		while(bigLeftToMerge1 > 0){
		while(bigLeftToMerge1 > 0){

					return 1;
		// if LEN is not specified, the character after POS should be null
    else{
				return 1;
		printf("size to merge bottom: %d\n", sizeToMerge);
			if(!addQ(&q1, stringToAdd)){
					return 1;
				qSize1++;
			}
						DIE("removeQ failed");
				}
				}
#include "/c/cs223/Hwk3/getLine.h"
		else{
				return 1;
		bigLeftToMerge2 = qSize2;
void swap(Queue *q1, Queue *q2){

#define DIE(msg) exit(fprintf(stderr, "%s\n", msg))
			// otherwise there's stuff left over from the second queue

				qSize2 = tmp;
			}
	// now loop through the rest of the args and read them as files
			bigLeftToMerge1--;
				bigLeftToMerge1--;
		if(!headQ(&q1, &head1) || !headQ(&q2, &head2)){
			if(line1[1] < '0' || line1[1] > '9'){
	// we'll always add to q1, then swap each time
				// call headQ and store values into head1 and head2
						return 1;
#include <string.h>
		return 1;
					return 1;
	// 	argumentString = strcat(argumentString, argv[i]);
			}
					}
						DIE("removeQ failed");
				else if(strcmp(head1, head2) > 0){

					leftToMerge2--;
			}
					DIE("removeQ failed");
				bigLeftToMerge2--;
// From then on, just keep comparing heads until one of the queues is empty
	was empty, or had another line. Then I wrote a new getLine function which
		// now check if LEN is specified, and if it isn't, set it to INT_MAX
				qSize1++;
{
	*q1 = *q2;
			}
	int qSize1 = 0, qSize2 = 0, bigLeftToMerge2, bigLeftToMerge1;
				bigLeftToMerge2--;
				leftToMerge1--;

		else{
		return 1;
		if(inFile == NULL){
	}
3/9		4:30pm		1 hour		It now sorts but only handles powers of 2 and is
    if(isEmptyQ(q)){
	bigLeftToMerge2 = qSize2;
    }
				}
	}
				printf("bigLeftToMerges: %d %d\n", bigLeftToMerge1, bigLeftToMerge2);
					qPos2++;

    }
			// open the file and loop through the lines
				}
			len = strtol(line + 1, &line, 10);
		// call headQ and store values into head1 and head2

			// if there's stuff left over from the first queue
			while(qPos2 < stopMergeIndex2){
		qSize2 = tmp;
	worked between files, and it worked splendidly.
					DIE("addQ failed");
    // if the queue is empty, it has no head, so it fails
					DIE("addQ failed");

					qSize2--;
	}
			int tmp = qSize1;
				// we don't free since the queue still points to the same addr
			bigLeftToMerge1 = bigLeftToMerge2;
	// }
				printf("size we're merging: %d\n", sizeToMerge);
		// various indices)
					DIE("headQ failed");

// you finish the first merging, alternating which queue you push to
			if(!removeQ(&q1, &stringToAdd)){
			if(!removeQ(&q1, &stringToAdd)){
								merging
				}
					DIE("addQ failed");
						return 1;
		}
				}
#include "/c/cs223/Hwk4/Queue.h"
				printf("left to merges: %d %d\n", leftToMerge1, leftToMerge2);
				int tmp = qSize1;
	Queue dummy = *q1;

				numElements++;
		}
				DIE("addQ failed");
				if(!addQ(&q1, line)){
    }
	// if getLine doesn't fail, return its result
// and prints the sorted lines to the standard output
				return 1;
				}
				DIE("addQ failed");
	int qSize1 = 0, qSize2 = 0, bigLeftToMerge2, bigLeftToMerge1;
				else if(reversed){
				// first, which is the one that q1 originally pointed to
		stdInput = memset(stdInput, 0, strlen(line));
					return 1;
	int qSize1 = 0, qSize2 = 0, bigLeftToMerge2, bigLeftToMerge1;
		qSize1 = qSize2;
			DIE("removeQ failed");
				qSize1++;
	// //argumentString = memset(argumentString, '\0', argLength + 1);
		}
void swap(Queue *arg1, Queue *arg2);
		// empty
	for(int i = firstFileArg; i < argc; i++){
// you finish the first merging, alternating which queue you push to
		DIE("createQ() failed!");
								most functions								
			DIE("removeQ failed");
				if(!addQ(&q1, stringToAdd)){
			}
			tmp = bigLeftToMerge1;
					bigLeftToMerge1--;
	// we'll always add to q1, then swap each time
			//free(line);
	}
				// we don't free since the queue still points to the same addr
				leftToMerge1--;
			if(!removeQ(&q1, &stringToAdd)){
		bigLeftToMerge2 = qSize2;
	if(qSize2 > qSize1){

Difficulties I ran into:
				// if we have a tie, remove from the queue that has priority
				// between the two queues
	}
}
			qSize1 = qSize2;

			DIE("removeQ failed");
	while(!isEmptyQ(&q1) && !isEmptyQ(&q2)){
			bigLeftToMerge1--;
			bigLeftToMerge1 = bigLeftToMerge2;
				if(strcmp(head1, head2) < 0){

	// pos and len hold the POS,LEN command line options
    while(!isEmptyQ(q)){
	if(argv[1][0] == '-'){
			bigLeftToMerge1--;
		else if(strcmp(head1, head2) > 0){
	return 0;
					}
		// now check if LEN is specified, and if it isn't, set it to INT_MAX
			if(!removeQ(&q1, &stringToAdd)){
		}
					leftToMerge1--;
				if(!removeQ(&q2, &stringToAdd)){
	int leftToMerge1 = 1, leftToMerge2 = 1;
		// now we've finished the merging -- now some housekeeping
			}
					return 1;

			}
        return false;
			int tmp = qSize1;
		bigLeftToMerge2 = qSize2;
	}

			swap(&startSize1, &startSize2);
				numElements++;
		if(!headQ(&q1, &head1) || !headQ(&q2, &head2)){
			int tmp = qSize1;
						DIE("removeQ failed");
				DIE("removeQ failed");
		bigLeftToMerge2 = qSize2;
			bigLeftToMerge1 = bigLeftToMerge2;

			while(leftToMerge1 > 0){
			len = INT_MAX;
// function to swap two queues (i.e. swap the pointers to the two nodes)

		qSize1 = qSize2;

			}
	Queue dummy = *q1;
			}

				DIE("removeQ failed");
    *q = temp;
			}
				if(!addQ(&q1, stringToAdd)){

						return 1;
		if(strcmp(head1, head2) < 0){
					if(isEmptyQ(&q1)){
		// empty
				if(!addQ(&q1, line)){
						DIE("removeQ failed");
    Node *newNode = malloc(sizeof(Node));
					return 1;
			return 1;
					if(!removeQ(&q1, &stringToAdd)){
				}
		if(!removeQ(&q2, &stringToAdd)){
		if(!headQ(&q1, &head1) || !headQ(&q2, &head2)){
		if(inFile == NULL){
			DIE("removeQ failed");
					DIE("addQ failed");
				// switch up the queues so that you split up the strings
				DIE("removeQ failed");

		if(strcmp(head1, head2) < 0){
				bigLeftToMerge2--;
